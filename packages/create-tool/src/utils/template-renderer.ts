/**
 * Template Renderer Utility
 *
 * High-level utility for rendering all templates with tool metadata.
 * Maps metadata to template variables and orchestrates template generation.
 *
 * @module utils/template-renderer
 */

import { renderTemplateFile } from '../templates/template-loader';
import { toPascalCase, toCamelCase, toSnakeCase } from './string-helpers';

/**
 * Tool metadata interface (from Story 31.1.2)
 */
export interface ToolMetadata {
  toolId: string;
  toolName: string;
  description: string;
  icon: string;
  version: string;
  permissions: string[];
  features: {
    backend: boolean;
    database: boolean;
    service: boolean;
    component: boolean;
    tests: boolean;
    integrationTests: boolean;
  };
}

/**
 * Template data interface with all variables needed by templates
 */
export interface TemplateData extends ToolMetadata {
  // Generated identifiers
  className: string;
  serviceName: string;
  repositoryName: string;
  tableName: string;

  // Paths
  route: string;
  apiBase: string;

  // Metadata
  createdAt: string;
  author: string;
}

/**
 * Rendered template content object
 */
export interface RenderedTemplates {
  frontend: {
    component: string;
    componentHtml: string;
    componentCss: string;
    service: string;
    routes: string;
    menuItem: string;
    integration: string;
    componentSpec: string;
    serviceSpec: string;
  };
  backend: {
    controller: string;
    service: string;
    repository: string;
    routes: string;
    validator: string;
    migration: string;
    appIntegration: string;
  };
  shared: {
    types: string;
  };
  config: {
    readme: string;
  };
}

/**
 * Convert tool metadata to template data with all required variables.
 *
 * @param metadata - Tool metadata from prompts
 * @returns Complete template data object
 *
 * @example
 * ```typescript
 * const metadata = {
 *   toolId: 'inventory-tracker',
 *   toolName: 'Inventory Tracker',
 *   description: 'Track inventory items',
 *   // ... other fields
 * };
 * const templateData = mapMetadataToTemplateData(metadata);
 * // {
 * //   ...metadata,
 * //   className: 'InventoryTracker',
 * //   serviceName: 'inventoryTrackerService',
 * //   tableName: 'inventory_tracker',
 * //   ...
 * // }
 * ```
 */
export function mapMetadataToTemplateData(metadata: ToolMetadata): TemplateData {
  return {
    ...metadata,
    // Generated identifiers using name conversion utilities
    className: toPascalCase(metadata.toolId),
    serviceName: toCamelCase(metadata.toolId) + 'Service',
    repositoryName: toCamelCase(metadata.toolId) + 'Repository',
    tableName: toSnakeCase(metadata.toolId),

    // Paths
    route: `/tools/${metadata.toolId}`,
    apiBase: `/api/tools/${metadata.toolId}`,

    // Metadata
    createdAt: new Date().toISOString(),
    author: 'Generated by create-tool CLI',
  };
}

/**
 * Render all templates with provided metadata.
 * Loads and renders each template file, returning organized object.
 *
 * @param metadata - Tool metadata from prompts
 * @returns Promise containing all rendered template content
 * @throws {TemplateNotFoundError} When template file doesn't exist
 * @throws {EJSSyntaxError} When template has syntax errors
 * @throws {MissingVariableError} When required variables are undefined
 *
 * @example
 * ```typescript
 * const metadata = {
 *   toolId: 'inventory-tracker',
 *   toolName: 'Inventory Tracker',
 *   description: 'Track inventory items',
 *   icon: 'pi-box',
 *   version: '1.0.0',
 *   permissions: ['user', 'admin'],
 *   features: { backend: true, database: true, service: true, component: true, tests: false, integrationTests: false }
 * };
 *
 * const rendered = await renderAllTemplates(metadata);
 * // rendered.frontend.component = "import { Component } from '@angular/core';\n..."
 * // rendered.backend.controller = "import { Request, Response } from 'express';\n..."
 * ```
 */
export async function renderAllTemplates(metadata: ToolMetadata): Promise<RenderedTemplates> {
  // Map metadata to template data
  const templateData = mapMetadataToTemplateData(metadata);

  // Prepare features array for README template
  const featuresArray = [];
  if (metadata.features.component) featuresArray.push('Angular standalone component');
  if (metadata.features.service) featuresArray.push('Frontend service with API integration');
  if (metadata.features.backend) featuresArray.push('Express backend controller');
  if (metadata.features.database) featuresArray.push('PostgreSQL database repository');
  if (metadata.features.tests) featuresArray.push('Unit tests');
  if (metadata.features.integrationTests) featuresArray.push('Integration tests');

  const readmeData = {
    ...templateData,
    features: featuresArray,
  };

  try {
    // Render all templates in parallel for better performance
    const [
      // Frontend templates
      component,
      componentHtml,
      componentCss,
      service,
      routes,
      menuItem,
      integration,
      componentSpec,
      serviceSpec,
      // Backend templates
      controller,
      backendService,
      repository,
      backendRoutes,
      validator,
      migration,
      appIntegration,
      // Shared templates
      types,
      // Config templates
      readme,
    ] = await Promise.all([
      // Frontend
      renderTemplateFile('frontend/component.ts.ejs', templateData),
      renderTemplateFile('frontend/component.html.ejs', templateData),
      renderTemplateFile('frontend/component.css.ejs', templateData),
      renderTemplateFile('frontend/service.ts.ejs', templateData),
      renderTemplateFile('frontend/routes.ts.ejs', templateData),
      renderTemplateFile('frontend/menu-item.ts.ejs', templateData),
      renderTemplateFile('frontend/INTEGRATION.md.ejs', templateData),
      renderTemplateFile('frontend/component.spec.ts.ejs', templateData),
      renderTemplateFile('frontend/service.spec.ts.ejs', templateData),
      // Backend
      renderTemplateFile('backend/controller.ts.ejs', templateData),
      renderTemplateFile('backend/service.ts.ejs', templateData),
      renderTemplateFile('backend/repository.ts.ejs', templateData),
      renderTemplateFile('backend/routes.ts.ejs', templateData),
      renderTemplateFile('backend/validator.ts.ejs', templateData),
      renderTemplateFile('backend/migration-template.sql.ejs', templateData),
      renderTemplateFile('backend/app-integration.md.ejs', templateData),
      // Shared
      renderTemplateFile('shared/types.ts.ejs', templateData),
      // Config
      renderTemplateFile('config/README.md.ejs', readmeData),
    ]);

    return {
      frontend: {
        component,
        componentHtml,
        componentCss,
        service,
        routes,
        menuItem,
        integration,
        componentSpec,
        serviceSpec,
      },
      backend: {
        controller,
        service: backendService,
        repository,
        routes: backendRoutes,
        validator,
        migration,
        appIntegration,
      },
      shared: {
        types,
      },
      config: {
        readme,
      },
    };
  } catch (error) {
    // Re-throw with context about which template failed
    if (error instanceof Error) {
      throw new Error(`Failed to render templates: ${error.message}`);
    }
    throw error;
  }
}

/**
 * Get file paths for rendered templates based on tool ID.
 * Returns object mapping template types to their output file paths.
 *
 * @param toolId - Tool identifier (kebab-case)
 * @returns Object with file paths for each template
 *
 * @example
 * ```typescript
 * const paths = getTemplatePaths('inventory-tracker');
 * // {
 * //   frontend: {
 * //     component: 'apps/web/src/app/features/tools/inventory-tracker/inventory-tracker.component.ts',
 * //     ...
 * //   },
 * //   ...
 * // }
 * ```
 */
export function getTemplatePaths(toolId: string): Record<string, Record<string, string>> {
  return {
    frontend: {
      component: `apps/web/src/app/features/tools/${toolId}/${toolId}.component.ts`,
      componentHtml: `apps/web/src/app/features/tools/${toolId}/${toolId}.component.html`,
      componentCss: `apps/web/src/app/features/tools/${toolId}/${toolId}.component.css`,
      service: `apps/web/src/app/features/tools/${toolId}/${toolId}.service.ts`,
      routes: `apps/web/src/app/features/tools/${toolId}/${toolId}.routes.ts`,
    },
    backend: {
      controller: `apps/api/src/controllers/${toolId}.controller.ts`,
      service: `apps/api/src/services/${toolId}.service.ts`,
      repository: `apps/api/src/repositories/${toolId}.repository.ts`,
      routes: `apps/api/src/routes/${toolId}.routes.ts`,
      validator: `apps/api/src/validators/${toolId}.validator.ts`,
    },
    shared: {
      types: `packages/shared/src/types/${toolId}.types.ts`,
    },
    config: {
      readme: `apps/web/src/app/features/tools/${toolId}/README.md`,
    },
  };
}
