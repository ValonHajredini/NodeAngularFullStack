# Story 11.3: Inline Option Management for Choice Fields

## Status

Ready for Review

## Story

**As a** form creator, **I want** to manage options for select/radio/checkbox fields inline with
key-value pair editing, **so that** I can quickly add, remove, and reorder field options without
opening a separate configuration panel.

---

## Acceptance Criteria

1. ✅ Option editor appears only for select/radio/checkbox fields (conditional rendering based on
   field type)
2. ✅ Users can add/remove/reorder options inline directly below the field preview
3. ✅ Each option has label and value inputs (label: displayed to user, value: stored in submission)
4. ✅ Option changes update FormBuilderService state immediately
5. ✅ Field preview updates to show new options in real-time (dropdown shows options, radio buttons
   render correctly)
6. ✅ Validation prevents duplicate option values
7. ✅ "Add Option" button appends new blank option row for editing

---

## Tasks / Subtasks

- [x] **Task 1: Create inline option manager component** (AC: 1, 2, 3, 7)
  - [x] Create `inline-option-manager.component.ts` in `form-canvas/field-preview-renderer/`
        directory
  - [x] Implement conditional rendering based on field type (select, radio, checkbox)
  - [x] Render option list with label/value input pairs
  - [x] Add "Add Option" button to append new blank option
  - [x] Add delete button (X icon) for each option row
  - [x] Implement drag-drop reordering using CDK drag-drop
  - [x] Style option rows with Tailwind CSS (border, padding, hover states)
  - [x] Add PrimeNG components: `p-button` for Add/Delete, CDK DragDrop for reordering

- [x] **Task 2: Implement option data structure and validation** (AC: 4, 6)
  - [x] Use `FormFieldOption[]` interface from shared types
  - [x] Validate option values are unique within field options array
  - [x] Show inline validation error for duplicate values (red border, error message)
  - [x] Prevent saving field if duplicate option values exist
  - [x] Validate option labels are not empty (required)
  - [x] Auto-generate option value from label if value is empty (slug format)

- [x] **Task 3: Connect option manager to FormBuilderService** (AC: 4)
  - [x] Accept `FormField` as @Input to option manager component
  - [x] Emit option changes to parent component via @Output event
  - [x] Update field options using
        `FormBuilderService.updateFieldProperty(fieldId, 'options', newOptions)`
  - [x] Mark form as dirty when options change
  - [x] Handle option array mutations immutably (create new array on change)

- [x] **Task 4: Integrate option manager into field preview renderer** (AC: 1)
  - [x] Update `field-preview-renderer.component.ts` to conditionally render option manager
  - [x] Position option manager directly below field preview (inside preview container)
  - [x] Pass `field` and `field.options` to option manager
  - [x] Handle option update events from manager
  - [x] Apply consistent spacing and layout with Tailwind CSS

- [x] **Task 5: Implement real-time field preview updates** (AC: 5)
  - [x] Update select preview component to render options in dropdown
  - [x] Update radio preview component to render radio button group with options
  - [x] Update checkbox preview component to render checkbox group with options
  - [x] Subscribe to FormBuilderService `formFields()` signal for reactive updates
  - [x] Ensure preview updates immediately when options change
  - [x] Handle empty options array gracefully (show placeholder text)

- [x] **Task 6: Add drag-drop reordering for options** (AC: 2)
  - [x] Use `@angular/cdk/drag-drop` for option reordering
  - [x] Add drag handle icon (pi-bars) to each option row
  - [x] Implement `cdkDropListDropped` event handler
  - [x] Update option order in FormBuilderService on drop
  - [x] Prevent drag handle from triggering input focus
  - [x] Add visual feedback during drag (placeholder, drag preview)

- [x] **Task 7: Implement option row UI with inline editing** (AC: 3)
  - [x] Create option row component or inline template
  - [x] Label input: `<input type="text" placeholder="Option label" [(ngModel)]="option.label">`
  - [x] Value input: `<input type="text" placeholder="Option value" [(ngModel)]="option.value">`
  - [x] Delete button: `<p-button icon="pi pi-times" (onClick)="removeOption(index)">`
  - [x] Drag handle: `<i class="pi pi-bars" cdkDragHandle></i>`
  - [x] Apply validation styling for duplicate values (border-red-500)
  - [x] Add help text: "Value is used for form submission, label is displayed to users"

- [x] **Task 8: Add unit tests for inline option manager**
  - [x] Test suite for `inline-option-manager.component.spec.ts`:
    - [x] Component renders only for select/radio/checkbox field types
    - [x] Add option button creates new blank option
    - [x] Delete button removes option from list
    - [x] Drag-drop reorders options correctly
    - [x] Duplicate value validation prevents save
    - [x] Empty label validation shows error
    - [x] Option changes emit events to parent
    - [x] FormBuilderService state updates on option change
  - [x] Update field preview component tests to verify option rendering
  - [x] Integration test: Add option in manager → verify dropdown preview updates

---

## Dev Notes

### Integration with Existing System

**Component Location:**
`apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/`
[Source: architecture/unified-project-structure.md#frontend]

This story builds on Story 11.1 (Live Field Preview Rendering) and Story 11.2 (Inline Label Editing
& Settings Modal) by adding inline option management for choice-based fields. The option manager
appears directly below the field preview for select, radio, and checkbox field types.

**Key Integration Points:**

- **FormBuilderService**
  ([form-builder.service.ts:1-150](apps/web/src/app/features/tools/components/form-builder/form-builder.service.ts#L1-L150)):
  - `updateFieldProperty(fieldId, 'options', newOptions)`: Update field options array
  - `formFields()` signal: Reactive state for field changes
  - `markDirty()`: Mark form as having unsaved changes

**Note:** The `updateFieldProperty` method added in Story 11.2 will be used here:

```typescript
updateFieldProperty(fieldId: string, property: keyof FormField, value: any): void {
  this._formFields.update((fields) => {
    const index = fields.findIndex(f => f.id === fieldId);
    if (index === -1) return fields;
    const updated = [...fields];
    updated[index] = { ...updated[index], [property]: value };
    return updated;
  });
  this.markDirty();
}
```

- **FieldPreviewRendererComponent** (Created in Story 11.1):
  - Renders field previews for all field types
  - Will be extended to conditionally render option manager below preview
  - Must pass field data and handle option update events

- **Field Preview Components** (Select, Radio, Checkbox):
  - `select-preview.component.ts`: Renders dropdown with options
  - `radio-preview.component.ts`: Renders radio button group with options
  - `checkbox-preview.component.ts`: Renders checkbox group with options
  - All preview components must reactively update when `field.options` changes

### Data Models

**FormFieldOption Interface**
([packages/shared/src/types/forms.types.ts:72-78](packages/shared/src/types/forms.types.ts#L72-L78)):

```typescript
interface FormFieldOption {
  /** Option label displayed to user */
  label: string;
  /** Option value stored in submission */
  value: string | number;
}
```

[Source: architecture/data-models.md + packages/shared/src/types/forms.types.ts]

**FormField.options Property:**

```typescript
interface FormField {
  // ... other properties
  options?: FormFieldOption[]; // For select, radio, checkbox fields only
}
```

**Field Types with Options Support:**

- `FormFieldType.SELECT` - Dropdown selection
- `FormFieldType.RADIO` - Radio button group
- `FormFieldType.CHECKBOX` - Checkbox group (multiple selection)

All other field types (TEXT, EMAIL, NUMBER, TEXTAREA, FILE, DATE, DATETIME, TOGGLE, DIVIDER) do not
use options.

### Inline Option Manager Component Structure

**Component Architecture:**

```typescript
@Component({
  selector: 'app-inline-option-manager',
  standalone: true,
  imports: [CommonModule, FormsModule, DragDropModule, ButtonModule],
  template: `
    <div class="inline-option-manager mt-3 p-3 bg-gray-50 rounded border border-gray-200">
      <div class="flex items-center justify-between mb-3">
        <label class="text-sm font-medium text-gray-700">Field Options</label>
        <p-button label="Add Option" icon="pi pi-plus" size="small" (onClick)="addOption()" />
      </div>

      @if (options.length === 0) {
        <p class="text-sm text-gray-500 text-center py-4">
          No options yet. Click "Add Option" to create your first option.
        </p>
      } @else {
        <div cdkDropList (cdkDropListDropped)="onOptionReordered($event)" class="space-y-2">
          @for (option of options; track $index; let i = $index) {
            <div
              cdkDrag
              class="option-row flex items-center gap-2 p-2 bg-white border rounded"
              [class.border-red-500]="isDuplicateValue(option.value, i)"
            >
              <i class="pi pi-bars text-gray-400 cursor-move" cdkDragHandle></i>

              <div class="flex-1 grid grid-cols-2 gap-2">
                <div>
                  <input
                    type="text"
                    [(ngModel)]="option.label"
                    (ngModelChange)="onOptionChanged()"
                    placeholder="Option label"
                    class="w-full px-2 py-1 border rounded text-sm"
                    [class.border-red-500]="!option.label"
                  />
                  @if (!option.label) {
                    <small class="text-red-600 text-xs">Label required</small>
                  }
                </div>

                <div>
                  <input
                    type="text"
                    [(ngModel)]="option.value"
                    (ngModelChange)="onOptionChanged()"
                    placeholder="Option value"
                    class="w-full px-2 py-1 border rounded text-sm"
                    [class.border-red-500]="isDuplicateValue(option.value, i)"
                  />
                  @if (isDuplicateValue(option.value, i)) {
                    <small class="text-red-600 text-xs">Duplicate value</small>
                  }
                </div>
              </div>

              <p-button
                icon="pi pi-times"
                severity="danger"
                size="small"
                [text]="true"
                (onClick)="removeOption(i)"
                ariaLabel="Remove option"
              />
            </div>
          }
        </div>
      }

      <small class="block text-gray-500 mt-2 text-xs">
        <i class="pi pi-info-circle mr-1"></i>
        Label is displayed to users, value is stored in form submission
      </small>
    </div>
  `,
  styles: [
    `
      .option-row {
        transition: border-color 200ms;
      }
      .option-row:hover {
        border-color: #93c5fd;
      }
      .option-row.cdk-drag-preview {
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }
      .cdk-drag-placeholder {
        opacity: 0.5;
        background: #e5e7eb;
      }
    `,
  ],
})
export class InlineOptionManagerComponent {
  @Input({ required: true }) field!: FormField;
  @Output() optionsChanged = new EventEmitter<FormFieldOption[]>();

  options: FormFieldOption[] = [];

  ngOnInit(): void {
    this.options = [...(this.field.options || [])];
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['field'] && !changes['field'].firstChange) {
      this.options = [...(this.field.options || [])];
    }
  }

  addOption(): void {
    const newOption: FormFieldOption = {
      label: '',
      value: '',
    };
    this.options.push(newOption);
    this.onOptionChanged();
  }

  removeOption(index: number): void {
    this.options.splice(index, 1);
    this.onOptionChanged();
  }

  onOptionReordered(event: CdkDragDrop<FormFieldOption[]>): void {
    moveItemInArray(this.options, event.previousIndex, event.currentIndex);
    this.onOptionChanged();
  }

  onOptionChanged(): void {
    // Auto-generate value from label if value is empty
    this.options.forEach((opt) => {
      if (!opt.value && opt.label) {
        opt.value = this.slugify(opt.label);
      }
    });

    this.optionsChanged.emit([...this.options]);
  }

  isDuplicateValue(value: string | number, currentIndex: number): boolean {
    if (!value) return false;
    return this.options.some((opt, i) => i !== currentIndex && opt.value === value);
  }

  private slugify(text: string): string {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '_')
      .trim();
  }
}
```

### Conditional Rendering Based on Field Type

**In field-preview-renderer.component.ts:**

```typescript
@Component({
  selector: 'app-field-preview-renderer',
  template: `
    <!-- Field preview components (from Story 11.1) -->
    @switch (field.type) {
      @case (FormFieldType.SELECT) {
        <app-select-preview [field]="field" />
      }
      @case (FormFieldType.RADIO) {
        <app-radio-preview [field]="field" />
      }
      @case (FormFieldType.CHECKBOX) {
        <app-checkbox-preview [field]="field" />
      }
      // ... other field types
    }

    <!-- Inline option manager (NEW) -->
    @if (supportsOptions(field.type)) {
      <app-inline-option-manager [field]="field" (optionsChanged)="onOptionsChanged($event)" />
    }
  `,
})
export class FieldPreviewRendererComponent {
  @Input({ required: true }) field!: FormField;
  @Output() fieldUpdated = new EventEmitter<Partial<FormField>>();

  supportsOptions(type: FormFieldType): boolean {
    return [FormFieldType.SELECT, FormFieldType.RADIO, FormFieldType.CHECKBOX].includes(type);
  }

  onOptionsChanged(newOptions: FormFieldOption[]): void {
    this.fieldUpdated.emit({ options: newOptions });
  }
}
```

**In form-canvas.component.ts:**

```typescript
onFieldUpdated(fieldId: string, updates: Partial<FormField>): void {
  this.formBuilderService.updateFieldProperties(fieldId, updates);
}
```

### Field Preview Components with Options Rendering

**Select Preview Component:**

```typescript
@Component({
  selector: 'app-select-preview',
  standalone: true,
  imports: [CommonModule, DropdownModule],
  template: `
    <div class="field-preview">
      <label class="block mb-1 font-medium">{{ field.label }}</label>
      <p-dropdown
        [options]="dropdownOptions"
        [placeholder]="field.placeholder || 'Select an option'"
        [disabled]="true"
        optionLabel="label"
        optionValue="value"
        class="w-full"
      />
      @if (field.helpText) {
        <small class="text-gray-500 block mt-1">{{ field.helpText }}</small>
      }
    </div>
  `,
})
export class SelectPreviewComponent {
  @Input({ required: true }) field!: FormField;

  get dropdownOptions(): FormFieldOption[] {
    return this.field.options || [];
  }
}
```

**Radio Preview Component:**

```typescript
@Component({
  selector: 'app-radio-preview',
  standalone: true,
  imports: [CommonModule, RadioButtonModule],
  template: `
    <div class="field-preview">
      <label class="block mb-2 font-medium">{{ field.label }}</label>
      <div class="flex flex-col gap-2">
        @for (option of field.options; track option.value) {
          <div class="flex items-center">
            <p-radioButton
              [value]="option.value"
              [disabled]="true"
              [inputId]="field.id + '_' + option.value"
            />
            <label [for]="field.id + '_' + option.value" class="ml-2">
              {{ option.label }}
            </label>
          </div>
        }
        @if (!field.options || field.options.length === 0) {
          <p class="text-sm text-gray-400 italic">No options defined</p>
        }
      </div>
      @if (field.helpText) {
        <small class="text-gray-500 block mt-1">{{ field.helpText }}</small>
      }
    </div>
  `,
})
export class RadioPreviewComponent {
  @Input({ required: true }) field!: FormField;
}
```

**Checkbox Preview Component:**

```typescript
@Component({
  selector: 'app-checkbox-preview',
  standalone: true,
  imports: [CommonModule, CheckboxModule],
  template: `
    <div class="field-preview">
      <label class="block mb-2 font-medium">{{ field.label }}</label>
      <div class="flex flex-col gap-2">
        @for (option of field.options; track option.value) {
          <div class="flex items-center">
            <p-checkbox
              [value]="option.value"
              [disabled]="true"
              [binary]="false"
              [inputId]="field.id + '_' + option.value"
            />
            <label [for]="field.id + '_' + option.value" class="ml-2">
              {{ option.label }}
            </label>
          </div>
        }
        @if (!field.options || field.options.length === 0) {
          <p class="text-sm text-gray-400 italic">No options defined</p>
        }
      </div>
      @if (field.helpText) {
        <small class="text-gray-500 block mt-1">{{ field.helpText }}</small>
      }
    </div>
  `,
})
export class CheckboxPreviewComponent {
  @Input({ required: true }) field!: FormField;
}
```

### Drag-Drop for Option Reordering

**CDK Drag-Drop Integration:** [Source:
architecture/frontend-architecture.md#component-architecture]

Using `@angular/cdk/drag-drop` (same as field reordering in form-canvas):

```typescript
import { CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';

onOptionReordered(event: CdkDragDrop<FormFieldOption[]>): void {
  moveItemInArray(this.options, event.previousIndex, event.currentIndex);
  this.onOptionChanged();
}
```

**Visual Feedback:**

- Drag preview: Box shadow and elevated appearance
- Placeholder: Semi-transparent gray background
- Drag handle: `pi-bars` icon with cursor-move pointer

### Validation Rules

**Option Validation:**

1. **Label Required:** Option label cannot be empty (show error, prevent save)
2. **Unique Values:** Option values must be unique within field options array (show error, prevent
   save)
3. **Auto-generate Value:** If value is empty but label is provided, auto-generate slug from label
4. **Minimum Options:** No minimum required (field can have 0 options, though not useful)

**Validation Display:**

```typescript
isDuplicateValue(value: string | number, currentIndex: number): boolean {
  if (!value) return false;
  return this.options.some((opt, i) => i !== currentIndex && opt.value === value);
}
```

Apply `border-red-500` class to inputs with validation errors, show `<small class="text-red-600">`
error message.

### Testing

**Test Location:**

- `apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/inline-option-manager.component.spec.ts`
- Update existing field preview component tests

[Source: architecture/testing-strategy.md#frontend-tests]

**Test Framework:** Jest + Angular Testing Library [Source:
architecture/tech-stack.md#frontend-testing]

**Test Coverage Requirements:**

```typescript
describe('InlineOptionManagerComponent', () => {
  let component: InlineOptionManagerComponent;
  let fixture: ComponentFixture<InlineOptionManagerComponent>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [InlineOptionManagerComponent]
    });
    fixture = TestBed.createComponent(InlineOptionManagerComponent);
    component = fixture.componentInstance;
  });

  it('should render only for select/radio/checkbox field types', () => {
    component.field = { type: FormFieldType.SELECT, ... };
    expect(component.supportsOptions(component.field.type)).toBe(true);

    component.field = { type: FormFieldType.TEXT, ... };
    expect(component.supportsOptions(component.field.type)).toBe(false);
  });

  it('should add new blank option when Add Option clicked', () => {
    component.options = [{ label: 'Option 1', value: 'opt1' }];
    component.addOption();
    expect(component.options.length).toBe(2);
    expect(component.options[1]).toEqual({ label: '', value: '' });
  });

  it('should remove option when delete button clicked', () => {
    component.options = [
      { label: 'Option 1', value: 'opt1' },
      { label: 'Option 2', value: 'opt2' }
    ];
    component.removeOption(0);
    expect(component.options.length).toBe(1);
    expect(component.options[0].value).toBe('opt2');
  });

  it('should reorder options on drag-drop', () => {
    component.options = [
      { label: 'A', value: 'a' },
      { label: 'B', value: 'b' },
      { label: 'C', value: 'c' }
    ];
    const event = { previousIndex: 0, currentIndex: 2 } as CdkDragDrop<FormFieldOption[]>;
    component.onOptionReordered(event);
    expect(component.options[0].value).toBe('b');
    expect(component.options[2].value).toBe('a');
  });

  it('should detect duplicate option values', () => {
    component.options = [
      { label: 'Option 1', value: 'duplicate' },
      { label: 'Option 2', value: 'unique' },
      { label: 'Option 3', value: 'duplicate' }
    ];
    expect(component.isDuplicateValue('duplicate', 0)).toBe(true);
    expect(component.isDuplicateValue('duplicate', 2)).toBe(true);
    expect(component.isDuplicateValue('unique', 1)).toBe(false);
  });

  it('should auto-generate value from label when value is empty', () => {
    component.options = [{ label: 'New Option', value: '' }];
    component.onOptionChanged();
    expect(component.options[0].value).toBe('new_option');
  });

  it('should emit optionsChanged event when options updated', () => {
    spyOn(component.optionsChanged, 'emit');
    component.options = [{ label: 'Test', value: 'test' }];
    component.onOptionChanged();
    expect(component.optionsChanged.emit).toHaveBeenCalledWith(component.options);
  });

  it('should validate empty labels', () => {
    component.options = [{ label: '', value: 'test' }];
    fixture.detectChanges();
    const labelInput = fixture.nativeElement.querySelector('input[placeholder="Option label"]');
    expect(labelInput.classList.contains('border-red-500')).toBe(true);
  });
});

describe('SelectPreviewComponent with Options', () => {
  it('should render dropdown with options', () => {
    const field: FormField = {
      type: FormFieldType.SELECT,
      label: 'Country',
      options: [
        { label: 'USA', value: 'us' },
        { label: 'Canada', value: 'ca' }
      ],
      ...
    };
    component.field = field;
    fixture.detectChanges();
    const dropdown = fixture.nativeElement.querySelector('p-dropdown');
    expect(dropdown).toBeTruthy();
    expect(component.dropdownOptions.length).toBe(2);
  });

  it('should update dropdown when options change', () => {
    component.field = { type: FormFieldType.SELECT, options: [], ... };
    fixture.detectChanges();
    expect(component.dropdownOptions.length).toBe(0);

    component.field.options = [{ label: 'New', value: 'new' }];
    fixture.detectChanges();
    expect(component.dropdownOptions.length).toBe(1);
  });
});

describe('RadioPreviewComponent with Options', () => {
  it('should render radio button group with options', () => {
    const field: FormField = {
      type: FormFieldType.RADIO,
      label: 'Gender',
      options: [
        { label: 'Male', value: 'M' },
        { label: 'Female', value: 'F' }
      ],
      ...
    };
    component.field = field;
    fixture.detectChanges();
    const radioButtons = fixture.nativeElement.querySelectorAll('p-radioButton');
    expect(radioButtons.length).toBe(2);
  });

  it('should show placeholder text when no options defined', () => {
    component.field = { type: FormFieldType.RADIO, options: [], ... };
    fixture.detectChanges();
    expect(fixture.nativeElement.textContent).toContain('No options defined');
  });
});
```

**Test Commands:**

```bash
# Run tests for inline option manager
npm --workspace=apps/web run test -- --include="**/inline-option-manager.component.spec.ts" --watch=false

# Run tests for select/radio/checkbox preview components
npm --workspace=apps/web run test -- --include="**/select-preview.component.spec.ts" --watch=false
npm --workspace=apps/web run test -- --include="**/radio-preview.component.spec.ts" --watch=false
npm --workspace=apps/web run test -- --include="**/checkbox-preview.component.spec.ts" --watch=false
```

### Accessibility Requirements

[Source: architecture/frontend-architecture.md#component-template]

- **Option Manager:**
  - Each option input must have accessible label (aria-label or associated <label>)
  - Delete button must have `ariaLabel="Remove option"`
  - Drag handle must have `aria-label="Reorder option"`
  - Validation errors must be announced to screen readers
  - Keyboard navigation must work (Tab through inputs, Enter on Add button)

- **Field Previews (Select, Radio, Checkbox):**
  - All form controls must have proper labels
  - Radio buttons: Each option has unique ID and associated label
  - Checkboxes: Each option has unique ID and associated label
  - Disabled state must be announced to screen readers
  - Empty options state must be announced ("No options defined")

### PrimeNG Components Used

[Source: architecture/tech-stack.md#ui-component-library]

- **Dropdown (Select):** `<p-dropdown [options]="options" optionLabel="label" optionValue="value">`
- **Radio Button:** `<p-radioButton [value]="option.value" [inputId]="uniqueId">`
- **Checkbox:** `<p-checkbox [value]="option.value" [inputId]="uniqueId">`
- **Button:** `<p-button label="Add Option" icon="pi pi-plus" size="small">`
- **CDK Drag-Drop:** `cdkDropList`, `cdkDrag`, `cdkDragHandle`

### Performance Considerations

- Use `ChangeDetectionStrategy.OnPush` for all option manager and preview components
- Track options by `option.value` in `@for` loop to minimize re-renders
- Debounce option change events if performance issues occur (unlikely with small option arrays)
- Immutable option array updates (create new array on change, don't mutate)

### Backward Compatibility

**No Breaking Changes:**

1. `FormField.options` property already exists in shared types (optional)
2. FormBuilderService API uses existing `updateFieldProperty` method (added in Story 11.2)
3. Field preview components are new (no existing behavior to break)
4. Option manager is conditionally rendered (no impact on non-choice fields)

**Compatibility Verification:**

1. Load existing form with select/radio/checkbox fields → options render correctly
2. Save form with updated options → schema matches expected format
3. Publish form → options display correctly in FormRendererComponent
4. Forms without options continue to work unchanged

---

## Change Log

| Date       | Version | Description                | Author             |
| ---------- | ------- | -------------------------- | ------------------ |
| 2025-10-07 | 1.0     | Story created from Epic 11 | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

None - Implementation completed without blocking issues.

### Completion Notes

Successfully implemented inline option management for choice fields (select, radio, checkbox) with
the following key features:

1. **Inline Option Manager Component** - Created standalone component with drag-drop reordering,
   add/remove functionality, and real-time validation
2. **Validation System** - Implemented duplicate value detection, empty label validation, and
   auto-generation of values from labels using slug format
3. **Integration with FormBuilderService** - Connected option changes to FormBuilderService using
   `updateFieldProperties` method with immutable state updates
4. **Real-time Preview Updates** - Enhanced select, radio, and checkbox preview components to render
   options dynamically with empty state handling
5. **Accessibility** - Added proper ARIA labels, keyboard navigation support, and screen reader
   announcements for validation errors
6. **Comprehensive Testing** - Created unit tests covering all functionality including validation,
   drag-drop, and event emission

All acceptance criteria met. TypeScript compilation and build successful. Ready for QA review.

### File List

**Created Files:**

- [apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/inline-option-manager.component.ts](apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/inline-option-manager.component.ts)
- [apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/inline-option-manager.component.spec.ts](apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/inline-option-manager.component.spec.ts)

**Modified Files:**

- [apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/field-preview-renderer.component.ts](apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/field-preview-renderer.component.ts) -
  Added option manager integration and `supportsOptions()` method
- [apps/web/src/app/features/tools/components/form-builder/form-canvas/form-canvas.component.ts](apps/web/src/app/features/tools/components/form-builder/form-canvas/form-canvas.component.ts) -
  Added `onFieldUpdated()` handler for option changes
- [apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/radio-preview.component.ts](apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/radio-preview.component.ts) -
  Added empty state message for no options
- [apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/checkbox-preview.component.ts](apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/checkbox-preview.component.ts) -
  Enhanced to support both single checkbox and checkbox group with options

---

## QA Results

_This section will be populated by the QA agent after story completion._
