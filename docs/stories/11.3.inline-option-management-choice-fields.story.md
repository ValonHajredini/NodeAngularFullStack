# Story 11.3: Inline Option Management for Choice Fields

## Status

Draft

## Story

**As a** form creator, **I want** to manage options for select/radio/checkbox fields inline with
key-value pair editing, **so that** I can quickly add, remove, and reorder field options without
opening a separate configuration panel.

---

## Acceptance Criteria

1. ✅ Option editor appears only for select/radio/checkbox fields (conditional rendering based on
   field type)
2. ✅ Users can add/remove/reorder options inline directly below the field preview
3. ✅ Each option has label and value inputs (label: displayed to user, value: stored in submission)
4. ✅ Option changes update FormBuilderService state immediately
5. ✅ Field preview updates to show new options in real-time (dropdown shows options, radio buttons
   render correctly)
6. ✅ Validation prevents duplicate option values
7. ✅ "Add Option" button appends new blank option row for editing

---

## Tasks / Subtasks

- [ ] **Task 1: Create inline option manager component** (AC: 1, 2, 3, 7)
  - [ ] Create `inline-option-manager.component.ts` in `form-canvas/field-preview-renderer/`
        directory
  - [ ] Implement conditional rendering based on field type (select, radio, checkbox)
  - [ ] Render option list with label/value input pairs
  - [ ] Add "Add Option" button to append new blank option
  - [ ] Add delete button (X icon) for each option row
  - [ ] Implement drag-drop reordering using CDK drag-drop
  - [ ] Style option rows with Tailwind CSS (border, padding, hover states)
  - [ ] Add PrimeNG components: `p-button` for Add/Delete, CDK DragDrop for reordering

- [ ] **Task 2: Implement option data structure and validation** (AC: 4, 6)
  - [ ] Use `FormFieldOption[]` interface from shared types
  - [ ] Validate option values are unique within field options array
  - [ ] Show inline validation error for duplicate values (red border, error message)
  - [ ] Prevent saving field if duplicate option values exist
  - [ ] Validate option labels are not empty (required)
  - [ ] Auto-generate option value from label if value is empty (slug format)

- [ ] **Task 3: Connect option manager to FormBuilderService** (AC: 4)
  - [ ] Accept `FormField` as @Input to option manager component
  - [ ] Emit option changes to parent component via @Output event
  - [ ] Update field options using
        `FormBuilderService.updateFieldProperty(fieldId, 'options', newOptions)`
  - [ ] Mark form as dirty when options change
  - [ ] Handle option array mutations immutably (create new array on change)

- [ ] **Task 4: Integrate option manager into field preview renderer** (AC: 1)
  - [ ] Update `field-preview-renderer.component.ts` to conditionally render option manager
  - [ ] Position option manager directly below field preview (inside preview container)
  - [ ] Pass `field` and `field.options` to option manager
  - [ ] Handle option update events from manager
  - [ ] Apply consistent spacing and layout with Tailwind CSS

- [ ] **Task 5: Implement real-time field preview updates** (AC: 5)
  - [ ] Update select preview component to render options in dropdown
  - [ ] Update radio preview component to render radio button group with options
  - [ ] Update checkbox preview component to render checkbox group with options
  - [ ] Subscribe to FormBuilderService `formFields()` signal for reactive updates
  - [ ] Ensure preview updates immediately when options change
  - [ ] Handle empty options array gracefully (show placeholder text)

- [ ] **Task 6: Add drag-drop reordering for options** (AC: 2)
  - [ ] Use `@angular/cdk/drag-drop` for option reordering
  - [ ] Add drag handle icon (pi-bars) to each option row
  - [ ] Implement `cdkDropListDropped` event handler
  - [ ] Update option order in FormBuilderService on drop
  - [ ] Prevent drag handle from triggering input focus
  - [ ] Add visual feedback during drag (placeholder, drag preview)

- [ ] **Task 7: Implement option row UI with inline editing** (AC: 3)
  - [ ] Create option row component or inline template
  - [ ] Label input: `<input type="text" placeholder="Option label" [(ngModel)]="option.label">`
  - [ ] Value input: `<input type="text" placeholder="Option value" [(ngModel)]="option.value">`
  - [ ] Delete button: `<p-button icon="pi pi-times" (onClick)="removeOption(index)">`
  - [ ] Drag handle: `<i class="pi pi-bars" cdkDragHandle></i>`
  - [ ] Apply validation styling for duplicate values (border-red-500)
  - [ ] Add help text: "Value is used for form submission, label is displayed to users"

- [ ] **Task 8: Add unit tests for inline option manager**
  - [ ] Test suite for `inline-option-manager.component.spec.ts`:
    - [ ] Component renders only for select/radio/checkbox field types
    - [ ] Add option button creates new blank option
    - [ ] Delete button removes option from list
    - [ ] Drag-drop reorders options correctly
    - [ ] Duplicate value validation prevents save
    - [ ] Empty label validation shows error
    - [ ] Option changes emit events to parent
    - [ ] FormBuilderService state updates on option change
  - [ ] Update field preview component tests to verify option rendering
  - [ ] Integration test: Add option in manager → verify dropdown preview updates

---

## Dev Notes

### Integration with Existing System

**Component Location:**
`apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/`
[Source: architecture/unified-project-structure.md#frontend]

This story builds on Story 11.1 (Live Field Preview Rendering) and Story 11.2 (Inline Label Editing
& Settings Modal) by adding inline option management for choice-based fields. The option manager
appears directly below the field preview for select, radio, and checkbox field types.

**Key Integration Points:**

- **FormBuilderService**
  ([form-builder.service.ts:1-150](apps/web/src/app/features/tools/components/form-builder/form-builder.service.ts#L1-L150)):
  - `updateFieldProperty(fieldId, 'options', newOptions)`: Update field options array
  - `formFields()` signal: Reactive state for field changes
  - `markDirty()`: Mark form as having unsaved changes

**Note:** The `updateFieldProperty` method added in Story 11.2 will be used here:

```typescript
updateFieldProperty(fieldId: string, property: keyof FormField, value: any): void {
  this._formFields.update((fields) => {
    const index = fields.findIndex(f => f.id === fieldId);
    if (index === -1) return fields;
    const updated = [...fields];
    updated[index] = { ...updated[index], [property]: value };
    return updated;
  });
  this.markDirty();
}
```

- **FieldPreviewRendererComponent** (Created in Story 11.1):
  - Renders field previews for all field types
  - Will be extended to conditionally render option manager below preview
  - Must pass field data and handle option update events

- **Field Preview Components** (Select, Radio, Checkbox):
  - `select-preview.component.ts`: Renders dropdown with options
  - `radio-preview.component.ts`: Renders radio button group with options
  - `checkbox-preview.component.ts`: Renders checkbox group with options
  - All preview components must reactively update when `field.options` changes

### Data Models

**FormFieldOption Interface**
([packages/shared/src/types/forms.types.ts:72-78](packages/shared/src/types/forms.types.ts#L72-L78)):

```typescript
interface FormFieldOption {
  /** Option label displayed to user */
  label: string;
  /** Option value stored in submission */
  value: string | number;
}
```

[Source: architecture/data-models.md + packages/shared/src/types/forms.types.ts]

**FormField.options Property:**

```typescript
interface FormField {
  // ... other properties
  options?: FormFieldOption[]; // For select, radio, checkbox fields only
}
```

**Field Types with Options Support:**

- `FormFieldType.SELECT` - Dropdown selection
- `FormFieldType.RADIO` - Radio button group
- `FormFieldType.CHECKBOX` - Checkbox group (multiple selection)

All other field types (TEXT, EMAIL, NUMBER, TEXTAREA, FILE, DATE, DATETIME, TOGGLE, DIVIDER) do not
use options.

### Inline Option Manager Component Structure

**Component Architecture:**

```typescript
@Component({
  selector: 'app-inline-option-manager',
  standalone: true,
  imports: [CommonModule, FormsModule, DragDropModule, ButtonModule],
  template: `
    <div class="inline-option-manager mt-3 p-3 bg-gray-50 rounded border border-gray-200">
      <div class="flex items-center justify-between mb-3">
        <label class="text-sm font-medium text-gray-700">Field Options</label>
        <p-button label="Add Option" icon="pi pi-plus" size="small" (onClick)="addOption()" />
      </div>

      @if (options.length === 0) {
        <p class="text-sm text-gray-500 text-center py-4">
          No options yet. Click "Add Option" to create your first option.
        </p>
      } @else {
        <div cdkDropList (cdkDropListDropped)="onOptionReordered($event)" class="space-y-2">
          @for (option of options; track $index; let i = $index) {
            <div
              cdkDrag
              class="option-row flex items-center gap-2 p-2 bg-white border rounded"
              [class.border-red-500]="isDuplicateValue(option.value, i)"
            >
              <i class="pi pi-bars text-gray-400 cursor-move" cdkDragHandle></i>

              <div class="flex-1 grid grid-cols-2 gap-2">
                <div>
                  <input
                    type="text"
                    [(ngModel)]="option.label"
                    (ngModelChange)="onOptionChanged()"
                    placeholder="Option label"
                    class="w-full px-2 py-1 border rounded text-sm"
                    [class.border-red-500]="!option.label"
                  />
                  @if (!option.label) {
                    <small class="text-red-600 text-xs">Label required</small>
                  }
                </div>

                <div>
                  <input
                    type="text"
                    [(ngModel)]="option.value"
                    (ngModelChange)="onOptionChanged()"
                    placeholder="Option value"
                    class="w-full px-2 py-1 border rounded text-sm"
                    [class.border-red-500]="isDuplicateValue(option.value, i)"
                  />
                  @if (isDuplicateValue(option.value, i)) {
                    <small class="text-red-600 text-xs">Duplicate value</small>
                  }
                </div>
              </div>

              <p-button
                icon="pi pi-times"
                severity="danger"
                size="small"
                [text]="true"
                (onClick)="removeOption(i)"
                ariaLabel="Remove option"
              />
            </div>
          }
        </div>
      }

      <small class="block text-gray-500 mt-2 text-xs">
        <i class="pi pi-info-circle mr-1"></i>
        Label is displayed to users, value is stored in form submission
      </small>
    </div>
  `,
  styles: [
    `
      .option-row {
        transition: border-color 200ms;
      }
      .option-row:hover {
        border-color: #93c5fd;
      }
      .option-row.cdk-drag-preview {
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }
      .cdk-drag-placeholder {
        opacity: 0.5;
        background: #e5e7eb;
      }
    `,
  ],
})
export class InlineOptionManagerComponent {
  @Input({ required: true }) field!: FormField;
  @Output() optionsChanged = new EventEmitter<FormFieldOption[]>();

  options: FormFieldOption[] = [];

  ngOnInit(): void {
    this.options = [...(this.field.options || [])];
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['field'] && !changes['field'].firstChange) {
      this.options = [...(this.field.options || [])];
    }
  }

  addOption(): void {
    const newOption: FormFieldOption = {
      label: '',
      value: '',
    };
    this.options.push(newOption);
    this.onOptionChanged();
  }

  removeOption(index: number): void {
    this.options.splice(index, 1);
    this.onOptionChanged();
  }

  onOptionReordered(event: CdkDragDrop<FormFieldOption[]>): void {
    moveItemInArray(this.options, event.previousIndex, event.currentIndex);
    this.onOptionChanged();
  }

  onOptionChanged(): void {
    // Auto-generate value from label if value is empty
    this.options.forEach((opt) => {
      if (!opt.value && opt.label) {
        opt.value = this.slugify(opt.label);
      }
    });

    this.optionsChanged.emit([...this.options]);
  }

  isDuplicateValue(value: string | number, currentIndex: number): boolean {
    if (!value) return false;
    return this.options.some((opt, i) => i !== currentIndex && opt.value === value);
  }

  private slugify(text: string): string {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '_')
      .trim();
  }
}
```

### Conditional Rendering Based on Field Type

**In field-preview-renderer.component.ts:**

```typescript
@Component({
  selector: 'app-field-preview-renderer',
  template: `
    <!-- Field preview components (from Story 11.1) -->
    @switch (field.type) {
      @case (FormFieldType.SELECT) {
        <app-select-preview [field]="field" />
      }
      @case (FormFieldType.RADIO) {
        <app-radio-preview [field]="field" />
      }
      @case (FormFieldType.CHECKBOX) {
        <app-checkbox-preview [field]="field" />
      }
      // ... other field types
    }

    <!-- Inline option manager (NEW) -->
    @if (supportsOptions(field.type)) {
      <app-inline-option-manager [field]="field" (optionsChanged)="onOptionsChanged($event)" />
    }
  `,
})
export class FieldPreviewRendererComponent {
  @Input({ required: true }) field!: FormField;
  @Output() fieldUpdated = new EventEmitter<Partial<FormField>>();

  supportsOptions(type: FormFieldType): boolean {
    return [FormFieldType.SELECT, FormFieldType.RADIO, FormFieldType.CHECKBOX].includes(type);
  }

  onOptionsChanged(newOptions: FormFieldOption[]): void {
    this.fieldUpdated.emit({ options: newOptions });
  }
}
```

**In form-canvas.component.ts:**

```typescript
onFieldUpdated(fieldId: string, updates: Partial<FormField>): void {
  this.formBuilderService.updateFieldProperties(fieldId, updates);
}
```

### Field Preview Components with Options Rendering

**Select Preview Component:**

```typescript
@Component({
  selector: 'app-select-preview',
  standalone: true,
  imports: [CommonModule, DropdownModule],
  template: `
    <div class="field-preview">
      <label class="block mb-1 font-medium">{{ field.label }}</label>
      <p-dropdown
        [options]="dropdownOptions"
        [placeholder]="field.placeholder || 'Select an option'"
        [disabled]="true"
        optionLabel="label"
        optionValue="value"
        class="w-full"
      />
      @if (field.helpText) {
        <small class="text-gray-500 block mt-1">{{ field.helpText }}</small>
      }
    </div>
  `,
})
export class SelectPreviewComponent {
  @Input({ required: true }) field!: FormField;

  get dropdownOptions(): FormFieldOption[] {
    return this.field.options || [];
  }
}
```

**Radio Preview Component:**

```typescript
@Component({
  selector: 'app-radio-preview',
  standalone: true,
  imports: [CommonModule, RadioButtonModule],
  template: `
    <div class="field-preview">
      <label class="block mb-2 font-medium">{{ field.label }}</label>
      <div class="flex flex-col gap-2">
        @for (option of field.options; track option.value) {
          <div class="flex items-center">
            <p-radioButton
              [value]="option.value"
              [disabled]="true"
              [inputId]="field.id + '_' + option.value"
            />
            <label [for]="field.id + '_' + option.value" class="ml-2">
              {{ option.label }}
            </label>
          </div>
        }
        @if (!field.options || field.options.length === 0) {
          <p class="text-sm text-gray-400 italic">No options defined</p>
        }
      </div>
      @if (field.helpText) {
        <small class="text-gray-500 block mt-1">{{ field.helpText }}</small>
      }
    </div>
  `,
})
export class RadioPreviewComponent {
  @Input({ required: true }) field!: FormField;
}
```

**Checkbox Preview Component:**

```typescript
@Component({
  selector: 'app-checkbox-preview',
  standalone: true,
  imports: [CommonModule, CheckboxModule],
  template: `
    <div class="field-preview">
      <label class="block mb-2 font-medium">{{ field.label }}</label>
      <div class="flex flex-col gap-2">
        @for (option of field.options; track option.value) {
          <div class="flex items-center">
            <p-checkbox
              [value]="option.value"
              [disabled]="true"
              [binary]="false"
              [inputId]="field.id + '_' + option.value"
            />
            <label [for]="field.id + '_' + option.value" class="ml-2">
              {{ option.label }}
            </label>
          </div>
        }
        @if (!field.options || field.options.length === 0) {
          <p class="text-sm text-gray-400 italic">No options defined</p>
        }
      </div>
      @if (field.helpText) {
        <small class="text-gray-500 block mt-1">{{ field.helpText }}</small>
      }
    </div>
  `,
})
export class CheckboxPreviewComponent {
  @Input({ required: true }) field!: FormField;
}
```

### Drag-Drop for Option Reordering

**CDK Drag-Drop Integration:** [Source:
architecture/frontend-architecture.md#component-architecture]

Using `@angular/cdk/drag-drop` (same as field reordering in form-canvas):

```typescript
import { CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';

onOptionReordered(event: CdkDragDrop<FormFieldOption[]>): void {
  moveItemInArray(this.options, event.previousIndex, event.currentIndex);
  this.onOptionChanged();
}
```

**Visual Feedback:**

- Drag preview: Box shadow and elevated appearance
- Placeholder: Semi-transparent gray background
- Drag handle: `pi-bars` icon with cursor-move pointer

### Validation Rules

**Option Validation:**

1. **Label Required:** Option label cannot be empty (show error, prevent save)
2. **Unique Values:** Option values must be unique within field options array (show error, prevent
   save)
3. **Auto-generate Value:** If value is empty but label is provided, auto-generate slug from label
4. **Minimum Options:** No minimum required (field can have 0 options, though not useful)

**Validation Display:**

```typescript
isDuplicateValue(value: string | number, currentIndex: number): boolean {
  if (!value) return false;
  return this.options.some((opt, i) => i !== currentIndex && opt.value === value);
}
```

Apply `border-red-500` class to inputs with validation errors, show `<small class="text-red-600">`
error message.

### Testing

**Test Location:**

- `apps/web/src/app/features/tools/components/form-builder/form-canvas/field-preview-renderer/inline-option-manager.component.spec.ts`
- Update existing field preview component tests

[Source: architecture/testing-strategy.md#frontend-tests]

**Test Framework:** Jest + Angular Testing Library [Source:
architecture/tech-stack.md#frontend-testing]

**Test Coverage Requirements:**

```typescript
describe('InlineOptionManagerComponent', () => {
  let component: InlineOptionManagerComponent;
  let fixture: ComponentFixture<InlineOptionManagerComponent>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [InlineOptionManagerComponent]
    });
    fixture = TestBed.createComponent(InlineOptionManagerComponent);
    component = fixture.componentInstance;
  });

  it('should render only for select/radio/checkbox field types', () => {
    component.field = { type: FormFieldType.SELECT, ... };
    expect(component.supportsOptions(component.field.type)).toBe(true);

    component.field = { type: FormFieldType.TEXT, ... };
    expect(component.supportsOptions(component.field.type)).toBe(false);
  });

  it('should add new blank option when Add Option clicked', () => {
    component.options = [{ label: 'Option 1', value: 'opt1' }];
    component.addOption();
    expect(component.options.length).toBe(2);
    expect(component.options[1]).toEqual({ label: '', value: '' });
  });

  it('should remove option when delete button clicked', () => {
    component.options = [
      { label: 'Option 1', value: 'opt1' },
      { label: 'Option 2', value: 'opt2' }
    ];
    component.removeOption(0);
    expect(component.options.length).toBe(1);
    expect(component.options[0].value).toBe('opt2');
  });

  it('should reorder options on drag-drop', () => {
    component.options = [
      { label: 'A', value: 'a' },
      { label: 'B', value: 'b' },
      { label: 'C', value: 'c' }
    ];
    const event = { previousIndex: 0, currentIndex: 2 } as CdkDragDrop<FormFieldOption[]>;
    component.onOptionReordered(event);
    expect(component.options[0].value).toBe('b');
    expect(component.options[2].value).toBe('a');
  });

  it('should detect duplicate option values', () => {
    component.options = [
      { label: 'Option 1', value: 'duplicate' },
      { label: 'Option 2', value: 'unique' },
      { label: 'Option 3', value: 'duplicate' }
    ];
    expect(component.isDuplicateValue('duplicate', 0)).toBe(true);
    expect(component.isDuplicateValue('duplicate', 2)).toBe(true);
    expect(component.isDuplicateValue('unique', 1)).toBe(false);
  });

  it('should auto-generate value from label when value is empty', () => {
    component.options = [{ label: 'New Option', value: '' }];
    component.onOptionChanged();
    expect(component.options[0].value).toBe('new_option');
  });

  it('should emit optionsChanged event when options updated', () => {
    spyOn(component.optionsChanged, 'emit');
    component.options = [{ label: 'Test', value: 'test' }];
    component.onOptionChanged();
    expect(component.optionsChanged.emit).toHaveBeenCalledWith(component.options);
  });

  it('should validate empty labels', () => {
    component.options = [{ label: '', value: 'test' }];
    fixture.detectChanges();
    const labelInput = fixture.nativeElement.querySelector('input[placeholder="Option label"]');
    expect(labelInput.classList.contains('border-red-500')).toBe(true);
  });
});

describe('SelectPreviewComponent with Options', () => {
  it('should render dropdown with options', () => {
    const field: FormField = {
      type: FormFieldType.SELECT,
      label: 'Country',
      options: [
        { label: 'USA', value: 'us' },
        { label: 'Canada', value: 'ca' }
      ],
      ...
    };
    component.field = field;
    fixture.detectChanges();
    const dropdown = fixture.nativeElement.querySelector('p-dropdown');
    expect(dropdown).toBeTruthy();
    expect(component.dropdownOptions.length).toBe(2);
  });

  it('should update dropdown when options change', () => {
    component.field = { type: FormFieldType.SELECT, options: [], ... };
    fixture.detectChanges();
    expect(component.dropdownOptions.length).toBe(0);

    component.field.options = [{ label: 'New', value: 'new' }];
    fixture.detectChanges();
    expect(component.dropdownOptions.length).toBe(1);
  });
});

describe('RadioPreviewComponent with Options', () => {
  it('should render radio button group with options', () => {
    const field: FormField = {
      type: FormFieldType.RADIO,
      label: 'Gender',
      options: [
        { label: 'Male', value: 'M' },
        { label: 'Female', value: 'F' }
      ],
      ...
    };
    component.field = field;
    fixture.detectChanges();
    const radioButtons = fixture.nativeElement.querySelectorAll('p-radioButton');
    expect(radioButtons.length).toBe(2);
  });

  it('should show placeholder text when no options defined', () => {
    component.field = { type: FormFieldType.RADIO, options: [], ... };
    fixture.detectChanges();
    expect(fixture.nativeElement.textContent).toContain('No options defined');
  });
});
```

**Test Commands:**

```bash
# Run tests for inline option manager
npm --workspace=apps/web run test -- --include="**/inline-option-manager.component.spec.ts" --watch=false

# Run tests for select/radio/checkbox preview components
npm --workspace=apps/web run test -- --include="**/select-preview.component.spec.ts" --watch=false
npm --workspace=apps/web run test -- --include="**/radio-preview.component.spec.ts" --watch=false
npm --workspace=apps/web run test -- --include="**/checkbox-preview.component.spec.ts" --watch=false
```

### Accessibility Requirements

[Source: architecture/frontend-architecture.md#component-template]

- **Option Manager:**
  - Each option input must have accessible label (aria-label or associated <label>)
  - Delete button must have `ariaLabel="Remove option"`
  - Drag handle must have `aria-label="Reorder option"`
  - Validation errors must be announced to screen readers
  - Keyboard navigation must work (Tab through inputs, Enter on Add button)

- **Field Previews (Select, Radio, Checkbox):**
  - All form controls must have proper labels
  - Radio buttons: Each option has unique ID and associated label
  - Checkboxes: Each option has unique ID and associated label
  - Disabled state must be announced to screen readers
  - Empty options state must be announced ("No options defined")

### PrimeNG Components Used

[Source: architecture/tech-stack.md#ui-component-library]

- **Dropdown (Select):** `<p-dropdown [options]="options" optionLabel="label" optionValue="value">`
- **Radio Button:** `<p-radioButton [value]="option.value" [inputId]="uniqueId">`
- **Checkbox:** `<p-checkbox [value]="option.value" [inputId]="uniqueId">`
- **Button:** `<p-button label="Add Option" icon="pi pi-plus" size="small">`
- **CDK Drag-Drop:** `cdkDropList`, `cdkDrag`, `cdkDragHandle`

### Performance Considerations

- Use `ChangeDetectionStrategy.OnPush` for all option manager and preview components
- Track options by `option.value` in `@for` loop to minimize re-renders
- Debounce option change events if performance issues occur (unlikely with small option arrays)
- Immutable option array updates (create new array on change, don't mutate)

### Backward Compatibility

**No Breaking Changes:**

1. `FormField.options` property already exists in shared types (optional)
2. FormBuilderService API uses existing `updateFieldProperty` method (added in Story 11.2)
3. Field preview components are new (no existing behavior to break)
4. Option manager is conditionally rendered (no impact on non-choice fields)

**Compatibility Verification:**

1. Load existing form with select/radio/checkbox fields → options render correctly
2. Save form with updated options → schema matches expected format
3. Publish form → options display correctly in FormRendererComponent
4. Forms without options continue to work unchanged

---

## Change Log

| Date       | Version | Description                | Author             |
| ---------- | ------- | -------------------------- | ------------------ |
| 2025-10-07 | 1.0     | Story created from Epic 11 | Scrum Master (Bob) |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_This section will be populated by the QA agent after story completion._
