# Story 32.1.4: Search and Filtering UI

**Epic:** 32.1 - UI Components & Tool Discovery **Story Points:** 7 **Priority:** P1 **Assignee:**
Frontend Developer **Status:** Approved

---

## Description

Enhance the tools discovery page with search and filtering capabilities. Users can search tools by
name/description with debounced input, filter by status and date range, and clear all filters.
Integrates with `ToolRegistryService` for server-side search while also supporting client-side
filtering for better performance.

**Context:**

- Story 32.1.3 created ToolsListComponent for displaying tools
- Story 32.1.2 created ToolRegistryService with search capability
- This story adds search/filter UI on top of ToolsListComponent
- Uses reactive forms for search input with debounce
- Supports both server-side search (comprehensive) and client-side filtering (fast)

---

## Acceptance Criteria

**AC1: Search Input Implementation**

- ✅ Search input field with PrimeNG InputText
- ✅ Search icon displayed in input (pi-search)
- ✅ Placeholder text: "Search tools by name or description..."
- ✅ Debounced input (300ms delay after typing stops)
- ✅ Minimum 2 characters required for search
- ✅ Clear button (X) appears when text entered
- ✅ Search triggers on Enter key press

**AC2: Status Filter Dropdown**

- ✅ Dropdown with PrimeNG Dropdown component
- ✅ Options: All, Registered, Draft, Archived, Exported
- ✅ Default selection: "All"
- ✅ Filters tools by status field
- ✅ Works with search query (combined filtering)
- ✅ Shows count of tools per status (e.g., "Registered (12)")

**AC3: Date Range Filter (Optional)**

- ✅ Date range picker using PrimeNG Calendar
- ✅ Filters tools by createdAt date
- ✅ Default: "All time"
- ✅ Presets: Today, Last 7 days, Last 30 days, Custom range
- ✅ Works with search and status filters

**AC4: Filter Behavior**

- ✅ Client-side filtering for loaded tools (instant results)
- ✅ Server-side search via ToolRegistryService.searchTools() (comprehensive)
- ✅ Filters combine with AND logic (all conditions must match)
- ✅ Results update immediately on filter change
- ✅ Loading indicator during server search

**AC5: Results Display**

- ✅ Result count displayed: "Showing X of Y tools"
- ✅ "No results found" message when filters match nothing
- ✅ Empty state shows current filters
- ✅ Suggestion to clear filters in empty state
- ✅ Grid layout maintained from ToolsListComponent

**AC6: Clear Filters**

- ✅ "Clear Filters" button visible when filters active
- ✅ Button clears search, status, and date range
- ✅ Button disabled when no filters active
- ✅ Resets to all tools view
- ✅ Focus returns to search input after clear

**AC7: URL Query Parameters (Optional)**

- ✅ Search query stored in URL (?q=search)
- ✅ Status filter stored in URL (?status=registered)
- ✅ URL updates on filter change
- ✅ Filters restored from URL on page load
- ✅ Shareable filter URLs

**AC8: Accessibility**

- ✅ Search input has proper label and aria-label
- ✅ Dropdown has label and role="combobox"
- ✅ Clear filters button has aria-label
- ✅ Result count announced to screen readers
- ✅ Keyboard navigation works (Tab, Enter, Escape)

**AC9: Component Tests**

- ✅ Unit tests with ≥90% coverage
- ✅ Test: search input debounces correctly
- ✅ Test: status filter updates results
- ✅ Test: clear filters resets all inputs
- ✅ Test: combined filters work (search + status)
- ✅ Test: empty state displays for no results
- ✅ Test: result count updates correctly

---

## Tasks

### Task 1: Component Structure Setup

**Subtasks:**

1. Enhance ToolsListComponent (or create ToolsSearchComponent wrapper)
2. Import ReactiveFormsModule for form controls
3. Import PrimeNG modules (InputTextModule, DropdownModule, ButtonModule, CalendarModule)
4. Create FormGroup for filters
5. Add search input FormControl with validators
6. Add status filter FormControl
7. Add date range FormControl (optional)
8. Define filter state signals
9. Update component template structure
10. Add JSDoc for new properties

### Task 2: Search Input Implementation

**Subtasks:**

1. Add search FormControl with min length validator (2 chars)
2. Create search input template with p-inputText
3. Add search icon (pi-search) to input
4. Add clear button (X) that appears when text entered
5. Implement debounce using RxJS debounceTime(300)
6. Subscribe to valueChanges observable
7. Trigger search on debounced value
8. Handle Enter key to trigger immediate search
9. Clear search on X button click
10. Add loading indicator during search

### Task 3: Debounce Logic Implementation

**Subtasks:**

1. Import debounceTime, distinctUntilChanged from rxjs/operators
2. Pipe search valueChanges through debounce operators
3. Set debounce delay to 300ms
4. Use distinctUntilChanged to avoid duplicate searches
5. Filter out empty/short queries (< 2 chars)
6. Trigger search method on valid queries
7. Cancel pending searches on new input
8. Add search loading state signal
9. Test debounce with rapid typing
10. Verify only one API call made after typing stops

### Task 4: Status Filter Dropdown

**Subtasks:**

1. Define status options array: [{ label: 'All', value: null }, { label: 'Registered', value:
   'registered' }, ...]
2. Create status FormControl with initial value 'null'
3. Add p-dropdown to template
4. Bind [options] to status options
5. Bind [(ngModel)] or formControlName to status FormControl
6. Add filter icon to dropdown
7. Subscribe to status valueChanges
8. Trigger filter update on status change
9. Show tool count per status (optional enhancement)
10. Test status filtering

### Task 5: Client-Side Filtering

**Subtasks:**

1. Create `filteredTools = computed<ToolRegistryRecord[]>()` signal
2. Implement filter logic combining search, status, date
3. Filter by search query (case-insensitive name/description match)
4. Filter by status (exact match)
5. Filter by date range (createdAt between start and end)
6. Return filtered array
7. Update grid to display filteredTools instead of tools
8. Test filtering with various combinations
9. Verify instant filtering (no API calls)
10. Handle edge cases (null filters, empty arrays)

### Task 6: Server-Side Search Integration

**Subtasks:**

1. Create `performSearch(query: string)` method
2. Set search loading state to true
3. Call toolRegistryService.searchTools(query)
4. Subscribe to Observable
5. Update tools signal with search results
6. Set loading state to false
7. Handle search errors
8. Apply client-side status/date filters to search results
9. Update result count
10. Test search with 2-character minimum

### Task 7: Combined Filtering Logic

**Subtasks:**

1. Create `applyFilters()` method
2. Get current filter values (search, status, date)
3. If search query present: use server search results
4. If no search query: use all tools
5. Apply status filter to current tools
6. Apply date filter to current tools
7. Update filteredTools signal
8. Update result count
9. Test all filter combinations
10. Verify AND logic (all filters must match)

### Task 8: Clear Filters Implementation

**Subtasks:**

1. Create `clearFilters()` method
2. Reset search FormControl to empty string
3. Reset status FormControl to null
4. Reset date range FormControl to null
5. Clear URL query parameters (if implemented)
6. Update filteredTools to show all tools
7. Focus search input after clear
8. Add "Clear Filters" button to template
9. Bind button click to clearFilters method
10. Disable button when no filters active

### Task 9: Result Count Display

**Subtasks:**

1. Create `resultCount = computed<number>()` signal
2. Calculate count from filteredTools().length
3. Create `totalCount` signal from tools().length
4. Add result count template: "Showing {{ resultCount() }} of {{ totalCount() }} tools"
5. Style result count (muted, above grid)
6. Update count on filter changes
7. Announce count to screen readers (aria-live)
8. Hide count during loading
9. Test count accuracy
10. Add singular/plural handling ("1 tool" vs "2 tools")

### Task 10: Empty State for No Results

**Subtasks:**

1. Create `hasActiveFilters = computed<boolean>()` to check if any filters applied
2. Add empty state template for no results
3. Display current filter values in empty state
4. Add "Clear Filters" CTA in empty state
5. Style empty state differently from no tools state
6. Add icon (pi-filter-slash or pi-search)
7. Test empty state with various filter combinations
8. Verify empty state only shows when filters active
9. Add accessibility labels
10. Test keyboard navigation

### Task 11: URL Query Parameters (Optional)

**Subtasks:**

1. Import ActivatedRoute and Router
2. Create `updateUrlParams()` method
3. Build query params object from filters
4. Use router.navigate with queryParams
5. Subscribe to route.queryParams on init
6. Parse query params and set filter values
7. Trigger filtering on query param changes
8. Test shareable URLs
9. Test browser back/forward with filters
10. Handle invalid query param values

### Task 12: Loading States

**Subtasks:**

1. Create `searching = signal<boolean>(false)` for search loading
2. Show spinner in search input during search
3. Disable filter inputs during search (optional)
4. Add skeleton for search results (optional)
5. Show "Searching..." message below search input
6. Clear loading state on search complete/error
7. Test loading state appearance
8. Verify loading state accessibility
9. Add timeout for long searches (optional)
10. Handle multiple concurrent searches

### Task 13: Template Layout

**Subtasks:**

1. Create search/filter section above tools grid
2. Use flexbox or CSS Grid for filter layout
3. Desktop: Search + Status + Date in single row
4. Mobile: Stack filters vertically
5. Add spacing between filter inputs (16px)
6. Add result count below filters
7. Add clear filters button (right-aligned)
8. Integrate with ToolsListComponent grid
9. Add responsive breakpoints
10. Test layout across screen sizes

### Task 14: Styling

**Subtasks:**

1. Style search input (full width on mobile, 400px on desktop)
2. Style status dropdown (200px width)
3. Style date range picker (250px width)
4. Style clear filters button (secondary color)
5. Style result count (muted text, small font)
6. Add filter section background (optional)
7. Add spacing and padding
8. Match PrimeNG theme
9. Add hover/focus states
10. Test dark mode compatibility (if applicable)

### Task 15: Accessibility Implementation

**Subtasks:**

1. Add `aria-label="Search tools"` to search input
2. Add `<label>` elements for each filter
3. Add `role="search"` to search container
4. Add `aria-live="polite"` to result count
5. Add `aria-label="Clear all filters"` to clear button
6. Ensure keyboard navigation (Tab through filters)
7. Add focus indicators
8. Test with screen reader
9. Verify color contrast (WCAG AA)
10. Add skip links if needed

### Task 16: Unit Tests - Search

**Subtasks:**

1. Write test: "should debounce search input"
2. Use fakeAsync and tick(300) to test debounce
3. Write test: "should not search for queries < 2 chars"
4. Write test: "should call searchTools service method"
5. Write test: "should clear search on X button"
6. Write test: "should trigger search on Enter key"
7. Verify search loading state updates
8. Test search error handling
9. Verify result count updates after search
10. Test distinctUntilChanged behavior

### Task 17: Unit Tests - Filtering

**Subtasks:**

1. Write test: "should filter by status"
2. Write test: "should combine search and status filters"
3. Write test: "should filter by date range"
4. Write test: "should show empty state for no results"
5. Write test: "should clear all filters on clear button"
6. Write test: "should update result count correctly"
7. Write test: "should disable clear button when no filters"
8. Verify filtered tools computed signal
9. Test edge cases (null values, empty arrays)
10. Run coverage report (target ≥90%)

---

## Dev Notes

### Enhanced ToolsListComponent with Search/Filter

**TypeScript (tools-list.component.ts - Enhanced):**

````typescript
import { Component, OnInit, OnDestroy, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged, takeUntil } from 'rxjs/operators';
import { InputTextModule } from 'primeng/inputtext';
import { DropdownModule } from 'primeng/dropdown';
import { ButtonModule } from 'primeng/button';
import { CalendarModule } from 'primeng/calendar';
import { ToolCardComponent } from '@app/shared/components/tool-card/tool-card.component';
import { ToolRegistryService } from '@app/core/services/tool-registry.service';
import { ToolRegistryRecord } from '@nodeangularfullstack/shared';

interface StatusOption {
  label: string;
  value: string | null;
  count?: number;
}

/**
 * Displays tools with search and filtering capabilities.
 *
 * Features:
 * - Debounced search input (300ms delay)
 * - Status filtering (registered, draft, archived, exported)
 * - Date range filtering (optional)
 * - Client-side and server-side filtering
 * - Clear filters functionality
 *
 * @example
 * ```html
 * <app-tools-list></app-tools-list>
 * ```
 */
@Component({
  selector: 'app-tools-list',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    InputTextModule,
    DropdownModule,
    ButtonModule,
    CalendarModule,
    ToolCardComponent,
  ],
  templateUrl: './tools-list.component.html',
  styleUrl: './tools-list.component.scss',
})
export class ToolsListComponent implements OnInit, OnDestroy {
  // Tool data
  tools = signal<ToolRegistryRecord[]>([]);
  loading = signal<boolean>(true);
  searching = signal<boolean>(false);
  error = signal<string | null>(null);

  // Filter form
  filterForm: FormGroup;

  // Status options
  statusOptions: StatusOption[] = [
    { label: 'All Statuses', value: null },
    { label: 'Registered', value: 'registered' },
    { label: 'Draft', value: 'draft' },
    { label: 'Archived', value: 'archived' },
    { label: 'Exported', value: 'exported' },
  ];

  // Computed signals
  filteredTools = computed<ToolRegistryRecord[]>(() => {
    const allTools = this.tools();
    const searchQuery = this.filterForm?.get('search')?.value?.toLowerCase() || '';
    const statusFilter = this.filterForm?.get('status')?.value;

    let filtered = allTools;

    // Apply search filter (client-side)
    if (searchQuery.length >= 2) {
      filtered = filtered.filter(
        (tool) =>
          tool.name.toLowerCase().includes(searchQuery) ||
          tool.description?.toLowerCase().includes(searchQuery)
      );
    }

    // Apply status filter
    if (statusFilter) {
      filtered = filtered.filter((tool) => tool.status === statusFilter);
    }

    return filtered;
  });

  resultCount = computed<number>(() => this.filteredTools().length);
  totalCount = computed<number>(() => this.tools().length);
  hasActiveFilters = computed<boolean>(() => {
    const search = this.filterForm?.get('search')?.value;
    const status = this.filterForm?.get('status')?.value;
    return (search && search.length >= 2) || status !== null;
  });

  private destroy$ = new Subject<void>();

  constructor(
    private toolRegistryService: ToolRegistryService,
    private router: Router,
    private route: ActivatedRoute,
    private fb: FormBuilder
  ) {
    // Initialize filter form
    this.filterForm = this.fb.group({
      search: [''],
      status: [null],
      dateRange: [null],
    });
  }

  ngOnInit(): void {
    this.loadTools();
    this.setupSearchDebounce();
    this.setupFilterListeners();
    this.restoreFiltersFromUrl();
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  /**
   * Loads all tools from the registry.
   */
  private loadTools(): void {
    this.loading.set(true);
    this.error.set(null);

    this.toolRegistryService
      .getAllTools()
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (tools) => {
          console.log(`[ToolsListComponent] Loaded ${tools.length} tools`);
          this.tools.set(tools);
          this.loading.set(false);
        },
        error: (err) => {
          console.error('[ToolsListComponent] Failed to load tools:', err);
          this.error.set(err.message || 'Failed to load tools');
          this.loading.set(false);
        },
      });
  }

  /**
   * Sets up debounced search input handling.
   */
  private setupSearchDebounce(): void {
    this.filterForm
      .get('search')!
      .valueChanges.pipe(debounceTime(300), distinctUntilChanged(), takeUntil(this.destroy$))
      .subscribe((query: string) => {
        console.log(`[ToolsListComponent] Search query: "${query}"`);

        // For comprehensive search, use server-side search
        if (query && query.trim().length >= 2) {
          this.performServerSearch(query.trim());
        } else {
          // For empty search, show all tools with client-side filtering
          this.loadTools();
        }

        this.updateUrlParams();
      });
  }

  /**
   * Sets up listeners for status and date filters.
   */
  private setupFilterListeners(): void {
    // Status filter
    this.filterForm
      .get('status')!
      .valueChanges.pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        console.log('[ToolsListComponent] Status filter changed');
        this.updateUrlParams();
      });

    // Date range filter (optional)
    this.filterForm
      .get('dateRange')!
      .valueChanges.pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        console.log('[ToolsListComponent] Date range changed');
        this.updateUrlParams();
      });
  }

  /**
   * Performs server-side search for comprehensive results.
   */
  private performServerSearch(query: string): void {
    this.searching.set(true);

    this.toolRegistryService
      .searchTools(query)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (results) => {
          console.log(`[ToolsListComponent] Search returned ${results.length} results`);
          this.tools.set(results);
          this.searching.set(false);
        },
        error: (err) => {
          console.error('[ToolsListComponent] Search failed:', err);
          this.error.set(err.message || 'Search failed');
          this.searching.set(false);
        },
      });
  }

  /**
   * Clears all active filters and reloads tools.
   */
  clearFilters(): void {
    console.log('[ToolsListComponent] Clearing filters');
    this.filterForm.patchValue({
      search: '',
      status: null,
      dateRange: null,
    });
    this.loadTools();
    this.updateUrlParams();
  }

  /**
   * Handles tool card click and navigates to detail page.
   */
  onToolClick(tool: ToolRegistryRecord): void {
    console.log(`[ToolsListComponent] Tool clicked: ${tool.toolId}`);
    this.router.navigate(['/tools', tool.toolId]);
  }

  /**
   * Updates URL query parameters to reflect current filters.
   */
  private updateUrlParams(): void {
    const queryParams: any = {};

    const search = this.filterForm.get('search')?.value;
    if (search && search.length >= 2) {
      queryParams.q = search;
    }

    const status = this.filterForm.get('status')?.value;
    if (status) {
      queryParams.status = status;
    }

    this.router.navigate([], {
      relativeTo: this.route,
      queryParams,
      queryParamsHandling: 'merge',
    });
  }

  /**
   * Restores filters from URL query parameters on init.
   */
  private restoreFiltersFromUrl(): void {
    this.route.queryParams.pipe(takeUntil(this.destroy$)).subscribe((params) => {
      if (params['q']) {
        this.filterForm.patchValue({ search: params['q'] }, { emitEvent: false });
      }
      if (params['status']) {
        this.filterForm.patchValue({ status: params['status'] }, { emitEvent: false });
      }
    });
  }
}
````

**Template (tools-list.component.html - Enhanced):**

```html
<div class="tools-list-container">
  <!-- Header -->
  <div class="tools-list-header">
    <h2>Registered Tools</h2>
    <p class="subtitle">Browse and manage your registered tools</p>
  </div>

  <!-- Search & Filters Section -->
  <div class="filters-section" [formGroup]="filterForm">
    <div class="filters-row">
      <!-- Search Input -->
      <div class="search-input-wrapper">
        <span class="p-input-icon-left w-full">
          <i class="pi pi-search"></i>
          <input
            type="text"
            pInputText
            formControlName="search"
            placeholder="Search tools by name or description..."
            aria-label="Search tools"
            class="w-full"
            [class.loading]="searching()"
          />
          <i
            *ngIf="filterForm.get('search')?.value"
            class="pi pi-times clear-icon"
            (click)="filterForm.patchValue({ search: '' })"
            tabindex="0"
            role="button"
            aria-label="Clear search"
          ></i>
        </span>
        <small *ngIf="searching()" class="searching-text">
          <i class="pi pi-spin pi-spinner"></i> Searching...
        </small>
      </div>

      <!-- Status Filter -->
      <div class="filter-dropdown">
        <label for="status-filter">Status</label>
        <p-dropdown
          id="status-filter"
          formControlName="status"
          [options]="statusOptions"
          optionLabel="label"
          optionValue="value"
          placeholder="All Statuses"
          [style]="{ width: '200px' }"
        ></p-dropdown>
      </div>

      <!-- Clear Filters Button -->
      <p-button
        *ngIf="hasActiveFilters()"
        label="Clear Filters"
        icon="pi pi-filter-slash"
        severity="secondary"
        (onClick)="clearFilters()"
        [outlined]="true"
        class="clear-filters-btn"
        aria-label="Clear all filters"
      ></p-button>
    </div>

    <!-- Result Count -->
    <div class="result-count" aria-live="polite" aria-atomic="true">
      <span *ngIf="!loading() && !error()">
        Showing <strong>{{ resultCount() }}</strong> of
        <strong>{{ totalCount() }}</strong>
        {{ totalCount() === 1 ? 'tool' : 'tools' }}
      </span>
    </div>
  </div>

  <!-- Loading State -->
  <ng-container *ngIf="loading()">
    <div class="loading-message">
      <i class="pi pi-spin pi-spinner"></i>
      <span>Loading tools...</span>
    </div>
    <div class="tools-grid tools-grid-skeleton">
      <app-tool-card *ngFor="let i of [1,2,3,4,5,6,7,8]" [loading]="true"></app-tool-card>
    </div>
  </ng-container>

  <!-- Error State -->
  <ng-container *ngIf="error() && !loading()">
    <div class="error-state">
      <i class="pi pi-exclamation-triangle error-icon"></i>
      <h3>Failed to Load Tools</h3>
      <p class="error-message">{{ error() }}</p>
      <p-button
        label="Try Again"
        icon="pi pi-refresh"
        (onClick)="loadTools()"
        severity="secondary"
      ></p-button>
    </div>
  </ng-container>

  <!-- No Results (with active filters) -->
  <ng-container
    *ngIf="!loading() && !error() && filteredTools().length === 0 && hasActiveFilters()"
  >
    <div class="no-results-state">
      <i class="pi pi-filter-slash no-results-icon"></i>
      <h3>No Tools Match Your Filters</h3>
      <p class="no-results-message">Try adjusting your search or filter criteria</p>
      <div class="active-filters">
        <span *ngIf="filterForm.get('search')?.value" class="filter-chip">
          Search: "{{ filterForm.get('search')?.value }}"
        </span>
        <span *ngIf="filterForm.get('status')?.value" class="filter-chip">
          Status: {{ filterForm.get('status')?.value }}
        </span>
      </div>
      <p-button
        label="Clear Filters"
        icon="pi pi-filter-slash"
        (onClick)="clearFilters()"
        severity="primary"
      ></p-button>
    </div>
  </ng-container>

  <!-- Empty State (no tools at all) -->
  <ng-container *ngIf="!loading() && !error() && tools().length === 0 && !hasActiveFilters()">
    <div class="empty-state">
      <i class="pi pi-inbox empty-icon"></i>
      <h3>No Tools Found</h3>
      <p class="empty-message">Get started by registering your first tool</p>
      <p-button
        label="Register New Tool"
        icon="pi pi-plus"
        severity="primary"
        [routerLink]="['/tools/create']"
      ></p-button>
    </div>
  </ng-container>

  <!-- Tools Grid -->
  <ng-container *ngIf="!loading() && !error() && filteredTools().length > 0">
    <div class="tools-grid">
      <app-tool-card
        *ngFor="let tool of filteredTools()"
        [tool]="tool"
        [interactive]="true"
        (toolClick)="onToolClick($event)"
      ></app-tool-card>
    </div>
  </ng-container>
</div>
```

**Styles (tools-list.component.scss - Enhanced):**

```scss
.filters-section {
  margin-bottom: 32px;
  padding: 20px;
  background: var(--surface-card);
  border-radius: 8px;
  border: 1px solid var(--surface-border);

  @media (max-width: 768px) {
    padding: 16px;
  }
}

.filters-row {
  display: flex;
  align-items: flex-end;
  gap: 16px;
  flex-wrap: wrap;

  @media (max-width: 768px) {
    flex-direction: column;
    align-items: stretch;
  }
}

.search-input-wrapper {
  flex: 1;
  min-width: 300px;
  position: relative;

  @media (max-width: 768px) {
    min-width: 100%;
  }

  .clear-icon {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    cursor: pointer;
    color: var(--text-color-secondary);
    font-size: 1rem;

    &:hover {
      color: var(--text-color);
    }
  }

  .searching-text {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    color: var(--text-color-secondary);
    font-size: 0.875rem;
  }
}

.filter-dropdown {
  display: flex;
  flex-direction: column;
  gap: 4px;

  label {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text-color-secondary);
  }

  @media (max-width: 768px) {
    width: 100%;

    ::ng-deep p-dropdown {
      width: 100% !important;
    }
  }
}

.clear-filters-btn {
  margin-left: auto;

  @media (max-width: 768px) {
    width: 100%;
  }
}

.result-count {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--surface-border);
  font-size: 0.875rem;
  color: var(--text-color-secondary);

  strong {
    color: var(--text-color);
    font-weight: 600;
  }
}

.no-results-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 80px 32px;
  text-align: center;

  .no-results-icon {
    font-size: 4rem;
    color: var(--text-color-secondary);
    margin-bottom: 24px;
  }

  .active-filters {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin: 16px 0 24px 0;
    justify-content: center;
  }

  .filter-chip {
    background: var(--surface-100);
    color: var(--text-color);
    padding: 6px 12px;
    border-radius: 16px;
    font-size: 0.875rem;
  }
}

// Rest of styles from previous story...
```

---

## Testing

### Manual Testing

**Test 1: Search with Debounce**

```bash
# 1. Navigate to tools page
# 2. Type "form" in search input
# 3. Wait 300ms
# Expected: Search triggered after typing stops
# Verify in Network tab: Only ONE request to /api/tools/search
```

**Test 2: Status Filtering**

```bash
# 1. Select "Registered" from status dropdown
# Expected: Grid shows only registered tools
# Result count updates: "Showing X of Y tools"
```

**Test 3: Combined Filters**

```bash
# 1. Type "analytics" in search
# 2. Select "Draft" from status
# Expected: Only draft tools matching "analytics" displayed
```

**Test 4: Clear Filters**

```bash
# 1. Apply search + status filters
# 2. Click "Clear Filters" button
# Expected: All tools displayed, filters reset
```

**Test 5: No Results**

```bash
# 1. Search for "nonexistent-tool-xyz"
# Expected: "No Tools Match Your Filters" message
# Shows active filters and "Clear Filters" button
```

**Test 6: URL Parameters**

```bash
# 1. Search for "form"
# 2. Check URL: ?q=form
# 3. Refresh page
# Expected: Search filter restored, results displayed
```

### Automated Testing

```bash
# Run unit tests
npm --workspace=apps/web run test -- --include="**/tools-list.component.spec.ts" --watch=false

# Expected output:
# PASS src/app/features/tools/components/tools-list/tools-list.component.spec.ts
#   ToolsListComponent
#     Search
#       ✓ should debounce search input (350ms)
#       ✓ should not search for queries < 2 chars (30ms)
#       ✓ should clear search on X button (25ms)
#       ✓ should call searchTools service (35ms)
#     Filtering
#       ✓ should filter by status (28ms)
#       ✓ should combine search and status filters (32ms)
#       ✓ should show no results state (30ms)
#       ✓ should clear all filters (25ms)
#       ✓ should update result count (20ms)
#       ✓ should disable clear button when no filters (18ms)
#
# Tests: 10 passed, 10 total
# Coverage: Statements 92%, Branches 88%, Functions 90%, Lines 92%
```

---

## Dependencies

**Depends On:**

- Story 32.1.2: Tool Registry Service (searchTools method)
- Story 32.1.3: ToolsList Component (grid layout)

**Blocks:**

- Story 32.2: Dynamic Routing (navigation from search results)

---

## QA Gate

**Quality Score Target:** ≥90/100

| Criterion                  | Weight | Target                    |
| -------------------------- | ------ | ------------------------- |
| Unit test coverage         | 20%    | ≥90%                      |
| All tests passing          | 15%    | 100%                      |
| Search debounce functional | 15%    | 300ms delay               |
| Filtering accurate         | 15%    | All combinations work     |
| Empty states clear         | 10%    | Helpful messages          |
| URL params work            | 10%    | Shareable URLs            |
| Accessibility (WCAG AA)    | 10%    | ARIA labels, keyboard nav |
| Code quality               | 5%     | No ESLint errors          |

**Exit Criteria:**

- All unit tests pass with ≥90% coverage
- Search debounces correctly (verified manually)
- All filter combinations work
- Clear filters resets all inputs
- Empty states display appropriately
- URL parameters work (filters restored on page load)
- Keyboard navigation functional
- Screen reader announces result count

---

## Notes

- Search uses 300ms debounce to balance responsiveness and API load
- Server-side search via `searchTools()` provides comprehensive results
- Client-side filtering (status, date) provides instant feedback
- Filters combine with AND logic (all must match)
- URL query parameters enable shareable filtered views
- Empty states distinguish between "no tools" vs "no results for filters"
- Result count keeps users informed of filtered results
