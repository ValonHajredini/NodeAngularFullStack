# Story 32.1.2: Tool Registry Service with Caching

**Epic:** 32.1 - UI Components & Tool Discovery **Story Points:** 7 **Priority:** P1 **Assignee:**
Frontend Developer **Status:** Approved

---

## Description

Create a frontend Angular service (`ToolRegistryService`) to interact with the Tool Registry backend
API. This service provides methods for fetching, searching, and managing tools with client-side
caching to minimize unnecessary HTTP requests and improve performance.

**Context:**

- Epic 30.2 implemented the Tool Registry backend API
- Story 32.1.1 created the ToolCard component for display
- This service acts as the data layer between backend API and frontend components
- Caching strategy uses RxJS `shareReplay()` to prevent duplicate requests

---

## Acceptance Criteria

**AC1: Service Setup & Dependencies**

- ✅ Service created at `apps/web/src/app/core/services/tool-registry.service.ts`
- ✅ Injectable with `providedIn: 'root'` (singleton)
- ✅ Imports HttpClient for API calls
- ✅ Imports RxJS operators (map, catchError, retry, shareReplay)
- ✅ Uses environment variables for API base URL
- ✅ Service exported from core barrel exports

**AC2: API Methods**

- ✅ `getAllTools(): Observable<ToolRegistryRecord[]>` - Fetch all registered tools
- ✅ `getToolById(toolId: string): Observable<ToolRegistryRecord>` - Fetch single tool
- ✅ `searchTools(query: string): Observable<ToolRegistryRecord[]>` - Search tools by
  name/description
- ✅ `refreshCache(): void` - Clear cache and force refetch
- ✅ All methods return RxJS Observables (no Promises)

**AC3: Caching Strategy**

- ✅ `getAllTools()` uses `shareReplay(1)` to cache results
- ✅ Cache invalidated on `refreshCache()` call
- ✅ `getToolById()` checks cache before making API request
- ✅ Search results not cached (always fresh)
- ✅ Cache cleared automatically after 5 minutes

**AC4: Error Handling**

- ✅ All API calls wrapped with `catchError()` operator
- ✅ Network errors return user-friendly messages
- ✅ 404 errors handled gracefully (return empty array or null)
- ✅ 401/403 errors redirect to login (via AuthService integration)
- ✅ Retry logic for transient failures (3 retries with exponential backoff)

**AC5: Retry & Timeout Configuration**

- ✅ Retry failed requests 3 times with exponential backoff (1s, 2s, 4s)
- ✅ Timeout set to 30 seconds per request
- ✅ Only retry on network errors (not 4xx errors)
- ✅ Log retries to console for debugging
- ✅ Maximum 3 retries before final failure

**AC6: TypeScript Type Safety**

- ✅ All methods use `ToolRegistryRecord` type from `@nodeangularfullstack/shared`
- ✅ Response types properly mapped from API responses
- ✅ No `any` types in service implementation
- ✅ Proper error type handling in catchError blocks
- ✅ JSDoc comments for all public methods

**AC7: Unit Tests**

- ✅ Test coverage ≥90%
- ✅ Test: `getAllTools()` returns cached data on second call
- ✅ Test: `getToolById()` makes HTTP GET request
- ✅ Test: `searchTools()` makes HTTP GET with query param
- ✅ Test: `refreshCache()` clears cache and forces refetch
- ✅ Test: Error handling for 404, 500, network errors
- ✅ Test: Retry logic executes 3 times on failure
- ✅ Uses HttpClientTestingModule and HttpTestingController

**AC8: Integration with AuthService**

- ✅ Injects AuthService for authentication token
- ✅ Adds Authorization header to all requests
- ✅ Redirects to login on 401 errors
- ✅ Handles token expiration gracefully
- ✅ Does not retry on 401/403 errors (auth issues)

---

## Tasks

### Task 1: Service File Structure Setup

**Subtasks:**

1. Create directory `apps/web/src/app/core/services/`
2. Create `tool-registry.service.ts` file
3. Create `tool-registry.service.spec.ts` test file
4. Update `apps/web/src/app/core/services/index.ts` barrel export
5. Update `apps/web/src/app/core/index.ts` barrel export
6. Import ToolRegistryRecord from `@nodeangularfullstack/shared`
7. Import environment from `apps/web/src/environments/environment`
8. Initialize Git tracking for new files
9. Verify file structure matches project conventions
10. Add JSDoc comments to file header

### Task 2: Service Class & Constructor

**Subtasks:**

1. Define `@Injectable({ providedIn: 'root' })` decorator
2. Inject HttpClient in constructor
3. Inject AuthService for authentication
4. Define private `apiUrl` property from environment.apiUrl
5. Define private `cache$` property for Observable cache
6. Define private `cacheTimestamp` property for cache expiration
7. Define `CACHE_DURATION` constant (5 minutes)
8. Add JSDoc comment for service class
9. Document caching strategy in JSDoc
10. Add example usage in JSDoc

### Task 3: getAllTools() Method Implementation

**Subtasks:**

1. Create `getAllTools(): Observable<ToolRegistryRecord[]>` method
2. Check if cache exists and is valid (< 5 min old)
3. Return cached Observable if valid
4. Make HTTP GET request to `/api/tools/registry`
5. Add Authorization header with JWT token
6. Use `map()` operator to transform response
7. Use `shareReplay(1)` to cache results
8. Use `retry(3)` for transient failures
9. Use `catchError()` for error handling
10. Update `cacheTimestamp` on successful response
11. Add JSDoc with @returns and @throws tags

### Task 4: getToolById() Method Implementation

**Subtasks:**

1. Create `getToolById(toolId: string): Observable<ToolRegistryRecord>` method
2. Validate toolId parameter (non-empty string)
3. Check if tool exists in cache
4. Make HTTP GET request to `/api/tools/registry/:id`
5. Add Authorization header
6. Use `map()` to extract tool from response
7. Use `retry(3)` for transient failures
8. Handle 404 errors (return null or throw)
9. Use `catchError()` for other errors
10. Add JSDoc with @param, @returns, @throws tags

### Task 5: searchTools() Method Implementation

**Subtasks:**

1. Create `searchTools(query: string): Observable<ToolRegistryRecord[]>` method
2. Validate query parameter (min 2 characters)
3. Throw error if query too short
4. Make HTTP GET request to `/api/tools/search?q=<query>`
5. Add Authorization header
6. Use `map()` to transform response
7. Use `retry(3)` for transient failures
8. Use `catchError()` for error handling
9. Do NOT cache search results (always fresh)
10. Add JSDoc with @param, @returns, @throws tags

### Task 6: refreshCache() Method Implementation

**Subtasks:**

1. Create `refreshCache(): void` method
2. Set `cache$` to undefined to clear cache
3. Set `cacheTimestamp` to null
4. Immediately call `getAllTools()` to refetch
5. Log cache refresh to console (debug mode)
6. Add JSDoc explaining when to use this method
7. Document that this triggers new HTTP request
8. Add example usage in JSDoc
9. Consider adding optional parameter to refresh specific tool
10. Test cache refresh behavior

### Task 7: Caching Logic Implementation

**Subtasks:**

1. Create `isCacheValid()` private helper method
2. Check if `cache$` exists
3. Check if `cacheTimestamp` is within CACHE_DURATION (5 min)
4. Return boolean indicating cache validity
5. Create `getCacheAge()` helper for debugging
6. Add cache hit/miss logging (debug mode)
7. Document caching strategy in service JSDoc
8. Test cache expiration after 5 minutes
9. Test cache invalidation on refreshCache()
10. Verify shareReplay behavior with multiple subscribers

### Task 8: Error Handling Implementation

**Subtasks:**

1. Create `handleError()` private method
2. Handle network errors (connection refused, timeout)
3. Handle 404 errors (tool not found)
4. Handle 401/403 errors (redirect to login)
5. Handle 500 errors (server error)
6. Return user-friendly error messages via `throwError()`
7. Log errors to console for debugging
8. Integrate with AuthService for auth errors
9. Add error type interfaces (ApiError)
10. Test all error scenarios

### Task 9: Retry Logic Implementation

**Subtasks:**

1. Import `retry`, `retryWhen`, `delay`, `scan` operators
2. Create `retryStrategy()` private helper method
3. Implement exponential backoff (1s, 2s, 4s delays)
4. Retry only on network errors (not 4xx)
5. Log each retry attempt to console
6. Maximum 3 retries before giving up
7. Use `retryWhen()` for custom retry logic
8. Test retry behavior with mock failures
9. Verify exponential backoff delays
10. Document retry strategy in JSDoc

### Task 10: Authorization Header Integration

**Subtasks:**

1. Inject AuthService in constructor
2. Create `getAuthHeaders()` private method
3. Get JWT token from AuthService
4. Return HttpHeaders with Authorization: Bearer <token>
5. Handle missing token (redirect to login)
6. Add headers to all HTTP requests
7. Test with valid token
8. Test with expired token
9. Test with missing token
10. Integrate with AuthService.getToken() method

### Task 11: Unit Tests - Basic Functionality

**Subtasks:**

1. Setup test bed with HttpClientTestingModule
2. Write test: "should create service"
3. Write test: "getAllTools() should return array of tools"
4. Write test: "getToolById() should return single tool"
5. Write test: "searchTools() should return filtered tools"
6. Write test: "searchTools() should throw error for short query"
7. Mock HTTP responses with HttpTestingController
8. Verify HTTP requests made to correct URLs
9. Verify request methods (GET, POST, etc.)
10. Verify response data types

### Task 12: Unit Tests - Caching Behavior

**Subtasks:**

1. Write test: "getAllTools() should cache results"
2. Verify single HTTP request for multiple subscriptions
3. Write test: "cache should expire after 5 minutes"
4. Mock Date.now() to advance time
5. Write test: "refreshCache() should clear cache"
6. Verify new HTTP request after refreshCache()
7. Write test: "getToolById() should use cache if available"
8. Write test: "search results should not be cached"
9. Verify cache hit/miss behavior
10. Test shareReplay() operator behavior

### Task 13: Unit Tests - Error Handling

**Subtasks:**

1. Write test: "should handle 404 error gracefully"
2. Write test: "should handle 500 server error"
3. Write test: "should handle network timeout"
4. Write test: "should redirect on 401 unauthorized"
5. Write test: "should retry 3 times on network error"
6. Write test: "should not retry on 4xx errors"
7. Mock error responses with HttpTestingController
8. Verify error messages user-friendly
9. Verify AuthService.logout() called on 401
10. Run coverage report (target ≥90%)

### Task 14: Unit Tests - Retry Logic

**Subtasks:**

1. Write test: "should retry failed request 3 times"
2. Mock network failure, then success on 3rd attempt
3. Write test: "should use exponential backoff delays"
4. Verify 1s, 2s, 4s delays between retries
5. Write test: "should give up after 3 retries"
6. Write test: "should not retry on 401 error"
7. Write test: "should not retry on 404 error"
8. Use fakeAsync and tick() for time-based testing
9. Verify retry count in logs
10. Test retry with different error types

### Task 15: Integration with AuthService

**Subtasks:**

1. Mock AuthService in unit tests
2. Write test: "should add Authorization header to requests"
3. Write test: "should call AuthService.getToken()"
4. Write test: "should redirect to login on 401"
5. Write test: "should handle expired token"
6. Verify AuthService.logout() called on auth errors
7. Test with valid JWT token
8. Test with missing token
9. Test with malformed token
10. Integrate with existing auth flow

### Task 16: Documentation & Examples

**Subtasks:**

1. Add comprehensive JSDoc to service class
2. Document caching strategy and duration
3. Document retry logic and backoff
4. Add usage examples for each method
5. Document error handling behavior
6. Create `USAGE.md` in service directory
7. Add code examples for common scenarios
8. Document when to call refreshCache()
9. Add troubleshooting section
10. Link to backend API documentation

---

## Dev Notes

### Service Implementation

**TypeScript (tool-registry.service.ts):**

````typescript
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError, of, Subject } from 'rxjs';
import { map, catchError, retry, shareReplay, retryWhen, delay, scan, tap } from 'rxjs/operators';
import { ToolRegistryRecord } from '@nodeangularfullstack/shared';
import { AuthService } from './auth.service';
import { Router } from '@angular/router';
import { environment } from '../../environments/environment';

/**
 * Service for interacting with the Tool Registry backend API.
 *
 * Provides methods for fetching, searching, and managing registered tools.
 * Implements client-side caching with shareReplay() to minimize HTTP requests.
 * Includes retry logic with exponential backoff for transient failures.
 *
 * @example Basic Usage
 * ```typescript
 * constructor(private toolRegistry: ToolRegistryService) {}
 *
 * ngOnInit() {
 *   this.toolRegistry.getAllTools().subscribe({
 *     next: (tools) => console.log('Tools:', tools),
 *     error: (err) => console.error('Error:', err),
 *   });
 * }
 * ```
 *
 * @example Search Tools
 * ```typescript
 * this.toolRegistry.searchTools('form').subscribe({
 *   next: (results) => console.log('Search results:', results),
 * });
 * ```
 *
 * @example Refresh Cache
 * ```typescript
 * // Force refetch from server
 * this.toolRegistry.refreshCache();
 * ```
 */
@Injectable({
  providedIn: 'root',
})
export class ToolRegistryService {
  private readonly apiUrl: string;
  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
  private readonly MAX_RETRIES = 3;

  private cache$: Observable<ToolRegistryRecord[]> | undefined;
  private cacheTimestamp: number | null = null;

  constructor(
    private http: HttpClient,
    private authService: AuthService,
    private router: Router
  ) {
    this.apiUrl = `${environment.apiUrl}/api/tools`;
  }

  /**
   * Fetches all registered tools from the API.
   *
   * Results are cached using shareReplay(1) for 5 minutes to minimize
   * unnecessary HTTP requests. Multiple subscriptions will receive the
   * cached data without triggering new API calls.
   *
   * @returns Observable<ToolRegistryRecord[]> Array of all tools
   * @throws ApiError if request fails after 3 retries
   *
   * @example
   * ```typescript
   * this.toolRegistry.getAllTools().subscribe({
   *   next: (tools) => {
   *     console.log(`Found ${tools.length} tools`);
   *   },
   *   error: (err) => {
   *     console.error('Failed to fetch tools:', err.message);
   *   },
   * });
   * ```
   */
  getAllTools(): Observable<ToolRegistryRecord[]> {
    // Check cache validity
    if (this.cache$ && this.isCacheValid()) {
      console.log('[ToolRegistryService] Returning cached data');
      return this.cache$;
    }

    console.log('[ToolRegistryService] Fetching tools from API');

    // Make API request with caching
    this.cache$ = this.http
      .get<{
        message: string;
        data: ToolRegistryRecord[];
      }>(`${this.apiUrl}/registry`, { headers: this.getAuthHeaders() })
      .pipe(
        tap(() => {
          this.cacheTimestamp = Date.now();
        }),
        map((response) => response.data),
        this.retryStrategy(),
        shareReplay(1), // Cache results
        catchError(this.handleError.bind(this))
      );

    return this.cache$;
  }

  /**
   * Fetches a single tool by its unique tool ID.
   *
   * @param toolId - The unique tool identifier (e.g., "form-builder")
   * @returns Observable<ToolRegistryRecord> The requested tool
   * @throws ApiError if tool not found (404) or request fails
   *
   * @example
   * ```typescript
   * this.toolRegistry.getToolById('form-builder').subscribe({
   *   next: (tool) => {
   *     console.log('Tool:', tool.name);
   *   },
   *   error: (err) => {
   *     if (err.status === 404) {
   *       console.error('Tool not found');
   *     }
   *   },
   * });
   * ```
   */
  getToolById(toolId: string): Observable<ToolRegistryRecord> {
    if (!toolId || toolId.trim().length === 0) {
      return throwError(() => new Error('Tool ID is required'));
    }

    console.log(`[ToolRegistryService] Fetching tool: ${toolId}`);

    return this.http
      .get<{
        message: string;
        data: ToolRegistryRecord;
      }>(`${this.apiUrl}/registry/${toolId}`, { headers: this.getAuthHeaders() })
      .pipe(
        map((response) => response.data),
        this.retryStrategy(),
        catchError(this.handleError.bind(this))
      );
  }

  /**
   * Searches for tools matching the provided query.
   *
   * Searches tool names and descriptions for the query string.
   * Results are NOT cached (always fresh from server).
   *
   * @param query - Search query (minimum 2 characters)
   * @returns Observable<ToolRegistryRecord[]> Array of matching tools
   * @throws Error if query is less than 2 characters
   *
   * @example
   * ```typescript
   * this.toolRegistry.searchTools('analytics').subscribe({
   *   next: (results) => {
   *     console.log(`Found ${results.length} matching tools`);
   *   },
   * });
   * ```
   */
  searchTools(query: string): Observable<ToolRegistryRecord[]> {
    if (!query || query.trim().length < 2) {
      return throwError(() => new Error('Search query must be at least 2 characters'));
    }

    console.log(`[ToolRegistryService] Searching tools: "${query}"`);

    return this.http
      .get<{ message: string; data: ToolRegistryRecord[] }>(`${this.apiUrl}/search`, {
        headers: this.getAuthHeaders(),
        params: { q: query.trim() },
      })
      .pipe(
        map((response) => response.data),
        this.retryStrategy(),
        catchError(this.handleError.bind(this))
      );
  }

  /**
   * Clears the cached tool data and forces a fresh fetch from the server.
   *
   * Use this method when you know the tool data has changed on the server
   * (e.g., after creating, updating, or deleting a tool).
   *
   * @example
   * ```typescript
   * // After creating a new tool
   * this.createTool(newTool).subscribe(() => {
   *   this.toolRegistry.refreshCache(); // Refresh to include new tool
   * });
   * ```
   */
  refreshCache(): void {
    console.log('[ToolRegistryService] Clearing cache');
    this.cache$ = undefined;
    this.cacheTimestamp = null;

    // Immediately trigger refetch
    this.getAllTools().subscribe({
      next: () => console.log('[ToolRegistryService] Cache refreshed'),
      error: (err) => console.error('[ToolRegistryService] Refresh failed:', err),
    });
  }

  /**
   * Checks if the current cache is still valid (within CACHE_DURATION).
   *
   * @private
   * @returns true if cache exists and is less than 5 minutes old
   */
  private isCacheValid(): boolean {
    if (!this.cacheTimestamp) return false;

    const age = Date.now() - this.cacheTimestamp;
    const isValid = age < this.CACHE_DURATION;

    if (!isValid) {
      console.log('[ToolRegistryService] Cache expired (age: ${age}ms)');
    }

    return isValid;
  }

  /**
   * Gets HTTP headers with Authorization token.
   *
   * @private
   * @returns HttpHeaders with Bearer token
   */
  private getAuthHeaders(): HttpHeaders {
    const token = this.authService.getToken();
    return new HttpHeaders({
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token}`,
    });
  }

  /**
   * Custom retry strategy with exponential backoff.
   *
   * Retries failed requests up to 3 times with delays of 1s, 2s, 4s.
   * Only retries on network errors (not 4xx client errors).
   *
   * @private
   * @returns RxJS operator for retry logic
   */
  private retryStrategy() {
    return retryWhen((errors: Observable<any>) =>
      errors.pipe(
        scan((retryCount, error) => {
          // Don't retry on 4xx errors (client errors)
          if (error.status >= 400 && error.status < 500) {
            throw error;
          }

          retryCount++;
          if (retryCount > this.MAX_RETRIES) {
            console.error(`[ToolRegistryService] Max retries (${this.MAX_RETRIES}) exceeded`);
            throw error;
          }

          const delayMs = Math.pow(2, retryCount - 1) * 1000; // 1s, 2s, 4s
          console.log(
            `[ToolRegistryService] Retry ${retryCount}/${this.MAX_RETRIES} in ${delayMs}ms...`
          );

          return retryCount;
        }, 0),
        delay(1000) // Initial delay
      )
    );
  }

  /**
   * Handles HTTP errors and returns user-friendly messages.
   *
   * @private
   * @param error - HttpErrorResponse from failed request
   * @returns Observable that errors with user-friendly message
   */
  private handleError(error: HttpErrorResponse): Observable<never> {
    let errorMessage: string;

    if (error.status === 0) {
      // Network error
      errorMessage = 'Network error. Please check your connection.';
    } else if (error.status === 401 || error.status === 403) {
      // Unauthorized - redirect to login
      errorMessage = 'Session expired. Please log in again.';
      this.authService.logout();
      this.router.navigate(['/auth/login']);
    } else if (error.status === 404) {
      errorMessage = 'Tool not found.';
    } else if (error.status >= 500) {
      errorMessage = 'Server error. Please try again later.';
    } else {
      errorMessage = error.error?.message || 'An unexpected error occurred.';
    }

    console.error('[ToolRegistryService] Error:', errorMessage, error);

    return throwError(() => ({
      message: errorMessage,
      status: error.status,
      error: error.error,
    }));
  }
}
````

### Unit Tests

```typescript
// tool-registry.service.spec.ts
import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { Router } from '@angular/router';
import { ToolRegistryService } from './tool-registry.service';
import { AuthService } from './auth.service';
import { ToolRegistryRecord } from '@nodeangularfullstack/shared';

describe('ToolRegistryService', () => {
  let service: ToolRegistryService;
  let httpMock: HttpTestingController;
  let authServiceMock: jasmine.SpyObj<AuthService>;
  let routerMock: jasmine.SpyObj<Router>;

  const mockTools: ToolRegistryRecord[] = [
    {
      id: '1',
      toolId: 'form-builder',
      name: 'Form Builder',
      description: 'Build custom forms',
      version: '1.0.0',
      icon: 'pi-box',
      route: '/tools/form-builder',
      apiBase: '/api/form-builder',
      permissions: ['read', 'write'],
      status: 'registered',
      createdAt: new Date(),
      updatedAt: new Date(),
    },
    {
      id: '2',
      toolId: 'analytics',
      name: 'Analytics Dashboard',
      description: 'View analytics',
      version: '1.0.0',
      icon: 'pi-chart-bar',
      route: '/tools/analytics',
      apiBase: '/api/analytics',
      permissions: ['read'],
      status: 'registered',
      createdAt: new Date(),
      updatedAt: new Date(),
    },
  ];

  beforeEach(() => {
    authServiceMock = jasmine.createSpyObj('AuthService', ['getToken', 'logout']);
    authServiceMock.getToken.and.returnValue('mock-jwt-token');

    routerMock = jasmine.createSpyObj('Router', ['navigate']);

    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [
        ToolRegistryService,
        { provide: AuthService, useValue: authServiceMock },
        { provide: Router, useValue: routerMock },
      ],
    });

    service = TestBed.inject(ToolRegistryService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    httpMock.verify(); // Verify no outstanding HTTP requests
  });

  it('should create service', () => {
    expect(service).toBeTruthy();
  });

  describe('getAllTools()', () => {
    it('should return array of tools', (done) => {
      service.getAllTools().subscribe({
        next: (tools) => {
          expect(tools.length).toBe(2);
          expect(tools[0].toolId).toBe('form-builder');
          done();
        },
      });

      const req = httpMock.expectOne((request) => request.url.includes('/api/tools/registry'));
      expect(req.request.method).toBe('GET');
      expect(req.request.headers.get('Authorization')).toBe('Bearer mock-jwt-token');

      req.flush({ message: 'Success', data: mockTools });
    });

    it('should cache results on second call', (done) => {
      // First call
      service.getAllTools().subscribe();

      const req1 = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
      req1.flush({ message: 'Success', data: mockTools });

      // Second call (should use cache)
      service.getAllTools().subscribe({
        next: (tools) => {
          expect(tools.length).toBe(2);
          done();
        },
      });

      // Verify no second HTTP request
      httpMock.expectNone((r) => r.url.includes('/api/tools/registry'));
    });

    it('should refetch after cache expires', (done) => {
      // First call
      service.getAllTools().subscribe();
      const req1 = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
      req1.flush({ message: 'Success', data: mockTools });

      // Simulate 6 minutes passing (cache expired)
      spyOn(Date, 'now').and.returnValue(Date.now() + 6 * 60 * 1000);

      // Second call (should make new request)
      service.getAllTools().subscribe({
        next: (tools) => {
          expect(tools.length).toBe(2);
          done();
        },
      });

      const req2 = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
      req2.flush({ message: 'Success', data: mockTools });
    });
  });

  describe('getToolById()', () => {
    it('should return single tool', (done) => {
      service.getToolById('form-builder').subscribe({
        next: (tool) => {
          expect(tool.toolId).toBe('form-builder');
          expect(tool.name).toBe('Form Builder');
          done();
        },
      });

      const req = httpMock.expectOne((r) => r.url.includes('/api/tools/registry/form-builder'));
      expect(req.request.method).toBe('GET');

      req.flush({ message: 'Success', data: mockTools[0] });
    });

    it('should throw error for empty toolId', (done) => {
      service.getToolById('').subscribe({
        error: (err) => {
          expect(err.message).toContain('Tool ID is required');
          done();
        },
      });
    });

    it('should handle 404 error', (done) => {
      service.getToolById('nonexistent').subscribe({
        error: (err) => {
          expect(err.status).toBe(404);
          expect(err.message).toContain('Tool not found');
          done();
        },
      });

      const req = httpMock.expectOne((r) => r.url.includes('/api/tools/registry/nonexistent'));
      req.flush({ message: 'Not found' }, { status: 404, statusText: 'Not Found' });
    });
  });

  describe('searchTools()', () => {
    it('should return filtered tools', (done) => {
      service.searchTools('form').subscribe({
        next: (results) => {
          expect(results.length).toBe(1);
          expect(results[0].toolId).toBe('form-builder');
          done();
        },
      });

      const req = httpMock.expectOne((r) => r.url.includes('/api/tools/search?q=form'));
      expect(req.request.method).toBe('GET');

      req.flush({ message: 'Success', data: [mockTools[0]] });
    });

    it('should throw error for short query', (done) => {
      service.searchTools('a').subscribe({
        error: (err) => {
          expect(err.message).toContain('at least 2 characters');
          done();
        },
      });
    });

    it('should not cache search results', (done) => {
      // First search
      service.searchTools('analytics').subscribe();
      const req1 = httpMock.expectOne((r) => r.url.includes('/api/tools/search'));
      req1.flush({ message: 'Success', data: [mockTools[1]] });

      // Second identical search (should make new request)
      service.searchTools('analytics').subscribe({
        next: () => done(),
      });

      const req2 = httpMock.expectOne((r) => r.url.includes('/api/tools/search'));
      req2.flush({ message: 'Success', data: [mockTools[1]] });
    });
  });

  describe('refreshCache()', () => {
    it('should clear cache and trigger refetch', (done) => {
      // Initial call (cached)
      service.getAllTools().subscribe();
      const req1 = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
      req1.flush({ message: 'Success', data: mockTools });

      // Refresh cache
      service.refreshCache();

      // Verify new request triggered
      const req2 = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
      req2.flush({ message: 'Success', data: mockTools });

      done();
    });
  });

  describe('Error Handling', () => {
    it('should handle network error', (done) => {
      service.getAllTools().subscribe({
        error: (err) => {
          expect(err.message).toContain('Network error');
          done();
        },
      });

      const req = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
      req.error(new ErrorEvent('Network error'), { status: 0 });
    });

    it('should redirect on 401 unauthorized', (done) => {
      service.getAllTools().subscribe({
        error: (err) => {
          expect(err.status).toBe(401);
          expect(authServiceMock.logout).toHaveBeenCalled();
          expect(routerMock.navigate).toHaveBeenCalledWith(['/auth/login']);
          done();
        },
      });

      const req = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
      req.flush({ message: 'Unauthorized' }, { status: 401, statusText: 'Unauthorized' });
    });

    it('should handle 500 server error', (done) => {
      service.getAllTools().subscribe({
        error: (err) => {
          expect(err.status).toBe(500);
          expect(err.message).toContain('Server error');
          done();
        },
      });

      const req = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
      req.flush({ message: 'Internal error' }, { status: 500, statusText: 'Server Error' });
    });
  });

  describe('Retry Logic', () => {
    it('should retry 3 times on network error', (done) => {
      let attempts = 0;

      service.getAllTools().subscribe({
        next: (tools) => {
          expect(attempts).toBe(3); // Failed 3 times, succeeded on 4th
          expect(tools.length).toBe(2);
          done();
        },
      });

      // Simulate 3 failures then success
      for (let i = 0; i < 3; i++) {
        const req = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
        attempts++;
        req.error(new ErrorEvent('Network error'));
      }

      // 4th attempt succeeds
      const req = httpMock.expectOne((r) => r.url.includes('/api/tools/registry'));
      req.flush({ message: 'Success', data: mockTools });
    });

    it('should not retry on 404 error', (done) => {
      service.getToolById('nonexistent').subscribe({
        error: (err) => {
          expect(err.status).toBe(404);
          done();
        },
      });

      const req = httpMock.expectOne((r) => r.url.includes('/api/tools/registry/nonexistent'));
      req.flush({ message: 'Not found' }, { status: 404, statusText: 'Not Found' });

      // Verify no retry attempted
      httpMock.expectNone((r) => r.url.includes('/api/tools/registry/nonexistent'));
    });
  });
});
```

---

## Testing

### Manual Testing

**Test 1: Fetch All Tools**

```typescript
// In component ngOnInit()
this.toolRegistryService.getAllTools().subscribe({
  next: (tools) => {
    console.log('Fetched tools:', tools);
    // Expected: Array of ToolRegistryRecord objects
  },
  error: (err) => console.error('Error:', err.message),
});

// Check browser Network tab:
// - Single HTTP GET to /api/tools/registry
// - Authorization header present
// - Response status 200
```

**Test 2: Test Caching**

```typescript
// Subscribe multiple times rapidly
this.toolRegistryService.getAllTools().subscribe();
this.toolRegistryService.getAllTools().subscribe();
this.toolRegistryService.getAllTools().subscribe();

// Check browser Network tab:
// - Only ONE HTTP request made
// - All subscriptions receive same data
```

**Test 3: Test Search**

```typescript
this.toolRegistryService.searchTools('form').subscribe({
  next: (results) => {
    console.log('Search results:', results);
    // Expected: Filtered array of tools matching "form"
  },
});

// Check browser Network tab:
// - HTTP GET to /api/tools/search?q=form
```

**Test 4: Test Refresh Cache**

```typescript
// Initial fetch
this.toolRegistryService.getAllTools().subscribe();

// Wait 1 second, then refresh
setTimeout(() => {
  this.toolRegistryService.refreshCache();
  // Check Network tab: New HTTP request triggered
}, 1000);
```

**Test 5: Test Error Handling**

```bash
# 1. Stop backend API server
npm stop

# 2. Try to fetch tools in frontend
this.toolRegistryService.getAllTools().subscribe({
  error: (err) => {
    console.error('Expected error:', err.message);
    // Expected: "Network error. Please check your connection."
  },
});

# 3. Check console for retry logs:
# [ToolRegistryService] Retry 1/3 in 1000ms...
# [ToolRegistryService] Retry 2/3 in 2000ms...
# [ToolRegistryService] Retry 3/3 in 4000ms...
# [ToolRegistryService] Max retries (3) exceeded
```

### Automated Testing

```bash
# Run unit tests
npm --workspace=apps/web run test -- --include="**/tool-registry.service.spec.ts" --watch=false

# Expected output:
# PASS src/app/core/services/tool-registry.service.spec.ts
#   ToolRegistryService
#     ✓ should create service (15ms)
#     getAllTools()
#       ✓ should return array of tools (30ms)
#       ✓ should cache results on second call (25ms)
#       ✓ should refetch after cache expires (28ms)
#     getToolById()
#       ✓ should return single tool (20ms)
#       ✓ should throw error for empty toolId (10ms)
#       ✓ should handle 404 error (25ms)
#     searchTools()
#       ✓ should return filtered tools (20ms)
#       ✓ should throw error for short query (10ms)
#       ✓ should not cache search results (30ms)
#     refreshCache()
#       ✓ should clear cache and trigger refetch (28ms)
#     Error Handling
#       ✓ should handle network error (22ms)
#       ✓ should redirect on 401 unauthorized (25ms)
#       ✓ should handle 500 server error (20ms)
#     Retry Logic
#       ✓ should retry 3 times on network error (80ms)
#       ✓ should not retry on 404 error (18ms)
#
# Tests: 16 passed, 16 total
# Coverage: Statements 92%, Branches 88%, Functions 90%, Lines 92%
```

---

## Dependencies

**Depends On:**

- Epic 30.2: Tool Registry Backend (API endpoints)
- Story 32.1.1: ToolCard Component (for displaying fetched tools)
- AuthService (for authentication tokens)

**Blocks:**

- Story 32.1.3: ToolsList Component (needs service to fetch tools)
- Story 32.1.4: Search and Filtering UI (uses service for search)

**Related Stories:**

- None

---

## QA Gate

**Quality Score Target:** ≥90/100

**Criteria:**

| Criterion                    | Weight | Target                          |
| ---------------------------- | ------ | ------------------------------- |
| Unit test coverage           | 20%    | ≥90%                            |
| All tests passing            | 15%    | 100% pass rate                  |
| Caching behavior functional  | 15%    | Cache verified with Network tab |
| Retry logic functional       | 15%    | 3 retries with backoff          |
| Error handling comprehensive | 15%    | All error types handled         |
| TypeScript type safety       | 10%    | No `any` types                  |
| JSDoc documentation complete | 10%    | All public methods              |

**Exit Criteria:**

- All unit tests pass with ≥90% coverage
- Caching prevents duplicate HTTP requests (verified manually)
- Retry logic works with exponential backoff (verified in console logs)
- All error scenarios handled gracefully (404, 401, 500, network)
- Authorization headers added to all requests
- Service exported and importable in feature modules
- JSDoc comments complete for all public methods

---

## Notes

- ToolRegistryService is the central data layer for tool management
- Caching strategy balances performance (fewer requests) with freshness (5 min expiration)
- Retry logic handles transient network failures gracefully
- Search results intentionally NOT cached to always return fresh data
- Service integrates with AuthService for authentication flow
- All HTTP errors provide user-friendly messages
- Console logging helps debug caching and retry behavior
- Service follows Angular best practices (singleton with providedIn: 'root')
