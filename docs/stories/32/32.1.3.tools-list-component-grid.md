# Story 32.1.3: ToolsList Component (Grid Layout)

**Epic:** 32.1 - UI Components & Tool Discovery **Story Points:** 6 **Priority:** P1 **Assignee:**
Frontend Developer **Status:** Draft

---

## Description

Create a `ToolsListComponent` that displays multiple tools in a responsive grid layout. This
component uses `ToolCardComponent` to render individual tools and integrates with
`ToolRegistryService` to fetch tool data. Supports loading states, empty states, and error handling.

**Context:**

- Story 32.1.1 created ToolCardComponent for displaying individual tools
- Story 32.1.2 created ToolRegistryService for fetching tool data
- This component serves as the main tool discovery page in the dashboard
- Uses CSS Grid for responsive layout (4 cols desktop, 2 cols tablet, 1 col mobile)

---

## Acceptance Criteria

**AC1: Component Structure & Setup**

- ✅ Component created at `apps/web/src/app/features/tools/components/tools-list/`
- ✅ Standalone component with proper imports (CommonModule, ToolCardComponent)
- ✅ Injects ToolRegistryService in constructor
- ✅ Uses signals for reactive state management
- ✅ Component exported from tools feature barrel exports

**AC2: Tool Data Fetching**

- ✅ Fetches all tools on component init using `ToolRegistryService.getAllTools()`
- ✅ Stores tools in signal: `tools = signal<ToolRegistryRecord[]>([])`
- ✅ Tracks loading state: `loading = signal<boolean>(true)`
- ✅ Tracks error state: `error = signal<string | null>(null)`
- ✅ Handles subscription cleanup on component destroy

**AC3: Grid Layout Implementation**

- ✅ Uses CSS Grid for responsive layout
- ✅ Desktop (≥1200px): 4 columns, 24px gap
- ✅ Tablet (768px-1199px): 2 columns, 16px gap
- ✅ Mobile (<768px): 1 column, 12px gap
- ✅ Cards auto-fill available space with `grid-template-columns: repeat(auto-fill, minmax(...))`
- ✅ Grid maintains aspect ratio and alignment

**AC4: Loading State**

- ✅ Displays 8 skeleton ToolCards while loading
- ✅ Skeleton cards match final grid layout
- ✅ Loading state shows immediately on mount
- ✅ Loading state dismisses when data arrives or error occurs
- ✅ Uses `*ngFor` to render skeleton cards

**AC5: Empty State**

- ✅ Displays friendly message when no tools registered
- ✅ Shows icon (pi-inbox) and text "No tools found"
- ✅ Includes call-to-action button "Register New Tool"
- ✅ CTA button links to tool registration page (if applicable)
- ✅ Empty state centered vertically and horizontally

**AC6: Error State**

- ✅ Displays error message on fetch failure
- ✅ Shows error icon (pi-exclamation-triangle) and error text
- ✅ Includes "Try Again" button to retry fetch
- ✅ Error message user-friendly (not raw API error)
- ✅ Retry button calls `refreshTools()` method

**AC7: Tool Card Interactions**

- ✅ Handles `toolClick` event from ToolCardComponent
- ✅ Navigates to tool detail page on card click
- ✅ Uses Angular Router for navigation
- ✅ Passes toolId as route parameter
- ✅ Hover effects inherited from ToolCardComponent

**AC8: Refresh Functionality**

- ✅ Provides `refreshTools()` method to refetch data
- ✅ Method clears cache via `ToolRegistryService.refreshCache()`
- ✅ Shows loading state during refresh
- ✅ Can be triggered by parent component or user action
- ✅ Emits event when refresh completes

**AC9: Component Tests**

- ✅ Unit tests with ≥90% coverage
- ✅ Test: fetches tools on init
- ✅ Test: displays tools in grid
- ✅ Test: shows loading skeleton initially
- ✅ Test: shows empty state when no tools
- ✅ Test: shows error state on fetch failure
- ✅ Test: navigates on tool click
- ✅ Test: refreshTools() refetches data

---

## Tasks

### Task 1: Component File Structure

**Subtasks:**

1. Create directory `apps/web/src/app/features/tools/components/tools-list/`
2. Create `tools-list.component.ts` file
3. Create `tools-list.component.html` template
4. Create `tools-list.component.scss` styles
5. Create `tools-list.component.spec.ts` test file
6. Update `apps/web/src/app/features/tools/components/index.ts` barrel export
7. Import ToolCardComponent from shared components
8. Import ToolRegistryService from core services
9. Verify file structure matches project conventions
10. Add JSDoc comments to file header

### Task 2: Component Class & Signals

**Subtasks:**

1. Define `@Component` decorator with standalone: true
2. Import CommonModule, ToolCardComponent
3. Inject ToolRegistryService in constructor
4. Inject Router for navigation
5. Define `tools = signal<ToolRegistryRecord[]>([])`
6. Define `loading = signal<boolean>(true)`
7. Define `error = signal<string | null>(null)`
8. Define `@Output() toolsLoaded = new EventEmitter<ToolRegistryRecord[]>()`
9. Implement OnInit interface
10. Implement OnDestroy interface for cleanup

### Task 3: Tool Fetching Logic (ngOnInit)

**Subtasks:**

1. Implement `ngOnInit()` lifecycle hook
2. Set loading state to true
3. Call `toolRegistryService.getAllTools()`
4. Subscribe to Observable
5. On success: update tools signal, set loading false
6. On error: update error signal, set loading false
7. Emit toolsLoaded event with fetched tools
8. Store subscription for cleanup
9. Add error logging to console
10. Add JSDoc for ngOnInit

### Task 4: Subscription Cleanup (ngOnDestroy)

**Subtasks:**

1. Implement `ngOnDestroy()` lifecycle hook
2. Create `destroy$ = new Subject<void>()` signal
3. Use `takeUntil(destroy$)` in subscriptions
4. Emit destroy$ signal on component destroy
5. Complete destroy$ observable
6. Verify no memory leaks
7. Add JSDoc for ngOnDestroy
8. Test subscription cleanup
9. Document cleanup pattern
10. Verify unsubscribe called in tests

### Task 5: Refresh Tools Method

**Subtasks:**

1. Create `refreshTools(): void` method
2. Set loading signal to true
3. Clear error signal
4. Call `toolRegistryService.refreshCache()`
5. Re-fetch tools using getAllTools()
6. Update tools signal on success
7. Update error signal on failure
8. Set loading false when complete
9. Add JSDoc with @example
10. Add unit tests for refresh

### Task 6: Tool Click Handler

**Subtasks:**

1. Create `onToolClick(tool: ToolRegistryRecord): void` method
2. Extract toolId from tool object
3. Use Angular Router to navigate
4. Navigate to `/tools/${tool.toolId}` route
5. Log navigation for debugging
6. Handle navigation errors
7. Add JSDoc with @param
8. Test navigation with RouterTestingModule
9. Verify route parameters passed correctly
10. Test with missing toolId

### Task 7: Grid Layout Template

**Subtasks:**

1. Create root `<div class="tools-list-container">`
2. Add loading state section with `*ngIf="loading()"`
3. Add error state section with `*ngIf="error() && !loading()"`
4. Add empty state section with `*ngIf="!loading() && !error() && tools().length === 0"`
5. Add tools grid section with `*ngIf="!loading() && !error() && tools().length > 0"`
6. Create `<div class="tools-grid">` container
7. Use `*ngFor` to iterate tools
8. Render `<app-tool-card>` for each tool
9. Bind `[tool]` input to current tool
10. Bind `(toolClick)` output to onToolClick handler

### Task 8: Loading State Template

**Subtasks:**

1. Create `<div class="tools-grid-skeleton">`
2. Use `*ngFor="let i of [1,2,3,4,5,6,7,8]"` to create 8 skeleton cards
3. Render `<app-tool-card [loading]="true">` for each skeleton
4. Match skeleton grid layout to actual grid
5. Add loading message above skeleton grid
6. Use PrimeNG ProgressSpinner (optional)
7. Style loading container
8. Test loading state display
9. Verify skeleton count responsive (fewer on mobile)
10. Add ARIA labels for accessibility

### Task 9: Empty State Template

**Subtasks:**

1. Create `<div class="empty-state">` container
2. Add icon `<i class="pi pi-inbox empty-icon"></i>`
3. Add heading `<h3>No tools found</h3>`
4. Add description `<p>Get started by registering your first tool</p>`
5. Add CTA button `<p-button label="Register New Tool">`
6. Bind button click to navigation (optional - may not exist yet)
7. Style empty state (centered, muted colors)
8. Add illustration or image (optional)
9. Test empty state display
10. Verify accessibility (ARIA labels, focus)

### Task 10: Error State Template

**Subtasks:**

1. Create `<div class="error-state">` container
2. Add error icon `<i class="pi pi-exclamation-triangle error-icon"></i>`
3. Add error message `<p>{{ error() }}</p>`
4. Add "Try Again" button `<p-button label="Try Again">`
5. Bind button click to `refreshTools()` method
6. Style error state (red accent, centered)
7. Add error details expander (optional)
8. Test error state display
9. Test retry button functionality
10. Verify accessibility

### Task 11: CSS Grid Styling

**Subtasks:**

1. Define `.tools-grid` with `display: grid`
2. Set `grid-template-columns: repeat(auto-fill, minmax(300px, 1fr))`
3. Set `gap: 24px` for desktop
4. Add responsive breakpoint for tablet (768px-1199px)
5. Tablet: `grid-template-columns: repeat(2, 1fr)`, `gap: 16px`
6. Add responsive breakpoint for mobile (<768px)
7. Mobile: `grid-template-columns: 1fr`, `gap: 12px`
8. Style `.tools-list-container` with padding and max-width
9. Add smooth transitions for grid changes
10. Test grid responsiveness across breakpoints

### Task 12: Loading State Styling

**Subtasks:**

1. Style `.tools-grid-skeleton` matching `.tools-grid`
2. Add fade-in animation for skeleton cards
3. Add shimmer animation (optional)
4. Style loading message
5. Center loading spinner (if using ProgressSpinner)
6. Match skeleton grid columns to actual grid
7. Add loading overlay (optional)
8. Test loading appearance
9. Verify smooth transition from loading to loaded
10. Add dark mode support (if applicable)

### Task 13: Empty & Error State Styling

**Subtasks:**

1. Style `.empty-state` with vertical/horizontal centering
2. Set empty icon size (4rem) and color (muted)
3. Style empty heading and description
4. Style CTA button (primary color, prominent)
5. Add spacing between empty state elements
6. Style `.error-state` similar to empty state
7. Set error icon color (red/warning)
8. Style error message (error color)
9. Style retry button (secondary color)
10. Test both states for visual consistency

### Task 14: Unit Tests - Data Fetching

**Subtasks:**

1. Setup test bed with required imports
2. Mock ToolRegistryService with spy object
3. Write test: "should create component"
4. Write test: "should fetch tools on init"
5. Write test: "should update tools signal on success"
6. Write test: "should set loading false after fetch"
7. Write test: "should handle fetch error"
8. Write test: "should update error signal on failure"
9. Verify service method called once on init
10. Use `fakeAsync` and `tick()` for async testing

### Task 15: Unit Tests - Rendering

**Subtasks:**

1. Write test: "should render tool cards for each tool"
2. Write test: "should display loading skeleton initially"
3. Write test: "should display empty state when no tools"
4. Write test: "should display error state on failure"
5. Write test: "should render correct number of cards"
6. Verify `*ngFor` renders correct number of elements
7. Verify tool data passed to ToolCardComponent inputs
8. Use `By.css()` to query DOM elements
9. Use `By.directive()` to query child components
10. Test conditional rendering (`*ngIf`)

### Task 16: Unit Tests - Interactions

**Subtasks:**

1. Write test: "should navigate on tool click"
2. Mock Router with spy object
3. Trigger toolClick event from ToolCardComponent
4. Verify router.navigate called with correct route
5. Write test: "should refresh tools on retry button click"
6. Trigger button click in error state
7. Verify service.refreshCache() called
8. Write test: "should emit toolsLoaded event"
9. Spy on event emitter
10. Verify emit called with correct data

---

## Dev Notes

### Component Implementation

**TypeScript (tools-list.component.ts):**

````typescript
import { Component, OnInit, OnDestroy, Output, EventEmitter, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router } from '@angular/router';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { ButtonModule } from 'primeng/button';
import { ToolCardComponent } from '@app/shared/components/tool-card/tool-card.component';
import { ToolRegistryService } from '@app/core/services/tool-registry.service';
import { ToolRegistryRecord } from '@nodeangularfullstack/shared';

/**
 * Displays a grid of registered tools using ToolCardComponent.
 *
 * Fetches tool data from ToolRegistryService and handles loading,
 * empty, and error states. Supports navigation to tool detail pages.
 *
 * @example
 * ```html
 * <app-tools-list (toolsLoaded)="onToolsLoaded($event)"></app-tools-list>
 * ```
 */
@Component({
  selector: 'app-tools-list',
  standalone: true,
  imports: [CommonModule, ToolCardComponent, ButtonModule],
  templateUrl: './tools-list.component.html',
  styleUrl: './tools-list.component.scss',
})
export class ToolsListComponent implements OnInit, OnDestroy {
  /**
   * List of tools fetched from the registry.
   */
  tools = signal<ToolRegistryRecord[]>([]);

  /**
   * Loading state indicator.
   */
  loading = signal<boolean>(true);

  /**
   * Error message if fetch fails.
   */
  error = signal<string | null>(null);

  /**
   * Emitted when tools are successfully loaded.
   */
  @Output() toolsLoaded = new EventEmitter<ToolRegistryRecord[]>();

  /**
   * Subject for managing subscription cleanup.
   */
  private destroy$ = new Subject<void>();

  /**
   * Skeleton card count for loading state.
   */
  readonly skeletonCount = Array.from({ length: 8 }, (_, i) => i);

  constructor(
    private toolRegistryService: ToolRegistryService,
    private router: Router
  ) {}

  /**
   * Fetches tools on component initialization.
   */
  ngOnInit(): void {
    this.loadTools();
  }

  /**
   * Cleans up subscriptions on component destroy.
   */
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  /**
   * Loads tools from the registry service.
   *
   * @private
   */
  private loadTools(): void {
    this.loading.set(true);
    this.error.set(null);

    this.toolRegistryService
      .getAllTools()
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (tools) => {
          console.log(`[ToolsListComponent] Loaded ${tools.length} tools`);
          this.tools.set(tools);
          this.loading.set(false);
          this.toolsLoaded.emit(tools);
        },
        error: (err) => {
          console.error('[ToolsListComponent] Failed to load tools:', err);
          this.error.set(err.message || 'Failed to load tools');
          this.loading.set(false);
        },
      });
  }

  /**
   * Refreshes the tool list by clearing cache and refetching.
   *
   * @example
   * ```typescript
   * // Triggered by "Try Again" button in error state
   * this.refreshTools();
   * ```
   */
  refreshTools(): void {
    console.log('[ToolsListComponent] Refreshing tools...');
    this.toolRegistryService.refreshCache();
    this.loadTools();
  }

  /**
   * Handles tool card click and navigates to tool detail page.
   *
   * @param tool - The clicked tool
   */
  onToolClick(tool: ToolRegistryRecord): void {
    console.log(`[ToolsListComponent] Tool clicked: ${tool.toolId}`);
    this.router.navigate(['/tools', tool.toolId]);
  }
}
````

**Template (tools-list.component.html):**

```html
<div class="tools-list-container">
  <!-- Header (optional) -->
  <div class="tools-list-header">
    <h2>Registered Tools</h2>
    <p class="subtitle">Browse and manage your registered tools</p>
  </div>

  <!-- Loading State -->
  <ng-container *ngIf="loading()">
    <div class="loading-message">
      <i class="pi pi-spin pi-spinner"></i>
      <span>Loading tools...</span>
    </div>
    <div class="tools-grid tools-grid-skeleton">
      <app-tool-card *ngFor="let i of skeletonCount" [loading]="true"></app-tool-card>
    </div>
  </ng-container>

  <!-- Error State -->
  <ng-container *ngIf="error() && !loading()">
    <div class="error-state">
      <i class="pi pi-exclamation-triangle error-icon"></i>
      <h3>Failed to Load Tools</h3>
      <p class="error-message">{{ error() }}</p>
      <p-button
        label="Try Again"
        icon="pi pi-refresh"
        (onClick)="refreshTools()"
        severity="secondary"
      ></p-button>
    </div>
  </ng-container>

  <!-- Empty State -->
  <ng-container *ngIf="!loading() && !error() && tools().length === 0">
    <div class="empty-state">
      <i class="pi pi-inbox empty-icon"></i>
      <h3>No Tools Found</h3>
      <p class="empty-message">Get started by registering your first tool</p>
      <p-button
        label="Register New Tool"
        icon="pi pi-plus"
        severity="primary"
        [routerLink]="['/tools/create']"
      ></p-button>
    </div>
  </ng-container>

  <!-- Tools Grid -->
  <ng-container *ngIf="!loading() && !error() && tools().length > 0">
    <div class="tools-grid">
      <app-tool-card
        *ngFor="let tool of tools()"
        [tool]="tool"
        [interactive]="true"
        (toolClick)="onToolClick($event)"
      ></app-tool-card>
    </div>
  </ng-container>
</div>
```

**Styles (tools-list.component.scss):**

```scss
.tools-list-container {
  padding: 24px;
  max-width: 1400px;
  margin: 0 auto;

  @media (max-width: 768px) {
    padding: 16px;
  }
}

.tools-list-header {
  margin-bottom: 32px;

  h2 {
    font-size: 2rem;
    font-weight: 700;
    color: var(--text-color);
    margin: 0 0 8px 0;
  }

  .subtitle {
    font-size: 1rem;
    color: var(--text-color-secondary);
    margin: 0;
  }
}

.loading-message {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 24px;
  color: var(--text-color-secondary);
  font-size: 1rem;

  i {
    font-size: 1.5rem;
    color: var(--primary-color);
  }
}

.tools-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 24px;

  @media (max-width: 1199px) {
    grid-template-columns: repeat(2, 1fr);
    gap: 16px;
  }

  @media (max-width: 768px) {
    grid-template-columns: 1fr;
    gap: 12px;
  }
}

.tools-grid-skeleton {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.empty-state,
.error-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 80px 32px;
  text-align: center;

  @media (max-width: 768px) {
    padding: 48px 16px;
  }
}

.empty-icon,
.error-icon {
  font-size: 4rem;
  margin-bottom: 24px;
}

.empty-icon {
  color: var(--text-color-secondary);
}

.error-icon {
  color: var(--red-500);
}

h3 {
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text-color);
  margin: 0 0 12px 0;
}

.empty-message,
.error-message {
  font-size: 1rem;
  color: var(--text-color-secondary);
  margin: 0 0 24px 0;
  max-width: 400px;
}

.error-message {
  color: var(--red-600);
}

p-button {
  margin-top: 8px;
}
```

### Unit Tests

```typescript
// tools-list.component.spec.ts
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { Router } from '@angular/router';
import { of, throwError } from 'rxjs';
import { ToolsListComponent } from './tools-list.component';
import { ToolRegistryService } from '@app/core/services/tool-registry.service';
import { ToolRegistryRecord } from '@nodeangularfullstack/shared';
import { By } from '@angular/platform-browser';

describe('ToolsListComponent', () => {
  let component: ToolsListComponent;
  let fixture: ComponentFixture<ToolsListComponent>;
  let mockToolRegistryService: jasmine.SpyObj<ToolRegistryService>;
  let mockRouter: jasmine.SpyObj<Router>;

  const mockTools: ToolRegistryRecord[] = [
    {
      id: '1',
      toolId: 'form-builder',
      name: 'Form Builder',
      description: 'Build custom forms',
      version: '1.0.0',
      icon: 'pi-box',
      route: '/tools/form-builder',
      apiBase: '/api/form-builder',
      permissions: ['read', 'write'],
      status: 'registered',
      createdAt: new Date(),
      updatedAt: new Date(),
    },
    {
      id: '2',
      toolId: 'analytics',
      name: 'Analytics',
      description: 'View analytics',
      version: '1.0.0',
      icon: 'pi-chart-bar',
      route: '/tools/analytics',
      apiBase: '/api/analytics',
      permissions: ['read'],
      status: 'registered',
      createdAt: new Date(),
      updatedAt: new Date(),
    },
  ];

  beforeEach(async () => {
    mockToolRegistryService = jasmine.createSpyObj('ToolRegistryService', [
      'getAllTools',
      'refreshCache',
    ]);
    mockToolRegistryService.getAllTools.and.returnValue(of(mockTools));

    mockRouter = jasmine.createSpyObj('Router', ['navigate']);

    await TestBed.configureTestingModule({
      imports: [ToolsListComponent],
      providers: [
        { provide: ToolRegistryService, useValue: mockToolRegistryService },
        { provide: Router, useValue: mockRouter },
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(ToolsListComponent);
    component = fixture.componentInstance;
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  describe('Data Fetching', () => {
    it('should fetch tools on init', () => {
      fixture.detectChanges();
      expect(mockToolRegistryService.getAllTools).toHaveBeenCalled();
    });

    it('should update tools signal on success', (done) => {
      fixture.detectChanges();

      setTimeout(() => {
        expect(component.tools().length).toBe(2);
        expect(component.tools()[0].toolId).toBe('form-builder');
        done();
      }, 0);
    });

    it('should set loading false after fetch', (done) => {
      fixture.detectChanges();

      setTimeout(() => {
        expect(component.loading()).toBe(false);
        done();
      }, 0);
    });

    it('should handle fetch error', (done) => {
      const errorMessage = 'Network error';
      mockToolRegistryService.getAllTools.and.returnValue(
        throwError(() => ({ message: errorMessage }))
      );

      fixture.detectChanges();

      setTimeout(() => {
        expect(component.error()).toBe(errorMessage);
        expect(component.loading()).toBe(false);
        done();
      }, 0);
    });

    it('should emit toolsLoaded event', (done) => {
      spyOn(component.toolsLoaded, 'emit');
      fixture.detectChanges();

      setTimeout(() => {
        expect(component.toolsLoaded.emit).toHaveBeenCalledWith(mockTools);
        done();
      }, 0);
    });
  });

  describe('Rendering', () => {
    it('should display loading skeleton initially', () => {
      const compiled = fixture.debugElement;
      const skeletonCards = compiled.queryAll(By.css('.tools-grid-skeleton app-tool-card'));

      expect(skeletonCards.length).toBe(8);
    });

    it('should render tool cards after loading', (done) => {
      fixture.detectChanges();

      setTimeout(() => {
        fixture.detectChanges();
        const toolCards = fixture.debugElement.queryAll(By.css('.tools-grid app-tool-card'));
        expect(toolCards.length).toBe(2);
        done();
      }, 0);
    });

    it('should display empty state when no tools', (done) => {
      mockToolRegistryService.getAllTools.and.returnValue(of([]));
      fixture.detectChanges();

      setTimeout(() => {
        fixture.detectChanges();
        const emptyState = fixture.debugElement.query(By.css('.empty-state'));
        expect(emptyState).toBeTruthy();
        expect(emptyState.nativeElement.textContent).toContain('No Tools Found');
        done();
      }, 0);
    });

    it('should display error state on failure', (done) => {
      mockToolRegistryService.getAllTools.and.returnValue(
        throwError(() => ({ message: 'Failed to load' }))
      );
      fixture.detectChanges();

      setTimeout(() => {
        fixture.detectChanges();
        const errorState = fixture.debugElement.query(By.css('.error-state'));
        expect(errorState).toBeTruthy();
        expect(errorState.nativeElement.textContent).toContain('Failed to load');
        done();
      }, 0);
    });
  });

  describe('Interactions', () => {
    it('should navigate on tool click', (done) => {
      fixture.detectChanges();

      setTimeout(() => {
        component.onToolClick(mockTools[0]);
        expect(mockRouter.navigate).toHaveBeenCalledWith(['/tools', 'form-builder']);
        done();
      }, 0);
    });

    it('should refresh tools on retry', () => {
      component.refreshTools();
      expect(mockToolRegistryService.refreshCache).toHaveBeenCalled();
      expect(mockToolRegistryService.getAllTools).toHaveBeenCalledTimes(2); // init + refresh
    });
  });
});
```

---

## Testing

### Manual Testing

**Test 1: View Tools Grid**

```bash
# 1. Ensure backend API running with registered tools
npm --workspace=apps/api run db:seed

# 2. Start frontend
npm --workspace=apps/web run dev

# 3. Navigate to http://localhost:4200/tools
# Expected: Grid of tool cards, 4 columns on desktop
```

**Test 2: Test Responsive Layout**

```bash
# 1. Open browser DevTools (F12)
# 2. Enable device toolbar (Ctrl+Shift+M)
# 3. Test breakpoints:
#    - Desktop (1200px): 4 columns
#    - Tablet (800px): 2 columns
#    - Mobile (400px): 1 column
# Expected: Grid adapts smoothly at each breakpoint
```

**Test 3: Test Loading State**

```bash
# 1. Open Network tab in DevTools
# 2. Throttle network to "Slow 3G"
# 3. Refresh page
# Expected: 8 skeleton cards display while loading
```

**Test 4: Test Empty State**

```bash
# 1. Clear all tools from database
psql -U user -d nodeangular_db -c "DELETE FROM tool_registry;"

# 2. Refresh page
# Expected: Empty state with "No tools found" message
```

**Test 5: Test Error State**

```bash
# 1. Stop backend API server
npm stop

# 2. Refresh page
# Expected: Error state with "Try Again" button

# 3. Start API server
npm start

# 4. Click "Try Again"
# Expected: Tools load successfully
```

**Test 6: Test Tool Navigation**

```bash
# 1. Click on a tool card
# Expected: Navigate to /tools/:toolId route
# (May show 404 if route not implemented yet)
```

### Automated Testing

```bash
# Run unit tests
npm --workspace=apps/web run test -- --include="**/tools-list.component.spec.ts" --watch=false

# Expected output:
# PASS src/app/features/tools/components/tools-list/tools-list.component.spec.ts
#   ToolsListComponent
#     ✓ should create (20ms)
#     Data Fetching
#       ✓ should fetch tools on init (25ms)
#       ✓ should update tools signal on success (30ms)
#       ✓ should set loading false after fetch (28ms)
#       ✓ should handle fetch error (25ms)
#       ✓ should emit toolsLoaded event (30ms)
#     Rendering
#       ✓ should display loading skeleton initially (22ms)
#       ✓ should render tool cards after loading (35ms)
#       ✓ should display empty state when no tools (30ms)
#       ✓ should display error state on failure (32ms)
#     Interactions
#       ✓ should navigate on tool click (20ms)
#       ✓ should refresh tools on retry (25ms)
#
# Tests: 12 passed, 12 total
# Coverage: Statements 94%, Branches 90%, Functions 92%, Lines 94%
```

---

## Dependencies

**Depends On:**

- Story 32.1.1: ToolCard Component (for rendering individual tools)
- Story 32.1.2: Tool Registry Service (for fetching tool data)
- AuthService (for authentication, via ToolRegistryService)

**Blocks:**

- Story 32.1.4: Search and Filtering UI (will use ToolsListComponent)
- Story 32.2.2: Tool Detail Pages (navigation target)

**Related Stories:**

- None

---

## QA Gate

**Quality Score Target:** ≥90/100

**Criteria:**

| Criterion                    | Weight | Target                     |
| ---------------------------- | ------ | -------------------------- |
| Unit test coverage           | 20%    | ≥90%                       |
| All tests passing            | 15%    | 100% pass rate             |
| Grid layout responsive       | 15%    | Works at 3 breakpoints     |
| Loading state UX             | 15%    | Smooth skeleton display    |
| Empty state UX               | 10%    | Clear message + CTA        |
| Error state UX               | 10%    | Clear error + retry button |
| Code quality (ESLint)        | 10%    | No errors or warnings      |
| JSDoc documentation complete | 5%     | All public methods         |

**Exit Criteria:**

- All unit tests pass with ≥90% coverage
- Grid displays correctly at all breakpoints (tested manually)
- Loading skeleton shows 8 cards matching final layout
- Empty state displays when no tools available
- Error state displays on fetch failure with working retry button
- Tool click navigates to correct route
- Component exported and importable in feature modules
- Signals update correctly (verified in tests)

---

## Notes

- ToolsListComponent serves as the main tool discovery page
- Uses CSS Grid for automatic responsive layout without media query logic in template
- Skeleton count (8) provides visual balance without overwhelming the page
- Empty state encourages user action with prominent CTA button
- Error state provides clear path to recovery (retry button)
- Component is reusable - can be embedded in dashboard or dedicated tools page
- Subscription cleanup prevents memory leaks on navigation
- Signals provide reactive updates without manual change detection
