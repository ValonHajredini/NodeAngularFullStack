# Story 32.2.5: Integration Tests for Epic 32.2

**Epic:** 32.2 Dynamic Routing & Export UI (25 pts) **Story Points:** 5 **Priority:** High
**Status:** Approved **Created:** 2025-10-24

---

## Description

Implement comprehensive integration and E2E tests for Epic 32.2, validating the complete dynamic
routing, tool detail pages, export permission checks, and export progress modal workflows. Ensure
all components, services, and route guards work together seamlessly with proper error handling and
user feedback.

---

## Acceptance Criteria

### E2E User Flow Testing

- [ ] Test navigation from tools list → tool detail page with valid toolId
- [ ] Test direct navigation to tool detail page via URL
- [ ] Test 404 redirect when navigating to invalid toolId
- [ ] Test tab switching on tool detail page (Overview → Config → Manifest → Analytics)
- [ ] Test copy-to-clipboard functionality for toolId
- [ ] Test export button visibility and state for admin users
- [ ] Test export button visibility and state for users with 'export' permission
- [ ] Test export button disabled state for users without permissions
- [ ] Test export modal opening from tool detail page
- [ ] Test export progress polling and real-time updates
- [ ] Test cancel export workflow with confirmation
- [ ] Test successful export completion flow with success message

### Integration Testing

- [ ] Test ToolGuard integration with Router and ToolRegistryService
- [ ] Test ToolDetailComponent integration with ToolRegistryService and AuthService
- [ ] Test ExportProgressModalComponent integration with ExportJobService
- [ ] Test permission computed signals with AuthService data changes
- [ ] Test modal lifecycle (open → poll → complete/cancel → close)
- [ ] Test error handling across component boundaries
- [ ] Test loading states and transitions between components

### API Integration

- [ ] Test tool detail API endpoint with mock backend
- [ ] Test export job creation API endpoint
- [ ] Test export job status polling API endpoint
- [ ] Test export job cancellation API endpoint
- [ ] Test API error scenarios (network errors, 404, 401, 500)
- [ ] Test API retry logic for transient failures

### Permission Scenarios

- [ ] Test admin role accessing export functionality
- [ ] Test user with 'export' permission accessing export functionality
- [ ] Test user without 'export' permission viewing disabled export button
- [ ] Test permission changes triggering UI updates (computed signals)
- [ ] Test unauthenticated user redirected from protected routes

### Regression Testing

- [ ] Verify all previous Epic 32.1 functionality still works (tools list, search, filtering)
- [ ] Verify lazy loading doesn't break navigation
- [ ] Verify URL query parameters maintained during navigation
- [ ] Verify browser back/forward buttons work correctly
- [ ] Verify responsive design maintained across all new pages

### Coverage Requirements

- [ ] Epic 32.2 components: ≥90% statement coverage
- [ ] Epic 32.2 services: ≥90% branch coverage
- [ ] Epic 32.2 route guards: 100% coverage
- [ ] E2E test coverage for all critical user paths

---

## Tasks

### 1. Setup Integration Test Infrastructure

**Estimated:** 4 hours **Dependencies:** None **Description:** Configure Playwright and Jest for
integration testing, create test utilities and mock services.

**Subtasks:**

1. Install Playwright dependencies (`@playwright/test`, `playwright`)
2. Create `tests/e2e/epic-32.2/` directory structure
3. Configure playwright.config.ts with test project for Epic 32.2
4. Create `tests/e2e/helpers/auth-helpers.ts` with login utilities
5. Create `tests/e2e/helpers/navigation-helpers.ts` with routing utilities
6. Create `tests/e2e/fixtures/tool-fixtures.ts` with mock tool data
7. Create `tests/e2e/fixtures/export-job-fixtures.ts` with mock job data
8. Setup API mocking with MSW (Mock Service Worker) or Playwright route interception
9. Create `tests/integration/epic-32.2/setup.ts` with shared test configuration
10. Document test infrastructure setup in story notes

### 2. E2E Test: Tools List to Tool Detail Navigation

**Estimated:** 3 hours **Dependencies:** Task 1 **Description:** Test complete user flow from tools
list to tool detail page.

**Subtasks:**

1. Create `tests/e2e/epic-32.2/tool-navigation.spec.ts`
2. Test clicking ToolCard navigates to correct detail page
3. Test URL updates with correct toolId parameter
4. Test ToolGuard allows navigation with valid toolId
5. Test tool detail page renders with correct data
6. Test browser back button returns to tools list
7. Test browser forward button returns to tool detail
8. Test direct URL navigation to `/tools/:toolId`
9. Test invalid toolId redirects to 404 page
10. Verify no console errors during navigation flow

### 3. E2E Test: Tool Detail Page Interactions

**Estimated:** 4 hours **Dependencies:** Task 2 **Description:** Test all interactive elements on
tool detail page.

**Subtasks:**

1. Create `tests/e2e/epic-32.2/tool-detail-interactions.spec.ts`
2. Test clicking "Overview" tab displays tool description and metadata
3. Test clicking "Config" tab displays tool configuration JSON
4. Test clicking "Manifest" tab displays formatted tool manifest
5. Test clicking "Analytics" tab displays placeholder analytics content
6. Test copy toolId button copies to clipboard
7. Test copy toolId button shows success toast message
8. Test permissions chips display correctly (admin, export, etc.)
9. Test status badge displays correct color (active/inactive)
10. Verify tab state persists during interactions (no re-rendering issues)

### 4. Integration Test: ToolGuard with Router

**Estimated:** 3 hours **Dependencies:** Task 1 **Description:** Test route guard integration with
Angular Router and service layer.

**Subtasks:**

1. Create `apps/web/src/app/features/tools/guards/tool.guard.spec.ts` (integration tests)
2. Mock ToolRegistryService.getToolById() with various responses
3. Test guard returns `true` for valid toolId
4. Test guard returns `false` and redirects for invalid toolId
5. Test guard handles API errors gracefully (redirect to 404)
6. Test guard injects Router and ToolRegistryService correctly
7. Test guard works with lazy loaded routes
8. Test guard doesn't block navigation to other routes
9. Test guard caching behavior (if implemented)
10. Verify guard doesn't cause memory leaks (cleanup subscriptions)

### 5. Integration Test: ToolDetailComponent with Services

**Estimated:** 4 hours **Dependencies:** Task 1 **Description:** Test component integration with
multiple services (ToolRegistryService, AuthService).

**Subtasks:**

1. Create
   `apps/web/src/app/features/tools/pages/tool-detail/tool-detail.component.integration.spec.ts`
2. Mock ToolRegistryService.getToolById() with tool data
3. Mock AuthService.currentUser$ with different user roles
4. Test component loads tool data on init
5. Test component updates when route params change
6. Test canExport computed signal updates when user role changes
7. Test canExport computed signal updates when permissions change
8. Test exportButtonTooltip computed signal reflects permission state
9. Test component handles tool not found error (redirect to 404)
10. Verify component cleanup on destroy (no memory leaks)

### 6. E2E Test: Export Permission Scenarios

**Estimated:** 4 hours **Dependencies:** Task 2, Task 3 **Description:** Test export button behavior
for different user roles and permissions.

**Subtasks:**

1. Create `tests/e2e/epic-32.2/export-permissions.spec.ts`
2. Setup mock authentication for admin user
3. Test admin user sees enabled export button
4. Test admin user can click export button
5. Setup mock authentication for user with 'export' permission
6. Test user with permission sees enabled export button
7. Setup mock authentication for user without 'export' permission
8. Test user without permission sees disabled export button
9. Test disabled button shows tooltip explaining lack of permission
10. Test unauthenticated user doesn't see export button (redirected to login)

### 7. E2E Test: Export Modal Opening and Display

**Estimated:** 3 hours **Dependencies:** Task 6 **Description:** Test export modal lifecycle and
initial display.

**Subtasks:**

1. Create `tests/e2e/epic-32.2/export-modal-display.spec.ts`
2. Login as admin user
3. Navigate to tool detail page
4. Click export button
5. Verify modal opens with correct title (tool name)
6. Verify modal displays "Preparing export..." initial state
7. Verify progress bar shows 0% initially
8. Verify step list is empty or shows "Initializing..."
9. Verify cancel button is visible and enabled
10. Verify modal overlay prevents interaction with background

### 8. Integration Test: Export Progress Polling

**Estimated:** 5 hours **Dependencies:** Task 1 **Description:** Test polling logic and state
updates in ExportProgressModalComponent.

**Subtasks:**

1. Create
   `apps/web/src/app/features/tools/components/export-progress-modal/export-progress-modal.component.integration.spec.ts`
2. Mock ExportJobService.startExport() returning job ID
3. Mock ExportJobService.getJobStatus() returning progressive job states
4. Test component starts polling after modal opens
5. Test polling interval is 2000ms (2 seconds)
6. Test component updates exportJob signal with each poll response
7. Test progress computed signal recalculates on job update (0% → 25% → 50% → 100%)
8. Test polling stops when job status is 'completed'
9. Test polling stops when job status is 'failed'
10. Test polling cleanup on component destroy (no memory leaks)

### 9. E2E Test: Export Progress Real-Time Updates

**Estimated:** 4 hours **Dependencies:** Task 7, Task 8 **Description:** Test real-time progress
updates in export modal.

**Subtasks:**

1. Create `tests/e2e/epic-32.2/export-progress-updates.spec.ts`
2. Mock API to return job status updates every 2 seconds
3. Open export modal and start export
4. Verify progress bar updates from 0% → 25% → 50% → 75% → 100%
5. Verify step list updates with new steps (pending → in_progress → completed)
6. Verify completed steps show green checkmark icon
7. Verify in_progress steps show spinning loader icon
8. Verify current step text updates in real-time
9. Wait for 10 seconds and verify at least 5 polling requests made
10. Verify progress updates are smooth (no flickering or layout shifts)

### 10. E2E Test: Export Cancellation Flow

**Estimated:** 3 hours **Dependencies:** Task 9 **Description:** Test user can cancel in-progress
export job.

**Subtasks:**

1. Create `tests/e2e/epic-32.2/export-cancellation.spec.ts`
2. Start export and wait for progress to reach 25%
3. Click "Cancel Export" button
4. Verify confirmation dialog appears with warning message
5. Click "No, Continue" in confirmation dialog
6. Verify export continues (progress updates to 50%)
7. Click "Cancel Export" again
8. Click "Yes, Cancel" in confirmation dialog
9. Verify API cancelExport() called with correct job ID
10. Verify modal closes and returns to tool detail page

### 11. E2E Test: Export Success Flow

**Estimated:** 3 hours **Dependencies:** Task 9 **Description:** Test successful export completion
and success message.

**Subtasks:**

1. Create `tests/e2e/epic-32.2/export-success.spec.ts`
2. Start export and mock API to return 'completed' status after 6 seconds
3. Verify progress bar reaches 100%
4. Verify all steps marked as 'completed' with green checkmarks
5. Verify success message displays "Export completed successfully!"
6. Verify "View Export Package" button appears
7. Verify "Close" button appears
8. Click "Close" button
9. Verify modal closes and returns to tool detail page
10. Verify success toast notification appears on tool detail page

### 12. E2E Test: Export Failure Scenarios

**Estimated:** 4 hours **Dependencies:** Task 9 **Description:** Test error handling during export
process.

**Subtasks:**

1. Create `tests/e2e/epic-32.2/export-errors.spec.ts`
2. Test network error during job creation (startExport fails)
3. Verify error message displays "Failed to start export. Please try again."
4. Test network error during polling (getJobStatus fails)
5. Verify retry logic attempts 3 times before showing error
6. Test API returns 'failed' job status
7. Verify error message displays job failure reason
8. Verify failed step shows red X icon
9. Verify "Close" button enabled on error
10. Verify clicking "Close" returns to tool detail page (no further polling)

### 13. Integration Test: API Endpoint Testing

**Estimated:** 4 hours **Dependencies:** Task 1 **Description:** Test API integration with mock
backend responses.

**Subtasks:**

1. Create `apps/web/src/app/features/tools/services/export-job.service.integration.spec.ts`
2. Setup HttpClientTestingModule and mock HTTP responses
3. Test startExport() POST request to `/api/tool-registry/tools/:toolId/export`
4. Test startExport() request includes JWT token in Authorization header
5. Test getJobStatus() GET request to `/api/tool-registry/export-jobs/:jobId`
6. Test cancelExport() POST request to `/api/tool-registry/export-jobs/:jobId/cancel`
7. Test service handles 404 Not Found responses
8. Test service handles 401 Unauthorized responses
9. Test service handles 500 Internal Server Error responses
10. Test service retry logic for network timeouts

### 14. Regression Test: Epic 32.1 Functionality

**Estimated:** 3 hours **Dependencies:** Task 2 **Description:** Ensure Epic 32.2 changes don't
break Epic 32.1 features.

**Subtasks:**

1. Create `tests/e2e/epic-32.2/regression-epic-32.1.spec.ts`
2. Test tools list still displays correctly with grid layout
3. Test search input still debounces and filters tools
4. Test status dropdown still filters tools by status
5. Test date range filter still works
6. Test URL query parameters still persist filters
7. Test clicking ToolCard still navigates correctly
8. Test loading skeleton still displays on initial load
9. Test empty state still displays when no tools found
10. Verify no console errors from Epic 32.1 components

### 15. Performance and Load Testing

**Estimated:** 3 hours **Dependencies:** All previous tasks **Description:** Test performance and
responsiveness of Epic 32.2 features.

**Subtasks:**

1. Create `tests/performance/epic-32.2/performance.spec.ts`
2. Test tool detail page load time (should be < 1 second)
3. Test tab switching performance (should be < 100ms)
4. Test export modal opening performance (should be < 200ms)
5. Test polling doesn't degrade performance over 2 minutes (10+ requests)
6. Test memory usage doesn't increase during polling (no leaks)
7. Test multiple rapid tab switches don't cause errors
8. Test page responsiveness during export progress updates
9. Test network throttling (slow 3G) doesn't break functionality
10. Document performance benchmarks in story notes

### 16. Coverage Analysis and Reporting

**Estimated:** 2 hours **Dependencies:** All previous tasks **Description:** Generate and analyze
test coverage reports for Epic 32.2.

**Subtasks:**

1. Run `npm --workspace=apps/web run test:coverage -- --include="**/tools/**"`
2. Verify ToolDetailComponent has ≥90% statement coverage
3. Verify ExportProgressModalComponent has ≥90% statement coverage
4. Verify ExportJobService has ≥90% branch coverage
5. Verify ToolGuard has 100% coverage
6. Generate HTML coverage report
7. Identify uncovered code paths
8. Add tests for uncovered branches (if any)
9. Re-run coverage to confirm ≥90% threshold met
10. Document coverage results in QA gate file

### 17. Test Documentation and Cleanup

**Estimated:** 2 hours **Dependencies:** All previous tasks **Description:** Document test suite and
clean up test code.

**Subtasks:**

1. Add JSDoc comments to all test files
2. Create `tests/e2e/epic-32.2/README.md` with test suite overview
3. Document test data fixtures and mock setup
4. Document how to run specific test suites
5. Document how to run tests in debug mode
6. Add test execution commands to root README.md
7. Review test code for DRY violations (extract shared utilities)
8. Remove console.log statements from test files
9. Verify all tests pass in CI/CD pipeline
10. Update QA gate file with final test results

---

## Dev Notes

### Architecture Context

**Epic 32.2 Components:**

- `ToolDetailComponent` (apps/web/src/app/features/tools/pages/tool-detail/)
- `ExportProgressModalComponent` (apps/web/src/app/features/tools/components/export-progress-modal/)
- `ToolGuard` (apps/web/src/app/features/tools/guards/tool.guard.ts)
- `ExportJobService` (apps/web/src/app/features/tools/services/export-job.service.ts)

**Integration Points:**

1. **Routing:** ToolGuard → Router → ToolRegistryService
2. **Permissions:** ToolDetailComponent → AuthService → computed signals
3. **Export Flow:** ToolDetailComponent → ExportProgressModalComponent → ExportJobService
4. **Polling:** ExportProgressModalComponent → interval() → getJobStatus()

**Testing Philosophy:**

- **Unit tests** focus on isolated component/service logic
- **Integration tests** verify cross-boundary interactions (component + service + router)
- **E2E tests** validate complete user workflows (click button → see result)

### Test Pyramid Strategy

```
         /\
        /  \        E2E Tests (10-15 tests)
       /____\       - Full user workflows
      /      \      - Browser automation
     /        \     - Slow but comprehensive
    /__________\
   /            \   Integration Tests (20-30 tests)
  /              \  - Component + Service interactions
 /________________\ - Mock HTTP responses
/                  \ Unit Tests (50-70 tests)
                    - Component logic
                    - Service methods
                    - Computed signals
```

**Why This Matters:**

- More unit tests = faster feedback, isolated failures
- Integration tests catch boundary errors
- E2E tests ensure real user experience works

### Playwright Configuration

```typescript
// playwright.config.ts (partial)
export default defineConfig({
  testDir: './tests/e2e',
  timeout: 30000, // 30 seconds per test
  expect: {
    timeout: 5000, // 5 seconds for assertions
  },
  use: {
    baseURL: 'http://localhost:4200',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'epic-32.2',
      testMatch: /epic-32\.2\/.*\.spec\.ts/,
      use: {
        ...devices['Desktop Chrome'],
      },
    },
  ],
  webServer: {
    command: 'npm --workspace=apps/web run dev',
    port: 4200,
    reuseExistingServer: !process.env.CI,
  },
});
```

**Key Configuration:**

- `testDir`: Points to E2E test directory
- `timeout`: Max time per test (30s)
- `trace`: Records trace on first retry for debugging
- `screenshot`: Captures screenshot on failure
- `webServer`: Auto-starts Angular dev server before tests

### API Mocking with Playwright Route Interception

```typescript
// tests/e2e/helpers/api-mocks.ts
import { Page } from '@playwright/test';
import { ToolRegistryRecord } from '@nodeangularfullstack/shared';

export async function mockToolDetailAPI(page: Page, tool: ToolRegistryRecord) {
  await page.route(`**/api/tool-registry/tools/${tool.toolId}`, async (route) => {
    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify(tool),
    });
  });
}

export async function mockExportJobAPI(
  page: Page,
  jobId: string,
  statusSequence: Array<{ status: string; progress: number }>
) {
  let callCount = 0;

  await page.route(`**/api/tool-registry/export-jobs/${jobId}`, async (route) => {
    const response = statusSequence[callCount] || statusSequence[statusSequence.length - 1];
    callCount++;

    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify({
        jobId,
        status: response.status,
        stepsCompleted: response.progress,
        stepsTotal: 10,
        currentStep: `Step ${response.progress + 1}`,
      }),
    });
  });
}
```

**Why This Pattern:**

- `page.route()` intercepts network requests
- `statusSequence` simulates progressive job updates
- `callCount` tracks polling iterations
- Eliminates dependency on real backend during tests

### Jest Integration Test Pattern

```typescript
// apps/web/src/app/features/tools/pages/tool-detail/tool-detail.component.integration.spec.ts
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ActivatedRoute, Router } from '@angular/router';
import { of, throwError } from 'rxjs';
import { ToolDetailComponent } from './tool-detail.component';
import { ToolRegistryService } from '../../services/tool-registry.service';
import { AuthService } from '../../../../core/services/auth.service';

describe('ToolDetailComponent Integration Tests', () => {
  let component: ToolDetailComponent;
  let fixture: ComponentFixture<ToolDetailComponent>;
  let toolRegistryService: jest.Mocked<ToolRegistryService>;
  let authService: jest.Mocked<AuthService>;
  let router: jest.Mocked<Router>;

  beforeEach(async () => {
    const mockToolRegistryService = {
      getToolById: jest.fn(),
    };

    const mockAuthService = {
      currentUser$: of({
        userId: 'user-123',
        email: 'admin@example.com',
        role: 'admin',
        tenantId: null,
      }),
    };

    const mockRouter = {
      navigate: jest.fn(),
    };

    await TestBed.configureTestingModule({
      imports: [ToolDetailComponent], // Standalone component
      providers: [
        { provide: ToolRegistryService, useValue: mockToolRegistryService },
        { provide: AuthService, useValue: mockAuthService },
        { provide: Router, useValue: mockRouter },
        {
          provide: ActivatedRoute,
          useValue: {
            paramMap: of(new Map([['toolId', 'tool-abc-123']])),
          },
        },
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(ToolDetailComponent);
    component = fixture.componentInstance;
    toolRegistryService = TestBed.inject(ToolRegistryService) as jest.Mocked<ToolRegistryService>;
    authService = TestBed.inject(AuthService) as jest.Mocked<AuthService>;
    router = TestBed.inject(Router) as jest.Mocked<Router>;
  });

  describe('Component Initialization', () => {
    it('should load tool data on init', () => {
      const mockTool = {
        toolId: 'tool-abc-123',
        toolName: 'Test Tool',
        toolType: 'forms',
        status: 'active',
      };

      toolRegistryService.getToolById.mockReturnValue(of(mockTool));

      component.ngOnInit();

      expect(toolRegistryService.getToolById).toHaveBeenCalledWith('tool-abc-123');
      expect(component.tool()).toEqual(mockTool);
      expect(component.loading()).toBe(false);
    });

    it('should redirect to 404 if tool not found', () => {
      toolRegistryService.getToolById.mockReturnValue(
        throwError(() => new Error('Tool not found'))
      );

      component.ngOnInit();

      expect(router.navigate).toHaveBeenCalledWith(['/404']);
    });
  });

  describe('Permission Computed Signals', () => {
    it('should allow export for admin users', () => {
      const mockTool = { toolId: 'tool-abc', toolName: 'Test Tool' };
      toolRegistryService.getToolById.mockReturnValue(of(mockTool));

      component.ngOnInit();
      fixture.detectChanges();

      expect(component.canExport()).toBe(true);
      expect(component.exportButtonTooltip()).toContain('Export this tool');
    });

    it('should allow export for users with export permission', () => {
      // Change auth service to return user with export permission
      const userWithPermission = {
        userId: 'user-456',
        email: 'user@example.com',
        role: 'user',
        permissions: ['export'],
      };

      (authService.currentUser$ as any) = of(userWithPermission);

      const mockTool = { toolId: 'tool-abc', toolName: 'Test Tool' };
      toolRegistryService.getToolById.mockReturnValue(of(mockTool));

      component.ngOnInit();
      fixture.detectChanges();

      expect(component.canExport()).toBe(true);
    });

    it('should deny export for users without permission', () => {
      const userWithoutPermission = {
        userId: 'user-789',
        email: 'readonly@example.com',
        role: 'user',
        permissions: [],
      };

      (authService.currentUser$ as any) = of(userWithoutPermission);

      const mockTool = { toolId: 'tool-abc', toolName: 'Test Tool' };
      toolRegistryService.getToolById.mockReturnValue(of(mockTool));

      component.ngOnInit();
      fixture.detectChanges();

      expect(component.canExport()).toBe(false);
      expect(component.exportButtonTooltip()).toContain("don't have permission");
    });
  });
});
```

**Why This Pattern:**

- `TestBed.configureTestingModule` sets up Angular testing module
- Mocked services with `jest.fn()` for controlled responses
- `of()` and `throwError()` simulate Observable responses
- Tests integration between component and services (not just component logic)

### E2E Test Example: Full Export Flow

```typescript
// tests/e2e/epic-32.2/export-success.spec.ts
import { test, expect, Page } from '@playwright/test';
import { loginAsAdmin } from '../helpers/auth-helpers';
import { mockToolDetailAPI, mockExportJobAPI } from '../helpers/api-mocks';

test.describe('Export Success Flow', () => {
  let page: Page;

  test.beforeEach(async ({ browser }) => {
    page = await browser.newPage();
    await loginAsAdmin(page); // Navigate to /login, fill form, submit
  });

  test('should complete export successfully with progress updates', async () => {
    // Step 1: Mock tool detail API
    const mockTool = {
      toolId: 'tool-forms-123',
      toolName: 'Customer Registration Form',
      toolType: 'forms',
      status: 'active',
      manifest: { version: '1.0.0', description: 'A form tool' },
    };

    await mockToolDetailAPI(page, mockTool);

    // Step 2: Navigate to tool detail page
    await page.goto('/tools/tool-forms-123');

    // Step 3: Verify page loaded
    await expect(page.locator('h1')).toContainText('Customer Registration Form');

    // Step 4: Mock export job creation
    await page.route('**/api/tool-registry/tools/tool-forms-123/export', async (route) => {
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({ jobId: 'job-123', status: 'pending' }),
      });
    });

    // Step 5: Mock export job status polling (simulate progress)
    await mockExportJobAPI(page, 'job-123', [
      { status: 'pending', progress: 0 },
      { status: 'in_progress', progress: 2 },
      { status: 'in_progress', progress: 5 },
      { status: 'in_progress', progress: 8 },
      { status: 'completed', progress: 10 },
    ]);

    // Step 6: Click export button
    const exportButton = page.locator('button:has-text("Export Tool")');
    await expect(exportButton).toBeEnabled();
    await exportButton.click();

    // Step 7: Verify modal opened
    const modal = page.locator('p-dialog[header*="Exporting"]');
    await expect(modal).toBeVisible();

    // Step 8: Wait for initial state
    await expect(page.locator('.export-progress-modal p-progressBar')).toBeVisible();
    await expect(page.locator('.export-progress-modal .progress-text')).toContainText('0%');

    // Step 9: Wait 2 seconds for first poll
    await page.waitForTimeout(2000);
    await expect(page.locator('.export-progress-modal .progress-text')).toContainText('20%');

    // Step 10: Wait 2 more seconds for second poll
    await page.waitForTimeout(2000);
    await expect(page.locator('.export-progress-modal .progress-text')).toContainText('50%');

    // Step 11: Wait 2 more seconds for third poll
    await page.waitForTimeout(2000);
    await expect(page.locator('.export-progress-modal .progress-text')).toContainText('80%');

    // Step 12: Wait 2 more seconds for completion
    await page.waitForTimeout(2000);
    await expect(page.locator('.export-progress-modal .progress-text')).toContainText('100%');

    // Step 13: Verify success message
    await expect(page.locator('.export-success-message')).toContainText(
      'Export completed successfully!'
    );

    // Step 14: Verify "View Export Package" button appears
    const viewPackageButton = page.locator('button:has-text("View Export Package")');
    await expect(viewPackageButton).toBeVisible();

    // Step 15: Close modal
    const closeButton = page.locator('button:has-text("Close")');
    await closeButton.click();

    // Step 16: Verify returned to tool detail page
    await expect(page).toHaveURL('/tools/tool-forms-123');
    await expect(modal).not.toBeVisible();

    // Step 17: Verify success toast notification
    await expect(page.locator('.p-toast-message-success')).toContainText('Export completed');
  });

  test('should handle export failure gracefully', async () => {
    const mockTool = {
      toolId: 'tool-forms-456',
      toolName: 'Failing Tool',
      toolType: 'forms',
      status: 'active',
    };

    await mockToolDetailAPI(page, mockTool);
    await page.goto('/tools/tool-forms-456');

    // Mock export job creation success
    await page.route('**/api/tool-registry/tools/tool-forms-456/export', async (route) => {
      await route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({ jobId: 'job-456', status: 'pending' }),
      });
    });

    // Mock export job polling with failure
    await mockExportJobAPI(page, 'job-456', [
      { status: 'pending', progress: 0 },
      { status: 'in_progress', progress: 3 },
      { status: 'failed', progress: 5 }, // Fails at 50%
    ]);

    // Click export button
    await page.locator('button:has-text("Export Tool")').click();

    // Wait for modal
    await expect(page.locator('p-dialog[header*="Exporting"]')).toBeVisible();

    // Wait for failure (6 seconds: initial + 2 polls)
    await page.waitForTimeout(6000);

    // Verify error message
    await expect(page.locator('.export-error-message')).toContainText('Export failed');

    // Verify failed step shows red X icon
    await expect(page.locator('.step-icon.failed')).toBeVisible();

    // Close modal
    await page.locator('button:has-text("Close")').click();

    // Verify returned to tool detail page
    await expect(page).toHaveURL('/tools/tool-forms-456');
  });
});
```

**Why This Pattern:**

- `test.beforeEach` sets up authenticated session
- `page.route()` mocks API responses
- `page.waitForTimeout()` simulates polling intervals
- `expect().toContainText()` verifies UI updates
- Tests complete user workflow from start to finish

### Polling Test Strategy

**Challenge:** Testing time-based polling without waiting actual time.

**Solution 1: Jest Fake Timers (Unit Tests)**

```typescript
describe('ExportProgressModalComponent Polling', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  it('should poll every 2 seconds', () => {
    const jobId = 'job-123';
    component.openModal(jobId);

    expect(exportJobService.getJobStatus).toHaveBeenCalledTimes(1);

    jest.advanceTimersByTime(2000);
    expect(exportJobService.getJobStatus).toHaveBeenCalledTimes(2);

    jest.advanceTimersByTime(2000);
    expect(exportJobService.getJobStatus).toHaveBeenCalledTimes(3);
  });
});
```

**Solution 2: Playwright Mocking (E2E Tests)**

```typescript
// Mock API to return different responses based on call count
let callCount = 0;
await page.route('**/api/export-jobs/job-123', async (route) => {
  const responses = [
    { status: 'pending', progress: 0 },
    { status: 'in_progress', progress: 50 },
    { status: 'completed', progress: 100 },
  ];
  const response = responses[callCount] || responses[responses.length - 1];
  callCount++;
  await route.fulfill({ status: 200, body: JSON.stringify(response) });
});
```

**Why Both Approaches:**

- Fake timers for fast unit tests (no actual waiting)
- E2E tests verify real timing with `waitForTimeout()`

### Coverage Analysis Commands

```bash
# Run coverage for Epic 32.2 components
npm --workspace=apps/web run test:coverage -- --include="**/tools/**"

# Generate HTML coverage report
npm --workspace=apps/web run test:coverage -- --include="**/tools/**" --coverage-reporter=html

# View coverage report
open apps/web/coverage/index.html

# Check coverage thresholds
npm --workspace=apps/web run test:coverage -- --include="**/tools/**" --coverageThreshold='{"global":{"statements":90,"branches":90,"functions":90,"lines":90}}'
```

**Coverage Targets:**

- ToolDetailComponent: ≥90% statements
- ExportProgressModalComponent: ≥90% statements
- ExportJobService: ≥90% branches
- ToolGuard: 100% (critical path)

### Test Execution Commands

```bash
# Run all Epic 32.2 E2E tests
npm run test:e2e -- tests/e2e/epic-32.2/

# Run specific E2E test file
npm run test:e2e -- tests/e2e/epic-32.2/export-success.spec.ts

# Run E2E tests with UI mode (interactive)
npm run test:e2e:ui

# Run Epic 32.2 integration tests
npm --workspace=apps/web run test -- --testPathPattern="epic-32.2" --watch=false

# Run all tests (unit + integration + E2E)
npm test
```

### CI/CD Integration

```yaml
# .github/workflows/test-epic-32.2.yml
name: Epic 32.2 Test Suite

on:
  push:
    paths:
      - 'apps/web/src/app/features/tools/**'
      - 'tests/e2e/epic-32.2/**'
  pull_request:
    branches: [main, develop]

jobs:
  test-epic-32-2:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Build shared package
        run: npm run build:shared

      - name: Run unit tests
        run: npm --workspace=apps/web run test -- --testPathPattern="tools" --watch=false

      - name: Run integration tests
        run: npm --workspace=apps/web run test -- --testPathPattern="epic-32.2" --watch=false

      - name: Install Playwright browsers
        run: npx playwright install --with-deps

      - name: Run E2E tests
        run: npm run test:e2e -- tests/e2e/epic-32.2/

      - name: Generate coverage report
        run: npm --workspace=apps/web run test:coverage -- --include="**/tools/**"

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./apps/web/coverage/lcov.info
          flags: epic-32.2

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/
```

**Why This Matters:**

- Automated testing on every push/PR
- Catches regressions before merge
- Coverage reports uploaded to Codecov
- Playwright reports available as artifacts

### Common Testing Pitfalls

**Pitfall 1: Not Cleaning Up Intervals**

```typescript
// ❌ BAD: Memory leak
ngOnInit() {
  setInterval(() => this.pollJobStatus(), 2000);
}

// ✅ GOOD: Cleanup on destroy
private pollingInterval: any;

ngOnInit() {
  this.pollingInterval = setInterval(() => this.pollJobStatus(), 2000);
}

ngOnDestroy() {
  if (this.pollingInterval) {
    clearInterval(this.pollingInterval);
  }
}
```

**Pitfall 2: Not Unsubscribing from Observables**

```typescript
// ❌ BAD: Subscription leak
ngOnInit() {
  this.service.getData().subscribe(data => this.data.set(data));
}

// ✅ GOOD: Unsubscribe with takeUntil
private destroy$ = new Subject<void>();

ngOnInit() {
  this.service.getData()
    .pipe(takeUntil(this.destroy$))
    .subscribe(data => this.data.set(data));
}

ngOnDestroy() {
  this.destroy$.next();
  this.destroy$.complete();
}
```

**Pitfall 3: Testing Implementation Instead of Behavior**

```typescript
// ❌ BAD: Testing internal method calls
it('should call startPolling on init', () => {
  spyOn(component, 'startPolling');
  component.ngOnInit();
  expect(component['startPolling']).toHaveBeenCalled();
});

// ✅ GOOD: Testing observable behavior
it('should update progress when job status changes', () => {
  const mockJob = { status: 'in_progress', stepsCompleted: 5, stepsTotal: 10 };
  service.getJobStatus.mockReturnValue(of(mockJob));

  component.ngOnInit();

  expect(component.exportJob()).toEqual(mockJob);
  expect(component.progress()).toBe(50);
});
```

### Test Debugging Tips

**Tip 1: Use Playwright Trace Viewer**

```bash
# Run test with trace
npm run test:e2e -- tests/e2e/epic-32.2/export-success.spec.ts --trace on

# Open trace viewer
npx playwright show-trace trace.zip
```

**Tip 2: Use Jest Debugging**

```json
// .vscode/launch.json
{
  "type": "node",
  "request": "launch",
  "name": "Jest Debug",
  "program": "${workspaceFolder}/node_modules/.bin/jest",
  "args": ["--runInBand", "--testPathPattern=tool-detail.component.integration.spec.ts"],
  "console": "integratedTerminal",
  "internalConsoleOptions": "neverOpen"
}
```

**Tip 3: Add Breakpoints in Test Code**

```typescript
it('should update progress', async () => {
  component.ngOnInit();

  // Add debugger statement
  debugger;

  expect(component.progress()).toBe(50);
});
```

---

## Testing

### Manual Test Script

```bash
#!/bin/bash
# tests/manual/epic-32.2-integration-test.sh

echo "=== Epic 32.2 Integration Test Suite ==="
echo

echo "Step 1: Start development environment"
./start-dev.sh
sleep 5

echo "Step 2: Run unit tests for Epic 32.2 components"
npm --workspace=apps/web run test -- --testPathPattern="tools" --watch=false
UNIT_EXIT_CODE=$?

echo "Step 3: Run integration tests"
npm --workspace=apps/web run test -- --testPathPattern="epic-32.2" --watch=false
INTEGRATION_EXIT_CODE=$?

echo "Step 4: Run E2E tests for Epic 32.2"
npm run test:e2e -- tests/e2e/epic-32.2/ --reporter=list
E2E_EXIT_CODE=$?

echo "Step 5: Generate coverage report"
npm --workspace=apps/web run test:coverage -- --include="**/tools/**"
COVERAGE_EXIT_CODE=$?

echo
echo "=== Test Results Summary ==="
echo "Unit Tests: $([ $UNIT_EXIT_CODE -eq 0 ] && echo 'PASSED' || echo 'FAILED')"
echo "Integration Tests: $([ $INTEGRATION_EXIT_CODE -eq 0 ] && echo 'PASSED' || echo 'FAILED')"
echo "E2E Tests: $([ $E2E_EXIT_CODE -eq 0 ] && echo 'PASSED' || echo 'FAILED')"
echo "Coverage: $([ $COVERAGE_EXIT_CODE -eq 0 ] && echo 'PASSED' || echo 'FAILED')"

# Exit with error if any test suite failed
if [ $UNIT_EXIT_CODE -ne 0 ] || [ $INTEGRATION_EXIT_CODE -ne 0 ] || [ $E2E_EXIT_CODE -ne 0 ] || [ $COVERAGE_EXIT_CODE -ne 0 ]; then
  echo
  echo "❌ Some tests failed. See above for details."
  exit 1
fi

echo
echo "✅ All tests passed successfully!"
exit 0
```

### Test Execution Checklist

**Pre-Test Setup:**

- [ ] Start PostgreSQL (`brew services start postgresql@14`)
- [ ] Start development environment (`./start-dev.sh`)
- [ ] Verify backend API accessible at http://localhost:3000
- [ ] Verify frontend accessible at http://localhost:4200
- [ ] Seed database with test data (`npm --workspace=apps/api run db:seed`)

**Unit Test Execution:**

- [ ] Run all Epic 32.2 unit tests
- [ ] Verify ToolDetailComponent tests pass
- [ ] Verify ExportProgressModalComponent tests pass
- [ ] Verify ExportJobService tests pass
- [ ] Verify ToolGuard tests pass

**Integration Test Execution:**

- [ ] Run all Epic 32.2 integration tests
- [ ] Verify component-service integration tests pass
- [ ] Verify route guard integration tests pass
- [ ] Verify API integration tests pass

**E2E Test Execution:**

- [ ] Run navigation E2E tests
- [ ] Run tool detail interactions E2E tests
- [ ] Run export permissions E2E tests
- [ ] Run export modal E2E tests
- [ ] Run export success flow E2E tests
- [ ] Run export cancellation E2E tests
- [ ] Run export failure scenarios E2E tests
- [ ] Run regression tests for Epic 32.1

**Coverage Validation:**

- [ ] Generate coverage report for Epic 32.2
- [ ] Verify ≥90% statement coverage
- [ ] Verify ≥90% branch coverage
- [ ] Verify ≥90% function coverage
- [ ] Verify ≥90% line coverage
- [ ] Review uncovered code paths
- [ ] Add tests for critical uncovered paths

**Post-Test Validation:**

- [ ] Review test output for warnings
- [ ] Check for console errors in E2E tests
- [ ] Verify no memory leaks (polling cleanup)
- [ ] Verify no flaky tests (run multiple times)
- [ ] Document any known issues or limitations

---

## Dependencies

### Blocked By:

- Story 32.2.1: Dynamic Route Configuration (ToolGuard implementation)
- Story 32.2.2: Tool Detail Pages (ToolDetailComponent)
- Story 32.2.3: Export Button & Permission Checks (canExport logic)
- Story 32.2.4: Export Progress Modal (ExportProgressModalComponent)

### Blocks:

- Epic 33.1: Export Core Infrastructure (backend export implementation)
- Story 33.1.4: Integration Tests for Epic 33.1

### Related:

- Story 32.1.3: ToolsList Component Grid (regression testing)
- Story 32.1.4: Search and Filtering UI (regression testing)

---

## QA Gate

**Gate File:** `docs/qa/gates/32.2.5-integration-tests-epic-32.2.yml`

### Quality Criteria (Weighted):

| Criterion                 | Weight | Target                         | Validation Method       |
| ------------------------- | ------ | ------------------------------ | ----------------------- |
| Unit Test Coverage        | 20%    | ≥90% statements/branches       | Jest coverage report    |
| Integration Test Coverage | 20%    | ≥85% cross-component flows     | Manual review           |
| E2E Test Coverage         | 25%    | 100% critical user paths       | Playwright test results |
| Regression Tests          | 10%    | All Epic 32.1 tests pass       | Test execution          |
| API Integration Tests     | 10%    | All endpoints tested           | HttpClientTestingModule |
| Performance Tests         | 5%     | Page load < 1s, polling stable | Performance suite       |
| Test Documentation        | 5%     | All tests have JSDoc           | Code review             |
| CI/CD Integration         | 5%     | Tests pass in pipeline         | GitHub Actions          |

**Minimum Score:** 90/100 to pass gate

### Validation Checklist:

**Code Quality:**

- [ ] All test files follow naming conventions (`*.spec.ts`, `*.integration.spec.ts`)
- [ ] All tests have descriptive `describe()` and `it()` blocks
- [ ] No `console.log()` or `debugger` statements in test code
- [ ] Test code follows DRY principles (shared utilities extracted)
- [ ] All tests pass linting (`npm run lint`)

**Test Coverage:**

- [ ] Unit tests achieve ≥90% statement coverage
- [ ] Unit tests achieve ≥90% branch coverage
- [ ] Integration tests cover all cross-component interactions
- [ ] E2E tests cover all critical user workflows
- [ ] Regression tests cover Epic 32.1 functionality

**Test Quality:**

- [ ] Tests verify behavior, not implementation details
- [ ] Tests use meaningful assertions (`expect()` statements)
- [ ] Tests clean up resources (intervals, subscriptions, timers)
- [ ] Tests handle async operations correctly (fakeAsync, waitForAsync)
- [ ] Tests are isolated (no shared state between tests)

**Documentation:**

- [ ] Test suite README created with overview
- [ ] Test execution commands documented
- [ ] Test debugging instructions provided
- [ ] Test fixtures and mocks documented
- [ ] Coverage results documented in QA gate file

**CI/CD:**

- [ ] Tests run automatically on push/PR
- [ ] Tests pass in GitHub Actions pipeline
- [ ] Coverage reports uploaded to Codecov
- [ ] Playwright reports available as artifacts
- [ ] Build fails if coverage < 90%

---

## Notes

### ★ Insight ─────────────────────────────────────

**Test Pyramid Philosophy:**

- **70% Unit Tests:** Fast, isolated, focused on individual functions
- **20% Integration Tests:** Verify cross-boundary interactions
- **10% E2E Tests:** Slow but comprehensive, real browser automation

**Polling Test Strategy:**

- Jest fake timers for unit tests (instant execution)
- Playwright mocking for E2E tests (verifies real timing)
- Both approaches essential for comprehensive coverage

**Why Integration Tests Matter:**

- Unit tests can pass but integration fails (mismatched interfaces)
- Integration tests catch boundary errors (service contracts)
- E2E tests catch UX issues (but are slow and brittle)

─────────────────────────────────────────────────

### Epic 32.2 Integration Test Scope

This story validates **all 5 Epic 32.2 stories** working together:

1. **32.2.1 Dynamic Routing:** ToolGuard validates toolId and prevents navigation to invalid tools
2. **32.2.2 Tool Detail Pages:** Tabbed interface displays tool information correctly
3. **32.2.3 Export Permissions:** Admin and users with 'export' permission see enabled button
4. **32.2.4 Export Progress:** Modal polls for job status and displays real-time updates
5. **32.2.5 Integration Tests (this story):** Validates all above working together end-to-end

### Test Data Management

**Fixtures Location:**

- `tests/e2e/fixtures/tool-fixtures.ts` - Mock tool data
- `tests/e2e/fixtures/export-job-fixtures.ts` - Mock export job data
- `tests/e2e/fixtures/user-fixtures.ts` - Mock user accounts

**Fixture Best Practices:**

- Use TypeScript interfaces from `@nodeangularfullstack/shared`
- Create reusable fixture functions (e.g., `createMockTool()`)
- Include edge cases (empty fields, null values, long strings)
- Version fixtures for backward compatibility testing

### Performance Benchmarks

**Target Metrics:**

- Tool detail page load: < 1 second
- Tab switching: < 100ms
- Export modal opening: < 200ms
- Polling overhead: < 50ms per request
- Memory usage during 2-minute polling: < 10MB increase

### Known Limitations

1. **Polling in E2E Tests:** Actual 2-second waits required, tests take longer
2. **Browser Differences:** Playwright tests run on Chromium by default (add Firefox/WebKit if
   needed)
3. **CI/CD Environment:** May need headless mode adjustments for GitHub Actions
4. **Coverage Gaps:** Some error paths hard to test (e.g., browser clipboard API)

### Future Enhancements

**Epic 33 Integration:**

- Add backend integration tests when export orchestrator implemented
- Add real export package generation tests
- Add multi-service export tests (forms, workflows, etc.)

**Additional Test Coverage:**

- Add accessibility tests with axe-core
- Add visual regression tests with Percy or Chromatic
- Add load tests (100+ concurrent exports)
- Add security tests (XSS, CSRF, unauthorized access)

---

**Story State:** Draft **Last Updated:** 2025-10-24 **Next Review:** After implementation completion
