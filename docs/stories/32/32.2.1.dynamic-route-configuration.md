# Story 32.2.1: Dynamic Route Configuration

**Epic:** 32.2 - Dynamic Routing & Export UI **Story Points:** 5 **Priority:** P1 **Assignee:**
Frontend Developer **Status:** Done

---

## Description

Implement dynamic route configuration that loads tool routes from the Tool Registry at runtime. Each
registered tool gets its own route (`/tools/:toolId`) with lazy-loaded components and route guards
to verify tool existence. Enables plugin-like architecture where tools can be added without
modifying routing configuration.

**Context:**

- Epic 32.1 implemented UI components for tool discovery
- This story enables navigation to individual tool detail pages
- Routes are generated dynamically based on registered tools
- Uses Angular's functional routing with lazy loading
- ToolGuard prevents navigation to non-existent tools

---

## Acceptance Criteria

**AC1: Dynamic Route Generation**

- ✅ Routes loaded from Tool Registry at app initialization
- ✅ Each tool gets route pattern: `/tools/:toolId`
- ✅ Routes use lazy loading with `loadComponent`
- ✅ Routes configured in `app.routes.ts`
- ✅ Tool routes nested under `/tools` prefix

**AC2: Route Guard Implementation**

- ✅ `ToolGuard` created at `apps/web/src/app/core/guards/tool.guard.ts`
- ✅ Guard implements `CanActivateFn` functional guard
- ✅ Verifies tool exists in registry before activation
- ✅ Redirects to 404 page if tool not found
- ✅ Loads tool data and stores in resolver

**AC3: Route Parameters**

- ✅ `toolId` extracted from route params
- ✅ Tool data resolved before component loads
- ✅ Tool data available via `ActivatedRoute.data`
- ✅ Type-safe parameter extraction
- ✅ Handles invalid toolId gracefully

**AC4: Lazy Loading**

- ✅ Tool components loaded on-demand using `loadComponent`
- ✅ Tool detail component code-split from main bundle
- ✅ Loading indicator shown during lazy load
- ✅ Error handling for failed lazy loads
- ✅ Chunk names configured for debugging

**AC5: Navigation Integration**

- ✅ Navigate from tools list to tool detail: `router.navigate(['/tools', toolId])`
- ✅ Breadcrumbs show tool hierarchy (Home > Tools > [Tool Name])
- ✅ Back navigation preserves filters/search state
- ✅ Direct URL access works (e.g., `/tools/form-builder`)
- ✅ Invalid URLs redirect to 404

**AC6: Route Configuration Structure**

- ✅ Main routes in `app.routes.ts`
- ✅ Tool routes dynamically added at runtime
- ✅ Default route (`''`) redirects to `/tools`
- ✅ Wildcard route (`**`) shows 404 component
- ✅ Route configuration type-safe

**AC7: Route Testing**

- ✅ Unit tests for ToolGuard with ≥85% coverage
- ✅ Test: guard allows access for existing tool
- ✅ Test: guard denies access for non-existent tool
- ✅ Test: guard redirects to 404 on denial
- ✅ Integration test: navigate to tool route
- ✅ Test: lazy loading triggers correctly

---

## Tasks

### Task 1: Route Guard Implementation

**Subtasks:**

1. Create `apps/web/src/app/core/guards/tool.guard.ts`
2. Implement `CanActivateFn` functional guard
3. Inject ToolRegistryService and Router
4. Extract `toolId` from route params
5. Call `toolRegistryService.getToolById(toolId)`
6. Return true if tool exists
7. Return false and redirect to 404 if not found
8. Handle async Observable with `map()` and `catchError()`
9. Add JSDoc documentation
10. Export guard from core barrel exports

### Task 2: Route Resolver (Optional)

**Subtasks:**

1. Create `apps/web/src/app/core/resolvers/tool.resolver.ts`
2. Implement `ResolveFn<ToolRegistryRecord>`
3. Extract `toolId` from route params
4. Fetch tool data from service
5. Return resolved tool data
6. Cache resolved data to avoid duplicate fetches
7. Handle resolver errors
8. Add JSDoc documentation
9. Integrate resolver with route config
10. Export resolver from core barrel exports

### Task 3: Dynamic Route Configuration

**Subtasks:**

1. Update `apps/web/src/app/app.routes.ts`
2. Define base routes (home, tools list, auth)
3. Add dynamic tool route: `{ path: 'tools/:toolId', canActivate: [ToolGuard], ... }`
4. Use `loadComponent` for lazy loading
5. Configure route data: `{ title: 'Tool Detail' }`
6. Add breadcrumb configuration (optional)
7. Add 404 wildcard route
8. Test route navigation
9. Verify lazy loading in Network tab
10. Document route structure

### Task 4: Tool Detail Component Stub

**Subtasks:**

1. Create `apps/web/src/app/features/tools/pages/tool-detail/`
2. Create `tool-detail.component.ts` stub
3. Create `tool-detail.component.html` template
4. Create `tool-detail.component.scss` styles
5. Inject ActivatedRoute to access route params
6. Extract `toolId` from route params
7. Fetch tool data from route resolver or service
8. Display tool name and description
9. Add "Back to Tools" button
10. Test component loads on navigation

### Task 5: ToolGuard Logic Implementation

**Subtasks:**

1. Import ToolRegistryService, Router, ActivatedRouteSnapshot
2. Create guard function: `export const toolGuard: CanActivateFn = (route) => { ... }`
3. Extract toolId: `const toolId = route.paramMap.get('toolId')`
4. Validate toolId is non-empty
5. Call `toolRegistryService.getToolById(toolId)`
6. Return Observable<boolean>
7. Map success to `true`
8. Catch 404 errors and return `false`
9. Redirect to `/404` on false
10. Log guard decisions for debugging

### Task 6: Error Handling

**Subtasks:**

1. Handle non-existent tool IDs (404)
2. Handle network errors during tool fetch
3. Handle malformed route parameters
4. Create custom 404 component for tools
5. Add error message: "Tool not found"
6. Provide link to tools list
7. Test error scenarios
8. Log errors to console
9. Show user-friendly error messages
10. Verify error handling in guard tests

### Task 7: Navigation Utilities

**Subtasks:**

1. Create `navigateToTool(toolId: string)` helper method
2. Add to ToolRegistryService or separate utility
3. Use Router to navigate: `router.navigate(['/tools', toolId])`
4. Return navigation promise
5. Handle navigation errors
6. Add JSDoc with examples
7. Use helper in ToolsListComponent
8. Test navigation helper
9. Support query params (optional)
10. Support fragment (optional)

### Task 8: Breadcrumb Integration (Optional)

**Subtasks:**

1. Install/configure breadcrumb library (PrimeNG Breadcrumb)
2. Define breadcrumb structure in route data
3. Create breadcrumb service (if needed)
4. Render breadcrumbs in app shell
5. Update breadcrumbs on route change
6. Show: Home > Tools > [Tool Name]
7. Make breadcrumb items clickable
8. Style breadcrumbs
9. Test breadcrumb navigation
10. Add ARIA labels for accessibility

### Task 9: Route Configuration Testing

**Subtasks:**

1. Create `apps/web/src/app/app.routes.spec.ts`
2. Test default route redirects to `/tools`
3. Test wildcard route shows 404
4. Test tool route registered: `/tools/:toolId`
5. Test tool route uses ToolGuard
6. Test lazy loading configuration
7. Mock ToolRegistryService in tests
8. Test route parameter extraction
9. Verify route data configuration
10. Run all route tests

### Task 10: ToolGuard Unit Tests

**Subtasks:**

1. Create `tool.guard.spec.ts`
2. Setup TestBed with mocked services
3. Write test: "should allow access for existing tool"
4. Mock `getToolById()` to return tool
5. Verify guard returns `true`
6. Write test: "should deny access for non-existent tool"
7. Mock `getToolById()` to throw 404 error
8. Verify guard returns `false`
9. Verify router.navigate called with ['/404']
10. Write test: "should handle invalid toolId"
11. Test with empty/null toolId
12. Run coverage report (target ≥85%)

### Task 11: Integration Testing

**Subtasks:**

1. Create E2E test: "navigate to tool detail page"
2. Start from tools list page
3. Click on tool card
4. Verify URL changes to `/tools/:toolId`
5. Verify tool detail component loads
6. Test direct URL access: `/tools/form-builder`
7. Verify guard prevents access to invalid tool
8. Test back navigation
9. Verify lazy loading in Network tab
10. Test navigation performance

### Task 12: Documentation

**Subtasks:**

1. Document dynamic routing architecture
2. Add JSDoc to ToolGuard
3. Add examples to README
4. Document how to add new tool routes
5. Explain lazy loading benefits
6. Document route guard behavior
7. Add troubleshooting guide
8. Create routing diagram (optional)
9. Link to Angular routing docs
10. Document breadcrumb configuration

---

## Dev Notes

### ToolGuard Implementation

**TypeScript (tool.guard.ts):**

````typescript
import { inject } from '@angular/core';
import { CanActivateFn, Router, ActivatedRouteSnapshot } from '@angular/router';
import { map, catchError } from 'rxjs/operators';
import { of } from 'rxjs';
import { ToolRegistryService } from '../services/tool-registry.service';

/**
 * Route guard that verifies a tool exists before allowing navigation.
 *
 * Prevents navigation to non-existent tool detail pages and redirects
 * to 404 page if tool is not found in the registry.
 *
 * @example
 * ```typescript
 * const routes: Routes = [
 *   {
 *     path: 'tools/:toolId',
 *     canActivate: [toolGuard],
 *     loadComponent: () => import('./tool-detail.component').then(m => m.ToolDetailComponent)
 *   }
 * ];
 * ```
 */
export const toolGuard: CanActivateFn = (route: ActivatedRouteSnapshot) => {
  const toolRegistryService = inject(ToolRegistryService);
  const router = inject(Router);

  const toolId = route.paramMap.get('toolId');

  if (!toolId) {
    console.error('[ToolGuard] No toolId in route params');
    router.navigate(['/404']);
    return of(false);
  }

  console.log(`[ToolGuard] Checking access for tool: ${toolId}`);

  return toolRegistryService.getToolById(toolId).pipe(
    map((tool) => {
      if (tool) {
        console.log(`[ToolGuard] Access granted for tool: ${toolId}`);
        return true;
      } else {
        console.warn(`[ToolGuard] Tool not found: ${toolId}`);
        router.navigate(['/404']);
        return false;
      }
    }),
    catchError((error) => {
      console.error(`[ToolGuard] Error checking tool: ${toolId}`, error);
      router.navigate(['/404']);
      return of(false);
    })
  );
};
````

### Dynamic Route Configuration

**TypeScript (app.routes.ts):**

```typescript
import { Routes } from '@angular/router';
import { toolGuard } from './core/guards/tool.guard';

export const routes: Routes = [
  // Default route
  {
    path: '',
    redirectTo: '/tools',
    pathMatch: 'full',
  },

  // Tools list page
  {
    path: 'tools',
    loadComponent: () =>
      import('./features/tools/components/tools-list/tools-list.component').then(
        (m) => m.ToolsListComponent
      ),
    data: { title: 'Tools', breadcrumb: 'Tools' },
  },

  // Dynamic tool detail page
  {
    path: 'tools/:toolId',
    canActivate: [toolGuard],
    loadComponent: () =>
      import('./features/tools/pages/tool-detail/tool-detail.component').then(
        (m) => m.ToolDetailComponent
      ),
    data: { title: 'Tool Detail', breadcrumb: 'Detail' },
  },

  // Auth routes
  {
    path: 'auth',
    loadChildren: () => import('./features/auth/auth.routes').then((m) => m.authRoutes),
  },

  // Admin routes
  {
    path: 'admin',
    loadChildren: () => import('./features/admin/admin.routes').then((m) => m.adminRoutes),
  },

  // 404 Not Found
  {
    path: '404',
    loadComponent: () =>
      import('./shared/components/not-found/not-found.component').then((m) => m.NotFoundComponent),
    data: { title: 'Not Found' },
  },

  // Wildcard route (must be last)
  {
    path: '**',
    redirectTo: '/404',
  },
];
```

### Tool Detail Component Stub

**TypeScript (tool-detail.component.ts):**

```typescript
import { Component, OnInit, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { ButtonModule } from 'primeng/button';
import { CardModule } from 'primeng/card';
import { ToolRegistryService } from '@app/core/services/tool-registry.service';
import { ToolRegistryRecord } from '@nodeangularfullstack/shared';

/**
 * Displays detailed information about a single tool.
 *
 * @example
 * Route: /tools/:toolId
 * Example URL: /tools/form-builder
 */
@Component({
  selector: 'app-tool-detail',
  standalone: true,
  imports: [CommonModule, ButtonModule, CardModule],
  templateUrl: './tool-detail.component.html',
  styleUrl: './tool-detail.component.scss',
})
export class ToolDetailComponent implements OnInit {
  tool = signal<ToolRegistryRecord | null>(null);
  loading = signal<boolean>(true);
  error = signal<string | null>(null);

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private toolRegistryService: ToolRegistryService
  ) {}

  ngOnInit(): void {
    this.loadTool();
  }

  private loadTool(): void {
    const toolId = this.route.snapshot.paramMap.get('toolId');

    if (!toolId) {
      this.error.set('Invalid tool ID');
      this.loading.set(false);
      return;
    }

    this.loading.set(true);

    this.toolRegistryService.getToolById(toolId).subscribe({
      next: (tool) => {
        this.tool.set(tool);
        this.loading.set(false);
      },
      error: (err) => {
        this.error.set(err.message || 'Failed to load tool');
        this.loading.set(false);
      },
    });
  }

  goBack(): void {
    this.router.navigate(['/tools']);
  }
}
```

**Template (tool-detail.component.html):**

```html
<div class="tool-detail-container">
  <!-- Loading State -->
  <p-card *ngIf="loading()">
    <div class="loading-state">
      <i class="pi pi-spin pi-spinner"></i>
      <span>Loading tool details...</span>
    </div>
  </p-card>

  <!-- Error State -->
  <p-card *ngIf="error() && !loading()">
    <div class="error-state">
      <i class="pi pi-exclamation-triangle error-icon"></i>
      <h3>Error Loading Tool</h3>
      <p>{{ error() }}</p>
      <p-button label="Back to Tools" icon="pi pi-arrow-left" (onClick)="goBack()"></p-button>
    </div>
  </p-card>

  <!-- Tool Content -->
  <div *ngIf="tool() && !loading()" class="tool-content">
    <!-- Header -->
    <div class="tool-header">
      <p-button
        icon="pi pi-arrow-left"
        [text]="true"
        (onClick)="goBack()"
        label="Back to Tools"
        class="back-button"
      ></p-button>
    </div>

    <!-- Tool Info Card -->
    <p-card>
      <ng-template pTemplate="header">
        <div class="card-header">
          <i [class]="'pi ' + (tool()!.icon || 'pi-box')" class="tool-icon"></i>
          <div>
            <h2>{{ tool()!.name }}</h2>
            <p class="tool-id">ID: {{ tool()!.toolId }}</p>
          </div>
        </div>
      </ng-template>

      <div class="tool-details">
        <div class="detail-row">
          <strong>Description:</strong>
          <p>{{ tool()!.description || 'No description provided' }}</p>
        </div>

        <div class="detail-row">
          <strong>Version:</strong>
          <p>{{ tool()!.version }}</p>
        </div>

        <div class="detail-row">
          <strong>Status:</strong>
          <p-badge
            [value]="tool()!.status"
            [severity]="getStatusSeverity(tool()!.status)"
          ></p-badge>
        </div>

        <div class="detail-row">
          <strong>Route:</strong>
          <p>{{ tool()!.route }}</p>
        </div>

        <div class="detail-row">
          <strong>API Base:</strong>
          <p>{{ tool()!.apiBase }}</p>
        </div>

        <div class="detail-row">
          <strong>Permissions:</strong>
          <div class="permissions-list">
            <span *ngFor="let permission of tool()!.permissions" class="permission-chip">
              {{ permission }}
            </span>
          </div>
        </div>
      </div>

      <ng-template pTemplate="footer">
        <div class="card-footer">
          <p-button
            label="Export Tool"
            icon="pi pi-download"
            severity="primary"
            [disabled]="true"
          ></p-button>
          <p-button
            label="Edit Tool"
            icon="pi pi-pencil"
            severity="secondary"
            [disabled]="true"
          ></p-button>
        </div>
      </ng-template>
    </p-card>
  </div>
</div>
```

### ToolGuard Unit Tests

```typescript
// tool.guard.spec.ts
import { TestBed } from '@angular/core/testing';
import { Router, ActivatedRouteSnapshot } from '@angular/router';
import { of, throwError } from 'rxjs';
import { toolGuard } from './tool.guard';
import { ToolRegistryService } from '../services/tool-registry.service';
import { ToolRegistryRecord } from '@nodeangularfullstack/shared';

describe('toolGuard', () => {
  let mockToolRegistryService: jasmine.SpyObj<ToolRegistryService>;
  let mockRouter: jasmine.SpyObj<Router>;
  let mockRoute: ActivatedRouteSnapshot;

  const mockTool: ToolRegistryRecord = {
    id: '1',
    toolId: 'form-builder',
    name: 'Form Builder',
    description: 'Build forms',
    version: '1.0.0',
    icon: 'pi-box',
    route: '/tools/form-builder',
    apiBase: '/api/form-builder',
    permissions: ['read', 'write'],
    status: 'registered',
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  beforeEach(() => {
    mockToolRegistryService = jasmine.createSpyObj('ToolRegistryService', ['getToolById']);
    mockRouter = jasmine.createSpyObj('Router', ['navigate']);

    mockRoute = {
      paramMap: {
        get: (key: string) => (key === 'toolId' ? 'form-builder' : null),
      },
    } as any;

    TestBed.configureTestingModule({
      providers: [
        { provide: ToolRegistryService, useValue: mockToolRegistryService },
        { provide: Router, useValue: mockRouter },
      ],
    });
  });

  it('should allow access for existing tool', (done) => {
    mockToolRegistryService.getToolById.and.returnValue(of(mockTool));

    TestBed.runInInjectionContext(() => {
      const result = toolGuard(mockRoute, {} as any);

      if (result instanceof Observable) {
        result.subscribe((allowed) => {
          expect(allowed).toBe(true);
          expect(mockRouter.navigate).not.toHaveBeenCalled();
          done();
        });
      }
    });
  });

  it('should deny access for non-existent tool', (done) => {
    mockToolRegistryService.getToolById.and.returnValue(
      throwError(() => ({ status: 404, message: 'Tool not found' }))
    );

    TestBed.runInInjectionContext(() => {
      const result = toolGuard(mockRoute, {} as any);

      if (result instanceof Observable) {
        result.subscribe((allowed) => {
          expect(allowed).toBe(false);
          expect(mockRouter.navigate).toHaveBeenCalledWith(['/404']);
          done();
        });
      }
    });
  });

  it('should handle invalid toolId', (done) => {
    mockRoute.paramMap.get = () => null; // No toolId

    TestBed.runInInjectionContext(() => {
      const result = toolGuard(mockRoute, {} as any);

      if (result instanceof Observable) {
        result.subscribe((allowed) => {
          expect(allowed).toBe(false);
          expect(mockRouter.navigate).toHaveBeenCalledWith(['/404']);
          done();
        });
      }
    });
  });
});
```

---

## Testing

### Manual Testing

**Test 1: Navigate to Tool Detail**

```bash
# 1. Navigate to http://localhost:4200/tools
# 2. Click on a tool card (e.g., "Form Builder")
# Expected: URL changes to /tools/form-builder
# Expected: Tool detail page loads showing tool information
```

**Test 2: Direct URL Access**

```bash
# 1. Navigate directly to http://localhost:4200/tools/form-builder
# Expected: Tool detail page loads
# Expected: No errors in console
```

**Test 3: Invalid Tool ID**

```bash
# 1. Navigate to http://localhost:4200/tools/nonexistent-tool
# Expected: Redirect to 404 page
# Expected: "Tool not found" message displayed
```

**Test 4: Lazy Loading**

```bash
# 1. Open Network tab in DevTools
# 2. Navigate to http://localhost:4200/tools
# 3. Click on a tool card
# Expected: New JS chunk loaded for tool detail component
# Expected: Chunk name visible in Network tab
```

**Test 5: Back Navigation**

```bash
# 1. Navigate to tool detail page
# 2. Click "Back to Tools" button
# Expected: Return to tools list
# Expected: Search/filter state preserved (if applicable)
```

### Automated Testing

```bash
# Run guard tests
npm --workspace=apps/web run test -- --include="**/tool.guard.spec.ts" --watch=false

# Expected output:
# PASS src/app/core/guards/tool.guard.spec.ts
#   toolGuard
#     ✓ should allow access for existing tool (35ms)
#     ✓ should deny access for non-existent tool (30ms)
#     ✓ should handle invalid toolId (25ms)
#
# Tests: 3 passed, 3 total
# Coverage: Statements 90%, Branches 88%, Functions 85%, Lines 90%
```

---

## Dependencies

**Depends On:**

- Story 32.1.2: Tool Registry Service (getToolById method)
- Story 32.1.3: ToolsList Component (navigation source)

**Blocks:**

- Story 32.2.2: Tool Detail Pages (route configuration required)
- Story 32.2.3: Export Button & Permission Checks (needs tool detail page)

**Related Stories:**

- None

---

## QA Gate

**Quality Score Target:** ≥90/100

| Criterion              | Weight | Target                  |
| ---------------------- | ------ | ----------------------- |
| Unit test coverage     | 20%    | ≥85%                    |
| All tests passing      | 15%    | 100%                    |
| Guard logic functional | 20%    | Verified manually       |
| Lazy loading works     | 15%    | Verified in Network tab |
| Navigation works       | 15%    | All routes navigable    |
| Error handling         | 10%    | 404 redirects work      |
| Code quality           | 5%     | No ESLint errors        |

**Exit Criteria:**

- All unit tests pass with ≥85% coverage
- ToolGuard allows access to existing tools
- ToolGuard denies access to non-existent tools
- Invalid toolId redirects to 404 page
- Lazy loading verified in Network tab
- Direct URL access works
- Back navigation functional
- Route configuration documented

---

## Notes

- Dynamic routing enables plugin-like architecture for tools
- ToolGuard prevents navigation to non-existent tools
- Lazy loading improves initial bundle size
- Route guards are functional (not class-based) for Angular 16+
- Tool detail component is stub - will be enhanced in next story
- Breadcrumbs optional but improve UX
- Route configuration type-safe with TypeScript
