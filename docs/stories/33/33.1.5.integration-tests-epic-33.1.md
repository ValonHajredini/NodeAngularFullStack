# Story 33.1.5: Integration Tests for Epic 33.1

**Epic:** 33.1 Export Core Infrastructure (23 pts) **Story Points:** 5 **Priority:** High
**Status:** Draft **Created:** 2025-10-24

---

## Description

Implement comprehensive integration and E2E tests for Epic 33.1, validating the complete export
infrastructure (orchestrator service, database schema, API endpoints, and pre-flight validation)
working together. Test real database operations, filesystem interactions, multi-step orchestration,
and error scenarios with rollback.

---

## Acceptance Criteria

### Integration Test Coverage

- [ ] Test complete export workflow from API call to package generation
- [ ] Test export orchestrator with real export strategies
- [ ] Test database operations with PostgreSQL test database
- [ ] Test filesystem operations with actual temp directories
- [ ] Test pre-flight validation integration with orchestrator
- [ ] Test error handling and rollback mechanisms
- [ ] Test concurrent export jobs (no interference)
- [ ] Coverage target: ≥85% for all Epic 33.1 services

### E2E Export Workflow Tests

- [ ] Test: Start export → In Progress → Completed
- [ ] Test: Start export → Validation Error → Export Blocked
- [ ] Test: Start export → Step Failure → Rollback
- [ ] Test: Start export → User Cancel → Rollback
- [ ] Test: Multiple exports for same tool (both complete)
- [ ] Test: Export forms tool (8 steps, ~1 minute duration)
- [ ] Test: Export generates valid .tar.gz package

### Database Integration Tests

- [ ] Test: Export job record created in export_jobs table
- [ ] Test: Job status updates during export (pending → in_progress → completed)
- [ ] Test: Job progress tracking (stepsCompleted increments)
- [ ] Test: Foreign key cascade (tool deleted → jobs deleted)
- [ ] Test: Migration up/down works correctly
- [ ] Test: Indexes used by query planner (EXPLAIN ANALYZE)

### Orchestrator Integration Tests

- [ ] Test: Orchestrator selects correct strategy for tool type
- [ ] Test: Orchestrator executes steps sequentially
- [ ] Test: Step failure triggers rollback
- [ ] Test: Timeout protection works (step exceeds 5 minutes)
- [ ] Test: Retry logic works for transient failures
- [ ] Test: Concurrent orchestrations don't conflict

### Pre-flight Validation Integration Tests

- [ ] Test: Validation prevents export of invalid tool
- [ ] Test: Validation allows export of valid tool
- [ ] Test: Validation warnings don't block export
- [ ] Test: Validation caching reduces redundant checks
- [ ] Test: Validation detects low disk space
- [ ] Test: Validation detects missing dependencies

### API Integration Tests

- [ ] Test: POST /tools/:toolId/export creates job
- [ ] Test: GET /export-jobs/:jobId returns real-time status
- [ ] Test: POST /export-jobs/:jobId/cancel cancels job
- [ ] Test: POST /tools/:toolId/export/validate returns validation result
- [ ] Test: Rate limiting enforced on status endpoint
- [ ] Test: Authentication required for all endpoints
- [ ] Test: Permission checks enforced (admin/export permission)

### Error Scenario Tests

- [ ] Test: Tool not found returns 404
- [ ] Test: Invalid toolId format returns 400
- [ ] Test: User without permission returns 403
- [ ] Test: Database connection failure handled gracefully
- [ ] Test: Filesystem write error triggers rollback
- [ ] Test: Strategy execution error triggers rollback
- [ ] Test: Package generation failure updates job status

### Filesystem Integration Tests

- [ ] Test: Working directory created in /tmp/exports/
- [ ] Test: Boilerplate files generated correctly
- [ ] Test: Package files copied to working directory
- [ ] Test: .tar.gz archive created successfully
- [ ] Test: Rollback deletes partial exports
- [ ] Test: Cleanup removes temp directories

### Performance Tests

- [ ] Test: Export completes in < 2 minutes (forms tool)
- [ ] Test: Status polling doesn't degrade performance
- [ ] Test: Concurrent exports don't slow each other down
- [ ] Test: Database queries optimized (indexes used)
- [ ] Test: Memory usage stable during export

---

## Tasks

### 1. Setup Integration Test Infrastructure

**Estimated:** 3 hours **Dependencies:** Stories 33.1.1-33.1.4 **Description:** Configure test
environment for Epic 33.1 integration tests.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/` directory
2. Create `setup.ts` file with test database configuration
3. Create `teardown.ts` file with cleanup logic
4. Configure Jest for integration tests (testMatch pattern)
5. Create test database connection helper
6. Create test data fixtures for tools, users, forms
7. Setup test filesystem paths (/tmp/test-exports/)
8. Mock external dependencies (Docker, npm) where appropriate
9. Add integration test script to package.json
10. Document test setup in README.md

### 2. Integration Test: Complete Export Workflow

**Estimated:** 4 hours **Dependencies:** Task 1 **Description:** Test full export flow from API call
to package generation.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/export-workflow.test.ts`
2. Setup test database with tool registry record (forms tool)
3. Seed form schema and fields for test tool
4. Call POST /tools/:toolId/export API endpoint
5. Verify export job created with status 'pending'
6. Wait for export to complete (poll status every 500ms)
7. Verify job status transitions: pending → in_progress → completed
8. Verify stepsCompleted increases from 0 → 8
9. Verify package_path populated in job record
10. Verify .tar.gz file exists at package_path

### 3. Integration Test: Export Strategies

**Estimated:** 3 hours **Dependencies:** Task 1 **Description:** Test export strategies with real
tool data.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/export-strategies.test.ts`
2. Test FormsExportStrategy with real form schema
3. Verify strategy generates Express.js boilerplate files
4. Verify strategy copies form data to export package
5. Verify strategy creates Docker configuration
6. Test strategy rollback deletes generated files
7. Test WorkflowsExportStrategy (if implemented)
8. Test ThemesExportStrategy (if implemented)
9. Verify each strategy creates valid package structure
10. Verify package files are not corrupted

### 4. Integration Test: Database Operations

**Estimated:** 3 hours **Dependencies:** Task 1 **Description:** Test export_jobs table operations
with PostgreSQL.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/database-operations.test.ts`
2. Test ExportJobRepository.create() inserts record
3. Test ExportJobRepository.update() modifies record
4. Test ExportJobRepository.findById() retrieves record
5. Test ExportJobRepository.findByUserId() filters by user
6. Test ExportJobRepository.findByStatus() filters by status
7. Test foreign key constraint (invalid tool_id fails)
8. Test cascade delete (tool deleted → jobs deleted)
9. Test transaction rollback on error
10. Verify indexes used by query planner (EXPLAIN ANALYZE)

### 5. Integration Test: Pre-flight Validation

**Estimated:** 3 hours **Dependencies:** Task 1 **Description:** Test validation prevents invalid
exports.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/pre-flight-validation.test.ts`
2. Test validation passes for valid tool
3. Test validation fails for tool with missing form schema
4. Test validation fails for tool with zero fields
5. Test validation returns warning for zero submissions
6. Test validation detects low disk space (mock filesystem)
7. Test validation detects missing tar command (mock exec)
8. Test validation caching works (second call faster)
9. Test validation API endpoint returns 422 on failure
10. Verify validation prevents export start

### 6. Integration Test: API Endpoints

**Estimated:** 4 hours **Dependencies:** Task 1 **Description:** Test all export API endpoints with
real authentication.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/api-endpoints.test.ts`
2. Setup JWT tokens for admin and regular user
3. Test POST /tools/:toolId/export with admin token (201 Created)
4. Test POST /tools/:toolId/export without permission (403 Forbidden)
5. Test GET /export-jobs/:jobId returns job status (200 OK)
6. Test GET /export-jobs/:jobId with invalid jobId (404 Not Found)
7. Test POST /export-jobs/:jobId/cancel cancels job (200 OK)
8. Test POST /export-jobs/:jobId/cancel by different user (403)
9. Test POST /tools/:toolId/export/validate returns validation report
10. Test rate limiting on status endpoint (11th request fails)

### 7. Integration Test: Error Scenarios

**Estimated:** 4 hours **Dependencies:** Task 1 **Description:** Test error handling and rollback
mechanisms.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/error-scenarios.test.ts`
2. Test export fails if validation has errors
3. Test step failure triggers rollback
4. Mock step.execute() to throw error
5. Verify completed steps rolled back in reverse order
6. Verify working directory deleted after rollback
7. Verify job status updated to 'failed'
8. Test database connection failure during export
9. Test filesystem write permission error
10. Verify error messages logged with context

### 8. Integration Test: Cancellation Flow

**Estimated:** 3 hours **Dependencies:** Task 2 **Description:** Test user can cancel in-progress
export.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/cancellation.test.ts`
2. Start export job
3. Wait until job reaches 'in_progress' status
4. Call cancel API endpoint
5. Verify job status updates to 'cancelling'
6. Wait for cancellation to complete
7. Verify job status updates to 'cancelled'
8. Verify working directory cleaned up
9. Test cancellation by job creator succeeds
10. Test cancellation by different user fails (403)

### 9. Integration Test: Concurrent Exports

**Estimated:** 3 hours **Dependencies:** Task 2 **Description:** Test multiple concurrent exports
don't interfere.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/concurrent-exports.test.ts`
2. Start 3 export jobs simultaneously (same tool)
3. Verify all 3 jobs created with unique jobIds
4. Poll status of all 3 jobs concurrently
5. Verify all 3 jobs complete successfully
6. Verify working directories are isolated (no conflicts)
7. Verify package files are separate (no overwrites)
8. Test concurrent exports for different tools
9. Verify database connection pool handles load
10. Measure performance degradation (should be minimal)

### 10. Integration Test: Filesystem Operations

**Estimated:** 3 hours **Dependencies:** Task 1 **Description:** Test filesystem interactions during
export.

**Subtasks:**

1. Create `apps/api/tests/integration/epic-33.1/filesystem-operations.test.ts`
2. Test working directory created with unique jobId
3. Test boilerplate files generated (server.ts, package.json, etc.)
4. Test Docker files generated (Dockerfile, docker-compose.yml)
5. Test form data files copied to export package
6. Test .tar.gz archive created with correct contents
7. Test archive extraction succeeds (untar and verify files)
8. Test rollback deletes all generated files
9. Test cleanup removes temp directories after completion
10. Verify no files left behind after export

### 11. Performance Tests

**Estimated:** 3 hours **Dependencies:** All previous tasks **Description:** Test export performance
and resource usage.

**Subtasks:**

1. Create `apps/api/tests/performance/epic-33.1/export-performance.test.ts`
2. Measure export duration for forms tool (should be < 2 minutes)
3. Measure status polling performance (100 requests in 1 second)
4. Test concurrent exports (10 simultaneous exports)
5. Measure database query performance (< 50ms per query)
6. Monitor memory usage during export (should be stable)
7. Test large form export (1000 fields, 10,000 submissions)
8. Measure package generation time (< 10 seconds)
9. Test rate limiting doesn't impact legitimate polling
10. Document performance benchmarks in test file

### 12. E2E Test: User Journey

**Estimated:** 4 hours **Dependencies:** All previous tasks **Description:** Test complete user
journey from login to export.

**Subtasks:**

1. Create `apps/api/tests/e2e/epic-33.1/user-journey.test.ts`
2. Use Playwright or Supertest for E2E testing
3. Step 1: User logs in as admin
4. Step 2: User navigates to tool detail page
5. Step 3: User clicks "Validate Export" button
6. Step 4: Validation passes, user clicks "Export Tool" button
7. Step 5: Export modal opens, progress updates in real-time
8. Step 6: Export completes, success message shows
9. Step 7: User clicks "Download Package" button
10. Verify package downloaded successfully

### 13. Coverage Analysis and Reporting

**Estimated:** 2 hours **Dependencies:** All previous tasks **Description:** Generate and analyze
test coverage for Epic 33.1.

**Subtasks:**

1. Run integration tests with coverage (`npm run test:coverage`)
2. Filter coverage for Epic 33.1 services (orchestrator, validator, etc.)
3. Verify ≥85% statement coverage
4. Verify ≥85% branch coverage
5. Identify uncovered code paths
6. Add tests for critical uncovered paths
7. Generate HTML coverage report
8. Document coverage results in QA gate file
9. Add coverage badge to README.md
10. Setup CI/CD to enforce coverage thresholds

### 14. CI/CD Integration

**Estimated:** 2 hours **Dependencies:** Task 13 **Description:** Add Epic 33.1 tests to CI/CD
pipeline.

**Subtasks:**

1. Create `.github/workflows/test-epic-33.1.yml` workflow file
2. Run integration tests on every push to Epic 33.1 files
3. Run tests on pull requests to main branch
4. Setup PostgreSQL service in GitHub Actions
5. Install test dependencies (Docker, tar, npm)
6. Run tests with coverage reporting
7. Upload coverage to Codecov
8. Fail build if coverage < 85%
9. Upload test artifacts (logs, reports)
10. Add status badge to repository README

### 15. Documentation and Examples

**Estimated:** 2 hours **Dependencies:** All previous tasks **Description:** Document integration
test suite and provide examples.

**Subtasks:**

1. Create `docs/testing/epic-33.1-integration-tests.md`
2. Document test setup and prerequisites
3. Provide example test scenarios
4. Document how to run specific test suites
5. Document how to run tests in debug mode
6. Add troubleshooting guide for common test failures
7. Document test data fixtures and how to modify
8. Add integration test examples to root README.md
9. Document performance benchmarks
10. Add testing best practices for Epic 33.1

---

## Dev Notes

### Integration Test Architecture

```
┌───────────────────────────────────────────────────────┐
│           Integration Test Suite (Epic 33.1)          │
└────────────────────┬──────────────────────────────────┘
                     │
        ┌────────────┴───────────┐
        │                        │
        ▼                        ▼
┌───────────────┐        ┌──────────────┐
│  API Tests    │        │  Service     │
│  (HTTP Layer) │        │  Tests       │
└───────┬───────┘        └──────┬───────┘
        │                       │
        ▼                       ▼
┌───────────────────────────────────────┐
│     ExportOrchestratorService         │
│     PreFlightValidator                │
│     ExportJobRepository               │
└────────────┬──────────────────────────┘
             │
             ▼
┌────────────────────────────────────────┐
│      Real Dependencies                 │
│  - PostgreSQL Test Database            │
│  - Filesystem (/tmp/test-exports/)     │
│  - Export Strategies (Forms, etc.)     │
└────────────────────────────────────────┘
```

**Why This Architecture:**

- **Real Dependencies:** Tests use actual PostgreSQL, filesystem (not mocks)
- **API Layer Tests:** Verify REST endpoints with authentication
- **Service Layer Tests:** Test orchestrator and validator directly
- **Integration:** All components working together (not isolated)

### Complete Export Workflow Test

```typescript
// apps/api/tests/integration/epic-33.1/export-workflow.test.ts
import request from 'supertest';
import app from '../../../src/app';
import { Pool } from 'pg';
import * as fs from 'fs/promises';
import * as path from 'path';

describe('Export Workflow Integration Test', () => {
  let pool: Pool;
  let adminToken: string;
  let testToolId: string;

  beforeAll(async () => {
    // Setup test database
    pool = new Pool({
      host: 'localhost',
      port: 5432,
      database: 'nodeangularfullstack_test',
      user: 'postgres',
      password: 'dbpassword',
    });

    // Run migrations
    await runMigrations(pool);

    // Seed test data
    const toolResult = await pool.query(
      `
      INSERT INTO tool_registry (tool_id, tool_name, tool_type, status, tool_metadata)
      VALUES ($1, $2, $3, $4, $5)
      RETURNING tool_id
    `,
      ['test-tool-123', 'Test Form', 'forms', 'active', { formSchemaId: 'form-456' }]
    );

    testToolId = toolResult.rows[0].tool_id;

    // Get admin token
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({ email: 'admin@example.com', password: 'Admin123!@#' });

    adminToken = loginResponse.body.accessToken;
  });

  afterAll(async () => {
    // Cleanup test data
    await pool.query('DELETE FROM export_jobs WHERE tool_id = $1', [testToolId]);
    await pool.query('DELETE FROM tool_registry WHERE tool_id = $1', [testToolId]);
    await pool.end();
  });

  it('should complete full export workflow: start → in_progress → completed', async () => {
    // Step 1: Start export
    const startResponse = await request(app)
      .post(`/api/tool-registry/tools/${testToolId}/export`)
      .set('Authorization', `Bearer ${adminToken}`)
      .expect(201);

    const jobId = startResponse.body.jobId;
    expect(jobId).toBeDefined();
    expect(startResponse.body.status).toBe('pending');

    // Step 2: Poll status until completed
    let status = 'pending';
    let attempts = 0;
    const maxAttempts = 60; // 60 seconds max

    while (status !== 'completed' && status !== 'failed' && attempts < maxAttempts) {
      await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait 1 second

      const statusResponse = await request(app)
        .get(`/api/tool-registry/export-jobs/${jobId}`)
        .set('Authorization', `Bearer ${adminToken}`)
        .expect(200);

      status = statusResponse.body.status;
      const progress = statusResponse.body.stepsCompleted;
      const total = statusResponse.body.stepsTotal;

      console.log(`[Attempt ${attempts + 1}] Status: ${status}, Progress: ${progress}/${total}`);
      attempts++;
    }

    // Step 3: Verify completed
    expect(status).toBe('completed');

    // Step 4: Verify job record in database
    const jobResult = await pool.query('SELECT * FROM export_jobs WHERE job_id = $1', [jobId]);
    const job = jobResult.rows[0];

    expect(job.status).toBe('completed');
    expect(job.steps_completed).toBe(job.steps_total);
    expect(job.package_path).toBeTruthy();
    expect(job.completed_at).toBeTruthy();

    // Step 5: Verify package file exists
    const packagePath = job.package_path;
    const packageExists = await fs
      .access(packagePath)
      .then(() => true)
      .catch(() => false);

    expect(packageExists).toBe(true);

    // Step 6: Verify package is valid .tar.gz
    expect(packagePath).toMatch(/\.tar\.gz$/);

    // Step 7: Extract and verify package contents (optional)
    const extractDir = path.join('/tmp/test-extracts', jobId);
    await fs.mkdir(extractDir, { recursive: true });

    const { exec } = require('child_process');
    const { promisify } = require('util');
    const execAsync = promisify(exec);

    await execAsync(`tar -xzf ${packagePath} -C ${extractDir}`);

    // Verify key files exist
    const files = await fs.readdir(extractDir);
    expect(files).toContain('package.json');
    expect(files).toContain('Dockerfile');
    expect(files).toContain('docker-compose.yml');

    // Cleanup
    await fs.rm(extractDir, { recursive: true, force: true });
  }, 120000); // 2 minute timeout

  it('should fail export if validation has errors', async () => {
    // Create tool with missing form schema
    const invalidToolResult = await pool.query(
      `
      INSERT INTO tool_registry (tool_id, tool_name, tool_type, status, tool_metadata)
      VALUES ($1, $2, $3, $4, $5)
      RETURNING tool_id
    `,
      ['invalid-tool-789', 'Invalid Form', 'forms', 'active', { formSchemaId: 'non-existent' }]
    );

    const invalidToolId = invalidToolResult.rows[0].tool_id;

    // Attempt to start export
    const response = await request(app)
      .post(`/api/tool-registry/tools/${invalidToolId}/export`)
      .set('Authorization', `Bearer ${adminToken}`)
      .expect(422); // Validation failed

    expect(response.body.message).toContain('validation');

    // Cleanup
    await pool.query('DELETE FROM tool_registry WHERE tool_id = $1', [invalidToolId]);
  });

  it('should cancel in-progress export', async () => {
    // Start export
    const startResponse = await request(app)
      .post(`/api/tool-registry/tools/${testToolId}/export`)
      .set('Authorization', `Bearer ${adminToken}`)
      .expect(201);

    const jobId = startResponse.body.jobId;

    // Wait for export to reach in_progress
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // Cancel export
    const cancelResponse = await request(app)
      .post(`/api/tool-registry/export-jobs/${jobId}/cancel`)
      .set('Authorization', `Bearer ${adminToken}`)
      .expect(200);

    expect(cancelResponse.body.status).toBe('cancelling');

    // Wait for cancellation to complete
    await new Promise((resolve) => setTimeout(resolve, 3000));

    // Verify status
    const statusResponse = await request(app)
      .get(`/api/tool-registry/export-jobs/${jobId}`)
      .set('Authorization', `Bearer ${adminToken}`)
      .expect(200);

    expect(statusResponse.body.status).toBe('cancelled');
  }, 30000);
});
```

**Why This Test Pattern:**

- **Real HTTP Requests:** Uses `supertest` to test actual API endpoints
- **Real Database:** Queries PostgreSQL to verify state
- **Real Filesystem:** Checks .tar.gz file exists and can be extracted
- **Polling Loop:** Simulates frontend polling behavior
- **Timeout:** 2-minute timeout allows export to complete fully
- **Cleanup:** Removes test data after each test

### Database Integration Test Example

```typescript
// apps/api/tests/integration/epic-33.1/database-operations.test.ts
import { ExportJobRepository } from '../../../src/repositories/export-job.repository';
import { Pool } from 'pg';
import { ExportJobStatus } from '@nodeangularfullstack/shared';

describe('ExportJobRepository Integration Tests', () => {
  let repository: ExportJobRepository;
  let pool: Pool;

  beforeAll(async () => {
    pool = new Pool({
      host: 'localhost',
      port: 5432,
      database: 'nodeangularfullstack_test',
      user: 'postgres',
      password: 'dbpassword',
    });

    repository = new ExportJobRepository(pool);
  });

  afterAll(async () => {
    await pool.end();
  });

  describe('Foreign Key Cascade', () => {
    it('should delete export jobs when tool is deleted', async () => {
      // Create test tool
      const toolResult = await pool.query(
        `
        INSERT INTO tool_registry (tool_id, tool_name, tool_type, status)
        VALUES ($1, $2, $3, $4)
        RETURNING tool_id
      `,
        ['cascade-tool-123', 'Cascade Test', 'forms', 'active']
      );

      const toolId = toolResult.rows[0].tool_id;

      // Create export job for tool
      const job = await repository.create({
        jobId: 'cascade-job-456',
        toolId,
        userId: 'user-789',
        status: ExportJobStatus.PENDING,
      });

      expect(job.jobId).toBe('cascade-job-456');

      // Delete tool (should cascade to export_jobs)
      await pool.query('DELETE FROM tool_registry WHERE tool_id = $1', [toolId]);

      // Verify export job was deleted
      const deletedJob = await repository.findById('cascade-job-456');
      expect(deletedJob).toBeNull();
    });
  });

  describe('Index Usage', () => {
    it('should use index for findByUserId query', async () => {
      // Create test data
      const userId = 'index-test-user';
      await repository.create({
        jobId: 'index-test-job-1',
        toolId: 'tool-123',
        userId,
        status: ExportJobStatus.PENDING,
      });

      // Run EXPLAIN ANALYZE on query
      const explainResult = await pool.query(
        `
        EXPLAIN (ANALYZE, FORMAT JSON)
        SELECT * FROM export_jobs WHERE user_id = $1
      `,
        [userId]
      );

      const queryPlan = explainResult.rows[0]['QUERY PLAN'][0];
      const usesIndex = JSON.stringify(queryPlan).includes('idx_export_jobs_user_id');

      expect(usesIndex).toBe(true);

      // Cleanup
      await pool.query('DELETE FROM export_jobs WHERE user_id = $1', [userId]);
    });
  });
});
```

**Why EXPLAIN ANALYZE:**

- Verifies indexes are actually used by query planner
- Catches performance regressions (queries without indexes)
- Validates index design decisions

### Manual Test Script

```bash
#!/bin/bash
# tests/manual/epic-33.1-integration-test.sh

echo "=== Epic 33.1 Integration Test Suite ==="
echo

echo "Step 1: Start backend API and database"
./start-dev.sh &
sleep 5

echo "Step 2: Run integration tests"
npm --workspace=apps/api run test:integration -- --testPathPattern="epic-33.1" --watch=false

INTEGRATION_EXIT_CODE=$?

echo "Step 3: Run performance tests"
npm --workspace=apps/api run test:performance -- --testPathPattern="epic-33.1" --watch=false

PERFORMANCE_EXIT_CODE=$?

echo "Step 4: Generate coverage report"
npm --workspace=apps/api run test:coverage -- --include="**/export-orchestrator*" --include="**/pre-flight-validator*"

COVERAGE_EXIT_CODE=$?

echo
echo "=== Test Results Summary ==="
echo "Integration Tests: $([ $INTEGRATION_EXIT_CODE -eq 0 ] && echo 'PASSED' || echo 'FAILED')"
echo "Performance Tests: $([ $PERFORMANCE_EXIT_CODE -eq 0 ] && echo 'PASSED' || echo 'FAILED')"
echo "Coverage: $([ $COVERAGE_EXIT_CODE -eq 0 ] && echo 'PASSED' || echo 'FAILED')"

./stop-dev.sh

if [ $INTEGRATION_EXIT_CODE -ne 0 ] || [ $PERFORMANCE_EXIT_CODE -ne 0 ] || [ $COVERAGE_EXIT_CODE -ne 0 ]; then
  echo
  echo "❌ Some tests failed"
  exit 1
fi

echo
echo "✅ All tests passed!"
exit 0
```

---

## Testing

### Test Execution Checklist

**Pre-Test Setup:**

- [ ] PostgreSQL running (`brew services start postgresql@14`)
- [ ] Test database created (`createdb nodeangularfullstack_test`)
- [ ] Migrations run on test database
- [ ] Test data seeded (tools, users, forms)
- [ ] `/tmp/test-exports/` directory exists and writable

**Integration Test Execution:**

- [ ] Run all Epic 33.1 integration tests
- [ ] Verify export workflow test passes
- [ ] Verify database operations test passes
- [ ] Verify API endpoints test passes
- [ ] Verify error scenarios test passes
- [ ] Verify cancellation test passes

**Coverage Validation:**

- [ ] Generate coverage report for Epic 33.1
- [ ] Verify ≥85% statement coverage
- [ ] Verify ≥85% branch coverage
- [ ] Review uncovered code paths
- [ ] Add tests for critical uncovered paths

**Performance Validation:**

- [ ] Export completes in < 2 minutes
- [ ] Status polling doesn't degrade performance
- [ ] Concurrent exports work correctly
- [ ] Database queries optimized (< 50ms)
- [ ] Memory usage stable during export

---

## Dependencies

### Blocked By:

- Story 33.1.1: Export Orchestrator Service
- Story 33.1.2: Export Jobs Database Schema
- Story 33.1.3: Export Job Status Tracking
- Story 33.1.4: Pre-flight Validation

### Blocks:

- Epic 33.2: Export Package Distribution (integration tests pass → move forward)

### Related:

- Story 32.2.5: Integration Tests for Epic 32.2 (similar testing approach)

---

## QA Gate

**Gate File:** `docs/qa/gates/33.1.5-integration-tests-epic-33.1.yml`

### Quality Criteria (Weighted):

| Criterion                 | Weight | Target                     | Validation Method |
| ------------------------- | ------ | -------------------------- | ----------------- |
| Integration Test Coverage | 30%    | ≥85% services/repositories | Jest coverage     |
| E2E Test Coverage         | 25%    | Complete workflow tested   | Manual review     |
| Performance Tests         | 20%    | Export < 2 min             | Performance suite |
| Error Scenario Coverage   | 15%    | All error paths tested     | Test review       |
| CI/CD Integration         | 10%    | Tests run in pipeline      | GitHub Actions    |

**Minimum Score:** 90/100 to pass gate

---

## Notes

### ★ Insight ─────────────────────────────────────

**Integration vs E2E Tests:**

- **Integration Tests:** Test components working together (service + DB + filesystem)
- **E2E Tests:** Test complete user journey (HTTP request → response)
- Both essential: Integration tests catch boundary errors, E2E tests verify user experience

**Why Real Dependencies:**

- Mocks can hide integration bugs (incompatible interfaces)
- Real database catches SQL errors, constraint violations
- Real filesystem catches permission errors, path issues

**Performance Test Strategy:**

- Measure baseline performance (export duration, query time)
- Detect performance regressions in CI/CD
- Set acceptable limits (< 2 min export, < 50ms queries)

─────────────────────────────────────────────────

**Story State:** Draft **Last Updated:** 2025-10-24 **Next Review:** After implementation completion
