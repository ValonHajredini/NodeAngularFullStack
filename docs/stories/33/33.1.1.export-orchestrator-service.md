# Story 33.1.1: Export Orchestrator Service

**Epic:** 33.1 Export Core Infrastructure (23 pts) **Story Points:** 8 **Priority:** Critical
**Status:** Draft **Created:** 2025-10-24

---

## Description

Implement the core ExportOrchestratorService in the backend API to coordinate the export of
registered tools as independent service packages. The orchestrator uses a strategy pattern to handle
different tool types (forms, workflows, themes) and manages the multi-step export process with
progress tracking, error handling, and rollback capabilities.

---

## Acceptance Criteria

### Service Architecture

- [ ] Create `ExportOrchestratorService` class in
      `apps/api/src/services/export-orchestrator.service.ts`
- [ ] Implement dependency injection for ToolRegistryRepository and ExportJobRepository
- [ ] Service follows Clean Architecture principles (service → repository pattern)
- [ ] Service uses TypeScript strict mode with full type safety
- [ ] Service includes comprehensive JSDoc documentation

### Export Strategy Pattern

- [ ] Create `IExportStrategy` interface in
      `apps/api/src/services/export-strategies/base.strategy.ts`
- [ ] Implement `FormsExportStrategy` for exporting form builder tools
- [ ] Implement `WorkflowsExportStrategy` for exporting workflow tools
- [ ] Implement `ThemesExportStrategy` for exporting theme tools
- [ ] Strategy factory pattern for strategy selection based on tool type
- [ ] Each strategy defines export steps specific to tool type

### Step Orchestration

- [ ] Orchestrator executes export steps sequentially
- [ ] Each step reports progress (current step, steps completed, steps total)
- [ ] Step execution includes timeout protection (max 5 minutes per step)
- [ ] Failed steps trigger rollback of previous steps
- [ ] Orchestrator persists progress after each step completion
- [ ] Orchestrator supports resuming interrupted exports

### Export Job Management

- [ ] `startExport(toolId, userId)` method creates export job and begins orchestration
- [ ] `getExportStatus(jobId)` method retrieves current job status and progress
- [ ] `cancelExport(jobId, userId)` method cancels in-progress export and triggers rollback
- [ ] Job status updates persisted to database in real-time
- [ ] Export jobs include created/updated timestamps
- [ ] Export jobs reference user who initiated export (audit trail)

### Package Generation

- [ ] Orchestrator generates standalone service package (boilerplate + tool data)
- [ ] Package includes Docker configuration (Dockerfile, docker-compose.yml)
- [ ] Package includes environment configuration (.env.example)
- [ ] Package includes README.md with setup instructions
- [ ] Package includes tool-specific data (schemas, configurations, assets)
- [ ] Package stored in temporary directory with unique job ID

### Error Handling

- [ ] Service validates tool exists before starting export
- [ ] Service validates user has export permission before starting
- [ ] Service handles strategy execution errors gracefully
- [ ] Service logs all errors with context (toolId, jobId, step)
- [ ] Service implements retry logic for transient failures (max 3 retries)
- [ ] Service cleans up partial exports on failure (rollback)

### Rollback Capabilities

- [ ] Each strategy step defines rollback logic (cleanup operations)
- [ ] Failed steps trigger rollback of completed steps in reverse order
- [ ] Cancelled exports trigger full rollback
- [ ] Rollback errors logged but don't block cancellation
- [ ] Database records updated to reflect rollback status

### Testing

- [ ] Unit tests for ExportOrchestratorService methods (≥90% coverage)
- [ ] Unit tests for each export strategy (≥85% coverage)
- [ ] Integration tests for strategy factory pattern
- [ ] Mock ExportJobRepository and ToolRegistryRepository
- [ ] Test error scenarios (tool not found, permission denied, step failure)
- [ ] Test cancellation and rollback logic

---

## Tasks

### 1. Setup Export Service Infrastructure

**Estimated:** 3 hours **Dependencies:** Story 30.1.2 (Tool Registry Repository) **Description:**
Create directory structure, interfaces, and base classes for export orchestration.

**Subtasks:**

1. Create `apps/api/src/services/export-strategies/` directory
2. Create `IExportStrategy` interface in `base.strategy.ts`
3. Define `ExportStep` type with properties: name, description, execute(), rollback()
4. Define `ExportContext` interface with toolId, jobId, userId, workingDir, metadata
5. Create `ExportOrchestratorService` class skeleton in `export-orchestrator.service.ts`
6. Add dependency injection for ToolRegistryRepository
7. Add dependency injection for ExportJobRepository (Story 33.1.2)
8. Create `apps/api/src/types/export.types.ts` with ExportJob and ExportStep interfaces
9. Export new service from `apps/api/src/services/index.ts`
10. Document service architecture in story dev notes

### 2. Implement IExportStrategy Interface

**Estimated:** 2 hours **Dependencies:** Task 1 **Description:** Define contract for export
strategies with step execution and rollback.

**Subtasks:**

1. Define `IExportStrategy` interface with getSteps() method
2. Define `IExportStep` interface with execute(context) and rollback(context) methods
3. Add `estimatedDurationMs` property to IExportStep
4. Add `priority` property to IExportStep (for step ordering)
5. Add `retryable` boolean property to IExportStep
6. Create `BaseExportStrategy` abstract class implementing common logic
7. Implement `validateToolData()` abstract method in BaseExportStrategy
8. Implement `generatePackageMetadata()` abstract method in BaseExportStrategy
9. Add JSDoc comments documenting strategy contract
10. Export interfaces from `apps/api/src/types/export.types.ts`

### 3. Implement FormsExportStrategy

**Estimated:** 5 hours **Dependencies:** Task 2 **Description:** Implement export strategy for form
builder tools with 8 steps.

**Subtasks:**

1. Create `apps/api/src/services/export-strategies/forms.strategy.ts`
2. Implement Step 1: Validate form tool data (check formSchemaId exists)
3. Implement Step 2: Generate Express.js boilerplate with TypeScript
4. Implement Step 3: Copy form schemas and submissions from database
5. Implement Step 4: Generate Prisma schema for standalone database
6. Implement Step 5: Generate migration files for standalone database
7. Implement Step 6: Create Docker configuration (Dockerfile, docker-compose.yml)
8. Implement Step 7: Generate README.md with setup instructions
9. Implement Step 8: Package files into .tar.gz archive
10. Implement rollback() for each step (cleanup temp files, database records)

### 4. Implement WorkflowsExportStrategy

**Estimated:** 4 hours **Dependencies:** Task 2 **Description:** Implement export strategy for
workflow tools with 7 steps.

**Subtasks:**

1. Create `apps/api/src/services/export-strategies/workflows.strategy.ts`
2. Implement Step 1: Validate workflow tool data (check workflowId exists)
3. Implement Step 2: Generate Node.js workflow engine boilerplate
4. Implement Step 3: Copy workflow definitions and execution history
5. Implement Step 4: Generate workflow JSON schema files
6. Implement Step 5: Create Docker configuration for workflow service
7. Implement Step 6: Generate README.md with workflow documentation
8. Implement Step 7: Package files into .tar.gz archive
9. Implement rollback() for each step
10. Add unit tests for WorkflowsExportStrategy

### 5. Implement ThemesExportStrategy

**Estimated:** 3 hours **Dependencies:** Task 2 **Description:** Implement export strategy for theme
tools with 6 steps.

**Subtasks:**

1. Create `apps/api/src/services/export-strategies/themes.strategy.ts`
2. Implement Step 1: Validate theme tool data (check themeId exists)
3. Implement Step 2: Generate CSS theme package with variables
4. Implement Step 3: Copy theme assets (fonts, images, backgrounds)
5. Implement Step 4: Generate theme documentation (color palette, typography)
6. Implement Step 5: Create NPM package structure (package.json, index.css)
7. Implement Step 6: Package files into .tar.gz archive
8. Implement rollback() for each step
9. Add unit tests for ThemesExportStrategy
10. Document theme export format in dev notes

### 6. Implement Strategy Factory Pattern

**Estimated:** 2 hours **Dependencies:** Tasks 3, 4, 5 **Description:** Create factory to select
appropriate export strategy based on tool type.

**Subtasks:**

1. Create `apps/api/src/services/export-strategies/factory.ts`
2. Implement `ExportStrategyFactory` class with static `create()` method
3. Map tool types to strategy classes (forms → FormsExportStrategy, etc.)
4. Throw error if tool type not supported
5. Add caching for strategy instances (singleton pattern)
6. Add unit tests for factory pattern
7. Mock strategy creation in orchestrator tests
8. Document factory usage in JSDoc comments
9. Export factory from `apps/api/src/services/index.ts`
10. Add example usage in dev notes

### 7. Implement startExport() Method

**Estimated:** 4 hours **Dependencies:** Task 6 **Description:** Orchestrate export job creation and
step execution.

**Subtasks:**

1. Validate toolId exists in ToolRegistryRepository
2. Validate userId has export permission (check AuthService)
3. Create export job record in database (status: 'pending')
4. Retrieve tool data from ToolRegistryRepository
5. Select export strategy using ExportStrategyFactory
6. Get export steps from selected strategy
7. Create temporary working directory (`/tmp/exports/${jobId}/`)
8. Execute steps sequentially with progress tracking
9. Update job status to 'in_progress' before first step
10. Update job status to 'completed' after last step

### 8. Implement Step Execution with Progress Tracking

**Estimated:** 4 hours **Dependencies:** Task 7 **Description:** Execute export steps with real-time
progress updates.

**Subtasks:**

1. Create `executeStep()` private method accepting step and context
2. Update job record before step execution (currentStep, stepsCompleted)
3. Call step.execute(context) with try-catch error handling
4. Update job record after successful step execution
5. Implement step timeout protection (max 5 minutes per step)
6. Log step start and completion with timestamps
7. Calculate and update progress percentage (stepsCompleted / stepsTotal)
8. Persist progress to database after each step
9. Return step result to orchestrator
10. Add unit tests for step execution flow

### 9. Implement Error Handling and Retry Logic

**Estimated:** 3 hours **Dependencies:** Task 8 **Description:** Handle step execution errors with
retry and rollback.

**Subtasks:**

1. Catch errors during step execution
2. Check if step is retryable (IExportStep.retryable property)
3. Implement retry logic with exponential backoff (3 attempts max)
4. Log each retry attempt with error details
5. If retries exhausted, mark step as failed
6. Update job status to 'failed' if step fails permanently
7. Store error message and stack trace in job record
8. Trigger rollback of completed steps on failure
9. Send error notification (future: email/webhook)
10. Add unit tests for error handling scenarios

### 10. Implement Rollback Mechanism

**Estimated:** 4 hours **Dependencies:** Task 9 **Description:** Implement rollback logic to undo
completed steps on failure or cancellation.

**Subtasks:**

1. Create `rollbackSteps()` private method accepting completed steps array
2. Reverse order of completed steps (LIFO - last in, first out)
3. Call step.rollback(context) for each completed step
4. Log rollback start and completion for each step
5. Handle rollback errors gracefully (log but continue)
6. Update job status to 'rolled_back' after rollback completes
7. Clean up temporary working directory
8. Delete partial export package files
9. Persist rollback status to database
10. Add unit tests for rollback scenarios

### 11. Implement getExportStatus() Method

**Estimated:** 2 hours **Dependencies:** Task 7 **Description:** Retrieve current export job status
and progress for polling.

**Subtasks:**

1. Query ExportJobRepository by jobId
2. Return job record if found
3. Throw 404 error if job not found
4. Include all job properties (status, progress, currentStep, createdAt, updatedAt)
5. Calculate progress percentage if not stored
6. Add caching layer for frequently polled jobs (Redis optional)
7. Add rate limiting for status endpoint (10 requests per second max)
8. Log status retrieval requests for monitoring
9. Add unit tests for getExportStatus()
10. Document response format in JSDoc

### 12. Implement cancelExport() Method

**Estimated:** 3 hours **Dependencies:** Task 10 **Description:** Cancel in-progress export job and
trigger rollback.

**Subtasks:**

1. Query ExportJobRepository to find job by jobId
2. Validate job exists and status is 'in_progress' or 'pending'
3. Validate requesting userId matches job creator (or is admin)
4. Update job status to 'cancelling' immediately
5. Stop current step execution gracefully (if possible)
6. Retrieve list of completed steps from job record
7. Trigger rollback of completed steps
8. Update job status to 'cancelled' after rollback
9. Clean up temporary working directory
10. Add unit tests for cancellation flow

### 13. Implement Package Generation

**Estimated:** 5 hours **Dependencies:** Tasks 3, 4, 5 **Description:** Generate standalone service
package with boilerplate and tool data.

**Subtasks:**

1. Create `apps/api/src/utils/package-generator.ts` utility
2. Implement `generateDockerfile()` function with template
3. Implement `generateDockerCompose()` function with PostgreSQL service
4. Implement `generateEnvExample()` function with required variables
5. Implement `generatePackageJson()` function with dependencies
6. Implement `generateREADME()` function with setup instructions
7. Implement `generatePrismaSchema()` function for database schema
8. Implement `copyToolData()` function to include schemas/configs
9. Implement `createTarArchive()` function to compress package
10. Add unit tests for each generator function

### 14. Implement Timeout Protection

**Estimated:** 2 hours **Dependencies:** Task 8 **Description:** Prevent steps from hanging
indefinitely with timeout protection.

**Subtasks:**

1. Wrap step.execute() with Promise.race() and timeout promise
2. Set timeout duration to 5 minutes (300,000ms) per step
3. If timeout exceeded, throw TimeoutError
4. Log timeout error with step name and elapsed time
5. Trigger rollback on timeout
6. Update job status to 'failed' with timeout message
7. Add configurable timeout per step type (read from strategy)
8. Add unit tests with mocked delays
9. Document timeout behavior in JSDoc
10. Add timeout configuration to environment variables

### 15. Implement Audit Trail and Logging

**Estimated:** 2 hours **Dependencies:** Task 7 **Description:** Comprehensive logging and audit
trail for export operations.

**Subtasks:**

1. Log export job creation with toolId, userId, timestamp
2. Log each step start with step name and context
3. Log each step completion with duration and result
4. Log errors with full stack trace and context
5. Log retry attempts with attempt number
6. Log rollback operations with step details
7. Log cancellation requests with userId
8. Use structured logging (JSON format for parsing)
9. Include correlation ID (jobId) in all logs
10. Add log level configuration (debug, info, warn, error)

### 16. Integration Tests

**Estimated:** 4 hours **Dependencies:** All previous tasks **Description:** Test orchestrator with
real strategies and repositories.

**Subtasks:**

1. Create `apps/api/tests/integration/export-orchestrator.test.ts`
2. Setup test database with tool registry records
3. Test startExport() with forms tool (full export flow)
4. Test startExport() with invalid toolId (validation error)
5. Test cancelExport() during in-progress export
6. Test getExportStatus() returns correct progress
7. Test step failure triggers rollback
8. Test retry logic for transient failures
9. Verify temporary files cleaned up after export
10. Verify job records persisted correctly

### 17. Documentation and Examples

**Estimated:** 2 hours **Dependencies:** All previous tasks **Description:** Document service usage
and provide code examples.

**Subtasks:**

1. Add comprehensive JSDoc comments to ExportOrchestratorService
2. Document each method with @param, @returns, @throws tags
3. Add usage examples in JSDoc @example tags
4. Create `docs/architecture/export-orchestrator.md` with architecture diagram
5. Document strategy pattern and how to add new strategies
6. Document rollback mechanism and step design
7. Add error handling best practices
8. Document performance considerations (timeout, retries)
9. Add troubleshooting guide for common issues
10. Update root README.md with export feature documentation

---

## Dev Notes

### Architecture Context

**Service Layer Pattern:**

```
ExportOrchestratorService (Orchestrator)
    ↓
ExportStrategyFactory (Factory Pattern)
    ↓
IExportStrategy (Strategy Pattern)
    ├── FormsExportStrategy (Concrete Strategy)
    ├── WorkflowsExportStrategy (Concrete Strategy)
    └── ThemesExportStrategy (Concrete Strategy)
        ↓
    IExportStep[] (Step Pattern)
        ├── Step 1: Validate
        ├── Step 2: Generate Boilerplate
        ├── Step 3: Copy Data
        └── Step N: Package Archive
```

**Why This Architecture:**

- **Orchestrator:** Coordinates the overall export process, manages job lifecycle
- **Factory:** Decouples orchestrator from concrete strategy implementations
- **Strategy:** Encapsulates tool-type-specific export logic (single responsibility)
- **Steps:** Break complex export into small, testable, rollbackable units

### Strategy Pattern Implementation

```typescript
// apps/api/src/services/export-strategies/base.strategy.ts

/**
 * Export step interface defining the contract for each step in the export process.
 */
export interface IExportStep {
  /** Unique step identifier */
  name: string;
  /** Human-readable step description */
  description: string;
  /** Estimated duration in milliseconds */
  estimatedDurationMs: number;
  /** Whether this step can be retried on failure */
  retryable: boolean;
  /** Step execution priority (lower = earlier) */
  priority: number;

  /**
   * Execute the export step
   * @param context - Export context with tool data and working directory
   * @returns Promise resolving to step result
   * @throws Error if step execution fails
   */
  execute(context: ExportContext): Promise<void>;

  /**
   * Rollback the export step (undo changes)
   * @param context - Export context
   * @returns Promise resolving when rollback complete
   */
  rollback(context: ExportContext): Promise<void>;
}

/**
 * Export context passed to each step
 */
export interface ExportContext {
  /** Tool ID being exported */
  toolId: string;
  /** Export job ID */
  jobId: string;
  /** User ID who initiated export */
  userId: string;
  /** Temporary working directory for export files */
  workingDir: string;
  /** Tool-specific metadata (forms, workflows, themes) */
  metadata: Record<string, any>;
  /** Tool data retrieved from registry */
  toolData: ToolRegistryRecord;
}

/**
 * Export strategy interface for tool-type-specific export logic
 */
export interface IExportStrategy {
  /**
   * Get ordered list of export steps for this tool type
   * @param toolData - Tool registry record
   * @returns Array of export steps
   */
  getSteps(toolData: ToolRegistryRecord): IExportStep[];

  /**
   * Validate tool data before export
   * @param toolData - Tool registry record
   * @throws Error if tool data invalid
   */
  validateToolData(toolData: ToolRegistryRecord): void;

  /**
   * Generate package metadata (package.json, README.md frontmatter)
   * @param toolData - Tool registry record
   * @returns Package metadata object
   */
  generatePackageMetadata(toolData: ToolRegistryRecord): Record<string, any>;
}

/**
 * Base export strategy with common functionality
 */
export abstract class BaseExportStrategy implements IExportStrategy {
  abstract getSteps(toolData: ToolRegistryRecord): IExportStep[];
  abstract validateToolData(toolData: ToolRegistryRecord): void;
  abstract generatePackageMetadata(toolData: ToolRegistryRecord): Record<string, any>;

  /**
   * Common step execution wrapper with error handling
   */
  protected async executeWithErrorHandling(
    step: IExportStep,
    context: ExportContext
  ): Promise<void> {
    try {
      await step.execute(context);
    } catch (error) {
      throw new Error(`Step ${step.name} failed: ${error.message}`);
    }
  }
}
```

**Why This Design:**

- Interface-driven design enables polymorphism and testability
- `IExportStep` makes each step independently testable and rollbackable
- `BaseExportStrategy` provides common functionality (DRY principle)
- `ExportContext` contains all data needed by any step (avoiding global state)

### FormsExportStrategy Implementation

```typescript
// apps/api/src/services/export-strategies/forms.strategy.ts
import { BaseExportStrategy, IExportStep, ExportContext } from './base.strategy';
import { ToolRegistryRecord } from '@nodeangularfullstack/shared';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Export strategy for form builder tools
 * Generates standalone Express.js service with form schemas and submission handling
 */
export class FormsExportStrategy extends BaseExportStrategy {
  validateToolData(toolData: ToolRegistryRecord): void {
    if (toolData.toolType !== 'forms') {
      throw new Error(`Invalid tool type: expected 'forms', got '${toolData.toolType}'`);
    }

    if (!toolData.toolMetadata?.formSchemaId) {
      throw new Error('Missing formSchemaId in tool metadata');
    }
  }

  generatePackageMetadata(toolData: ToolRegistryRecord): Record<string, any> {
    return {
      name: `form-service-${toolData.toolId}`,
      version: '1.0.0',
      description: `Standalone form service exported from ${toolData.toolName}`,
      main: 'src/server.ts',
      scripts: {
        dev: 'ts-node src/server.ts',
        build: 'tsc',
        start: 'node dist/server.js',
      },
      dependencies: {
        express: '^4.18.2',
        pg: '^8.11.3',
        dotenv: '^16.3.1',
      },
      devDependencies: {
        typescript: '^5.3.3',
        '@types/express': '^4.17.21',
        '@types/node': '^20.10.6',
        'ts-node': '^10.9.2',
      },
    };
  }

  getSteps(toolData: ToolRegistryRecord): IExportStep[] {
    return [
      new ValidateFormDataStep(),
      new GenerateExpressBoilerplateStep(),
      new CopyFormSchemasStep(),
      new GeneratePrismaSchemaStep(),
      new GenerateMigrationsStep(),
      new GenerateDockerConfigStep(),
      new GenerateREADMEStep(),
      new PackageArchiveStep(),
    ];
  }
}

/**
 * Step 1: Validate form tool data
 */
class ValidateFormDataStep implements IExportStep {
  name = 'validate-form-data';
  description = 'Validate form schemas and submissions exist';
  estimatedDurationMs = 2000; // 2 seconds
  retryable = true;
  priority = 1;

  async execute(context: ExportContext): Promise<void> {
    const { toolData } = context;
    const formSchemaId = toolData.toolMetadata?.formSchemaId;

    // Query database to verify form schema exists
    const formSchema = await this.getFormSchema(formSchemaId);
    if (!formSchema) {
      throw new Error(`Form schema ${formSchemaId} not found`);
    }

    // Store form schema in context for later steps
    context.metadata.formSchema = formSchema;
    context.metadata.submissionCount = await this.getSubmissionCount(formSchemaId);
  }

  async rollback(context: ExportContext): Promise<void> {
    // No cleanup needed for validation step
  }

  private async getFormSchema(formSchemaId: string): Promise<any> {
    // TODO: Query forms repository
    return { id: formSchemaId, schema: {} };
  }

  private async getSubmissionCount(formSchemaId: string): Promise<number> {
    // TODO: Query submissions repository
    return 0;
  }
}

/**
 * Step 2: Generate Express.js boilerplate
 */
class GenerateExpressBoilerplateStep implements IExportStep {
  name = 'generate-express-boilerplate';
  description = 'Generate Express.js TypeScript boilerplate';
  estimatedDurationMs = 5000; // 5 seconds
  retryable = true;
  priority = 2;

  async execute(context: ExportContext): Promise<void> {
    const { workingDir } = context;
    const srcDir = path.join(workingDir, 'src');

    // Create directory structure
    await fs.mkdir(srcDir, { recursive: true });

    // Generate server.ts
    const serverCode = this.generateServerCode(context);
    await fs.writeFile(path.join(srcDir, 'server.ts'), serverCode, 'utf-8');

    // Generate package.json
    const packageJson = this.generatePackageJson(context);
    await fs.writeFile(
      path.join(workingDir, 'package.json'),
      JSON.stringify(packageJson, null, 2),
      'utf-8'
    );

    // Generate tsconfig.json
    const tsconfigJson = this.generateTsConfig();
    await fs.writeFile(
      path.join(workingDir, 'tsconfig.json'),
      JSON.stringify(tsconfigJson, null, 2),
      'utf-8'
    );
  }

  async rollback(context: ExportContext): Promise<void> {
    // Delete generated files
    const filesToDelete = ['src/server.ts', 'package.json', 'tsconfig.json'];
    for (const file of filesToDelete) {
      const filePath = path.join(context.workingDir, file);
      await fs.unlink(filePath).catch(() => {});
    }
  }

  private generateServerCode(context: ExportContext): string {
    return `
import express from 'express';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

// Form submission endpoint
app.post('/api/forms/submit', async (req, res) => {
  // TODO: Handle form submission
  res.json({ success: true });
});

app.listen(PORT, () => {
  console.log(\`Form service running on port \${PORT}\`);
});
    `.trim();
  }

  private generatePackageJson(context: ExportContext): any {
    const strategy = new FormsExportStrategy();
    return strategy.generatePackageMetadata(context.toolData);
  }

  private generateTsConfig(): any {
    return {
      compilerOptions: {
        target: 'ES2020',
        module: 'commonjs',
        outDir: './dist',
        rootDir: './src',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
      },
      include: ['src/**/*'],
    };
  }
}

// Additional step classes (CopyFormSchemasStep, GeneratePrismaSchemaStep, etc.)
// Similar implementation pattern with execute() and rollback() methods
```

**Why This Implementation:**

- Each step is a separate class (single responsibility, easy to test)
- `execute()` performs the work, `rollback()` undoes it
- Steps store intermediate results in `context.metadata` for later steps
- File operations use async/await for non-blocking I/O
- Error messages include context (formSchemaId, filePath, etc.)

### ExportOrchestratorService Implementation

```typescript
// apps/api/src/services/export-orchestrator.service.ts
import { Injectable } from '@nestjs/common';
import { ToolRegistryRepository } from '../repositories/tool-registry.repository';
import { ExportJobRepository } from '../repositories/export-job.repository';
import { ExportStrategyFactory } from './export-strategies/factory';
import { IExportStrategy, ExportContext } from './export-strategies/base.strategy';
import { ExportJob, ExportJobStatus } from '@nodeangularfullstack/shared';
import * as fs from 'fs/promises';
import * as path from 'path';
import { v4 as uuidv4 } from 'uuid';

/**
 * Export orchestrator service
 * Coordinates export of tools as standalone service packages
 */
@Injectable()
export class ExportOrchestratorService {
  private readonly EXPORT_TEMP_DIR = '/tmp/exports';
  private readonly STEP_TIMEOUT_MS = 300000; // 5 minutes
  private readonly MAX_RETRIES = 3;

  constructor(
    private readonly toolRegistryRepo: ToolRegistryRepository,
    private readonly exportJobRepo: ExportJobRepository
  ) {}

  /**
   * Start export job for a tool
   * @param toolId - Tool registry ID
   * @param userId - User ID initiating export
   * @returns Export job record
   * @throws Error if tool not found or user lacks permission
   */
  async startExport(toolId: string, userId: string): Promise<ExportJob> {
    // Step 1: Validate tool exists
    const tool = await this.toolRegistryRepo.findById(toolId);
    if (!tool) {
      throw new Error(`Tool ${toolId} not found`);
    }

    // Step 2: Validate user has export permission
    await this.validateExportPermission(userId);

    // Step 3: Create export job record
    const jobId = uuidv4();
    const job = await this.exportJobRepo.create({
      jobId,
      toolId,
      userId,
      status: 'pending' as ExportJobStatus,
      stepsCompleted: 0,
      stepsTotal: 0,
      currentStep: 'Initializing...',
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    // Step 4: Execute export asynchronously (don't block)
    this.executeExport(job, tool).catch((error) => {
      console.error(`Export job ${jobId} failed:`, error);
    });

    return job;
  }

  /**
   * Execute export job with strategy pattern
   * @param job - Export job record
   * @param tool - Tool registry record
   */
  private async executeExport(job: ExportJob, tool: any): Promise<void> {
    try {
      // Step 1: Update job status to in_progress
      await this.exportJobRepo.update(job.jobId, {
        status: 'in_progress' as ExportJobStatus,
        updatedAt: new Date(),
      });

      // Step 2: Select export strategy
      const strategy = ExportStrategyFactory.create(tool.toolType);

      // Step 3: Validate tool data
      strategy.validateToolData(tool);

      // Step 4: Get export steps
      const steps = strategy.getSteps(tool);
      await this.exportJobRepo.update(job.jobId, {
        stepsTotal: steps.length,
        updatedAt: new Date(),
      });

      // Step 5: Create working directory
      const workingDir = path.join(this.EXPORT_TEMP_DIR, job.jobId);
      await fs.mkdir(workingDir, { recursive: true });

      // Step 6: Create export context
      const context: ExportContext = {
        jobId: job.jobId,
        toolId: tool.toolId,
        userId: job.userId,
        workingDir,
        metadata: {},
        toolData: tool,
      };

      // Step 7: Execute steps sequentially
      const completedSteps = [];
      for (let i = 0; i < steps.length; i++) {
        const step = steps[i];

        // Update current step
        await this.exportJobRepo.update(job.jobId, {
          currentStep: step.description,
          updatedAt: new Date(),
        });

        // Execute step with timeout and retry
        try {
          await this.executeStepWithRetry(step, context);
          completedSteps.push(step);

          // Update progress
          await this.exportJobRepo.update(job.jobId, {
            stepsCompleted: i + 1,
            updatedAt: new Date(),
          });
        } catch (error) {
          // Step failed - trigger rollback
          console.error(`Step ${step.name} failed:`, error);
          await this.rollbackSteps(completedSteps, context);
          throw error;
        }
      }

      // Step 8: Mark job as completed
      await this.exportJobRepo.update(job.jobId, {
        status: 'completed' as ExportJobStatus,
        currentStep: 'Export completed successfully',
        updatedAt: new Date(),
      });
    } catch (error) {
      // Mark job as failed
      await this.exportJobRepo.update(job.jobId, {
        status: 'failed' as ExportJobStatus,
        errorMessage: error.message,
        updatedAt: new Date(),
      });
    }
  }

  /**
   * Execute step with retry logic
   */
  private async executeStepWithRetry(step: any, context: ExportContext): Promise<void> {
    let lastError: Error;

    for (let attempt = 1; attempt <= this.MAX_RETRIES; attempt++) {
      try {
        // Execute step with timeout
        await this.executeStepWithTimeout(step, context);
        return; // Success
      } catch (error) {
        lastError = error;

        if (!step.retryable || attempt === this.MAX_RETRIES) {
          throw error;
        }

        // Wait before retry (exponential backoff)
        const delayMs = Math.pow(2, attempt) * 1000;
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
    }

    throw lastError;
  }

  /**
   * Execute step with timeout protection
   */
  private async executeStepWithTimeout(step: any, context: ExportContext): Promise<void> {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Step timeout')), this.STEP_TIMEOUT_MS);
    });

    await Promise.race([step.execute(context), timeoutPromise]);
  }

  /**
   * Rollback completed steps in reverse order
   */
  private async rollbackSteps(completedSteps: any[], context: ExportContext): Promise<void> {
    const reversedSteps = [...completedSteps].reverse();

    for (const step of reversedSteps) {
      try {
        await step.rollback(context);
      } catch (error) {
        console.error(`Rollback of ${step.name} failed:`, error);
        // Continue with rollback even if one step fails
      }
    }

    // Clean up working directory
    try {
      await fs.rm(context.workingDir, { recursive: true, force: true });
    } catch (error) {
      console.error('Failed to clean up working directory:', error);
    }
  }

  /**
   * Get export job status
   * @param jobId - Export job ID
   * @returns Export job record
   * @throws Error if job not found
   */
  async getExportStatus(jobId: string): Promise<ExportJob> {
    const job = await this.exportJobRepo.findById(jobId);
    if (!job) {
      throw new Error(`Export job ${jobId} not found`);
    }
    return job;
  }

  /**
   * Cancel in-progress export job
   * @param jobId - Export job ID
   * @param userId - User ID requesting cancellation
   * @throws Error if job not found or user unauthorized
   */
  async cancelExport(jobId: string, userId: string): Promise<void> {
    const job = await this.exportJobRepo.findById(jobId);
    if (!job) {
      throw new Error(`Export job ${jobId} not found`);
    }

    if (job.userId !== userId) {
      throw new Error('Unauthorized to cancel this export job');
    }

    if (job.status !== 'in_progress' && job.status !== 'pending') {
      throw new Error(`Cannot cancel job with status: ${job.status}`);
    }

    // Mark as cancelling
    await this.exportJobRepo.update(jobId, {
      status: 'cancelling' as ExportJobStatus,
      updatedAt: new Date(),
    });

    // TODO: Implement graceful cancellation (stop current step)
    // For now, rollback will happen when step completes

    // Mark as cancelled
    await this.exportJobRepo.update(jobId, {
      status: 'cancelled' as ExportJobStatus,
      updatedAt: new Date(),
    });
  }

  /**
   * Validate user has export permission
   */
  private async validateExportPermission(userId: string): Promise<void> {
    // TODO: Integrate with AuthService to check permissions
    // For now, assume all users have permission
  }
}
```

**Why This Implementation:**

- Asynchronous execution with `executeExport()` (non-blocking API response)
- Strategy pattern decouples orchestrator from tool-specific logic
- Sequential step execution with progress tracking after each step
- Retry logic with exponential backoff for transient failures
- Timeout protection prevents hanging exports
- Rollback mechanism ensures cleanup on failure
- Comprehensive error logging with context

### Testing Strategy

```typescript
// apps/api/tests/unit/services/export-orchestrator.service.test.ts
import { ExportOrchestratorService } from '../../../src/services/export-orchestrator.service';
import { ToolRegistryRepository } from '../../../src/repositories/tool-registry.repository';
import { ExportJobRepository } from '../../../src/repositories/export-job.repository';

describe('ExportOrchestratorService', () => {
  let service: ExportOrchestratorService;
  let toolRegistryRepo: jest.Mocked<ToolRegistryRepository>;
  let exportJobRepo: jest.Mocked<ExportJobRepository>;

  beforeEach(() => {
    toolRegistryRepo = {
      findById: jest.fn(),
    } as any;

    exportJobRepo = {
      create: jest.fn(),
      update: jest.fn(),
      findById: jest.fn(),
    } as any;

    service = new ExportOrchestratorService(toolRegistryRepo, exportJobRepo);
  });

  describe('startExport', () => {
    it('should create export job and return job record', async () => {
      const mockTool = {
        toolId: 'tool-123',
        toolName: 'Test Form',
        toolType: 'forms',
      };

      const mockJob = {
        jobId: 'job-abc',
        toolId: 'tool-123',
        userId: 'user-456',
        status: 'pending',
      };

      toolRegistryRepo.findById.mockResolvedValue(mockTool);
      exportJobRepo.create.mockResolvedValue(mockJob);

      const result = await service.startExport('tool-123', 'user-456');

      expect(result).toEqual(mockJob);
      expect(toolRegistryRepo.findById).toHaveBeenCalledWith('tool-123');
      expect(exportJobRepo.create).toHaveBeenCalled();
    });

    it('should throw error if tool not found', async () => {
      toolRegistryRepo.findById.mockResolvedValue(null);

      await expect(service.startExport('tool-invalid', 'user-456')).rejects.toThrow(
        'Tool tool-invalid not found'
      );
    });
  });

  describe('getExportStatus', () => {
    it('should return export job record', async () => {
      const mockJob = {
        jobId: 'job-abc',
        status: 'in_progress',
        stepsCompleted: 3,
        stepsTotal: 8,
      };

      exportJobRepo.findById.mockResolvedValue(mockJob);

      const result = await service.getExportStatus('job-abc');

      expect(result).toEqual(mockJob);
      expect(exportJobRepo.findById).toHaveBeenCalledWith('job-abc');
    });

    it('should throw error if job not found', async () => {
      exportJobRepo.findById.mockResolvedValue(null);

      await expect(service.getExportStatus('job-invalid')).rejects.toThrow(
        'Export job job-invalid not found'
      );
    });
  });

  describe('cancelExport', () => {
    it('should cancel in-progress export job', async () => {
      const mockJob = {
        jobId: 'job-abc',
        userId: 'user-456',
        status: 'in_progress',
      };

      exportJobRepo.findById.mockResolvedValue(mockJob);
      exportJobRepo.update.mockResolvedValue(undefined);

      await service.cancelExport('job-abc', 'user-456');

      expect(exportJobRepo.update).toHaveBeenCalledWith('job-abc', {
        status: 'cancelling',
        updatedAt: expect.any(Date),
      });

      expect(exportJobRepo.update).toHaveBeenCalledWith('job-abc', {
        status: 'cancelled',
        updatedAt: expect.any(Date),
      });
    });

    it('should throw error if user unauthorized', async () => {
      const mockJob = {
        jobId: 'job-abc',
        userId: 'user-456',
        status: 'in_progress',
      };

      exportJobRepo.findById.mockResolvedValue(mockJob);

      await expect(service.cancelExport('job-abc', 'user-789')).rejects.toThrow(
        'Unauthorized to cancel this export job'
      );
    });
  });
});
```

### Package Structure Example

```
/tmp/exports/job-abc-123/
├── Dockerfile
├── docker-compose.yml
├── .env.example
├── package.json
├── tsconfig.json
├── README.md
├── src/
│   ├── server.ts
│   ├── controllers/
│   │   └── forms.controller.ts
│   ├── repositories/
│   │   └── forms.repository.ts
│   └── schemas/
│       └── form-schema.json
├── prisma/
│   ├── schema.prisma
│   └── migrations/
│       └── 001_init.sql
└── data/
    ├── form-schemas/
    │   └── customer-registration.json
    └── form-submissions/
        └── submissions.csv
```

**Package Contents:**

- **Dockerfile:** Multi-stage build for production deployment
- **docker-compose.yml:** PostgreSQL + API service configuration
- **.env.example:** Required environment variables template
- **package.json:** Dependencies and scripts for standalone service
- **src/:** Express.js TypeScript source code
- **prisma/:** Database schema and migrations
- **data/:** Exported tool data (schemas, submissions, configs)

---

## Testing

### Unit Test Examples

```bash
# Run all export orchestrator tests
npm --workspace=apps/api run test -- --testPathPattern="export-orchestrator" --watch=false

# Run specific test suite
npm --workspace=apps/api run test -- --testPathPattern="export-orchestrator.service.test.ts"

# Run with coverage
npm --workspace=apps/api run test:coverage -- --testPathPattern="export-orchestrator"
```

### Manual Test Script

```bash
#!/bin/bash
# tests/manual/test-export-orchestrator.sh

echo "=== Export Orchestrator Manual Test ==="

# Step 1: Start backend API
npm --workspace=apps/api run dev &
API_PID=$!
sleep 3

# Step 2: Login and get JWT token
TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@example.com","password":"Admin123!@#"}' \
  | jq -r '.accessToken')

echo "Logged in with token: ${TOKEN:0:20}..."

# Step 3: Start export job
JOB_RESPONSE=$(curl -s -X POST http://localhost:3000/api/tool-registry/tools/tool-forms-123/export \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json")

JOB_ID=$(echo $JOB_RESPONSE | jq -r '.jobId')
echo "Started export job: $JOB_ID"

# Step 4: Poll job status every 2 seconds
for i in {1..30}; do
  STATUS_RESPONSE=$(curl -s -X GET http://localhost:3000/api/tool-registry/export-jobs/$JOB_ID \
    -H "Authorization: Bearer $TOKEN")

  STATUS=$(echo $STATUS_RESPONSE | jq -r '.status')
  PROGRESS=$(echo $STATUS_RESPONSE | jq -r '.stepsCompleted')
  TOTAL=$(echo $STATUS_RESPONSE | jq -r '.stepsTotal')
  CURRENT_STEP=$(echo $STATUS_RESPONSE | jq -r '.currentStep')

  echo "[$i] Status: $STATUS, Progress: $PROGRESS/$TOTAL, Step: $CURRENT_STEP"

  if [ "$STATUS" == "completed" ] || [ "$STATUS" == "failed" ]; then
    break
  fi

  sleep 2
done

# Step 5: Cleanup
kill $API_PID
echo "Test complete"
```

---

## Dependencies

### Blocked By:

- Story 30.1.2: Tool Registry Repository (toolId validation)
- Story 33.1.2: Export Jobs Database Schema (job persistence)

### Blocks:

- Story 33.1.3: Export Job Status Tracking (uses ExportOrchestratorService)
- Story 33.2.1: Export Package Download (requires completed export packages)

### Related:

- Story 32.2.4: Export Progress Modal (consumes job status API)
- Story 30.1.1: Tool Registry Database Schema (tool metadata)

---

## QA Gate

**Gate File:** `docs/qa/gates/33.1.1-export-orchestrator-service.yml`

### Quality Criteria (Weighted):

| Criterion          | Weight | Target                       | Validation Method    |
| ------------------ | ------ | ---------------------------- | -------------------- |
| Unit Test Coverage | 25%    | ≥90% statements/branches     | Jest coverage report |
| Integration Tests  | 20%    | All strategies tested        | Manual review        |
| Code Quality       | 15%    | ESLint + TypeScript strict   | Linting report       |
| Error Handling     | 15%    | All error paths tested       | Unit tests           |
| Documentation      | 10%    | JSDoc for all public methods | Code review          |
| Rollback Logic     | 10%    | All steps have rollback()    | Manual testing       |
| Performance        | 5%     | Export completes < 2 min     | Performance test     |

**Minimum Score:** 90/100 to pass gate

---

## Notes

### ★ Insight ─────────────────────────────────────

**Strategy Pattern Benefits:**

- **Open/Closed Principle:** Add new tool types without modifying orchestrator
- **Single Responsibility:** Each strategy handles one tool type's export logic
- **Testability:** Mock strategies for orchestrator tests, test strategies in isolation

**Step Pattern Benefits:**

- **Atomicity:** Each step is independently rollbackable
- **Progress Tracking:** Steps enable granular progress reporting
- **Fault Tolerance:** Failed steps don't corrupt entire export (rollback restores state)

**Why Async Execution:**

- `startExport()` returns immediately (non-blocking API)
- Export executes in background (long-running operation)
- Frontend polls `getExportStatus()` for real-time updates

─────────────────────────────────────────────────

**Story State:** Draft **Last Updated:** 2025-10-24 **Next Review:** After implementation completion
