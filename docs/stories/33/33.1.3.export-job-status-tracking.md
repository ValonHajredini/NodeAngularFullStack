# Story 33.1.3: Export Job Status Tracking

**Epic:** 33.1 Export Core Infrastructure (23 pts) **Story Points:** 5 **Priority:** Critical
**Status:** Approved **Created:** 2025-10-24

---

## Description

Implement REST API endpoints for export job status tracking, enabling frontend clients to initiate
exports, poll job progress, and cancel in-progress exports. Integrate with ExportOrchestratorService
and ExportJobRepository to provide real-time export status updates with comprehensive error
handling, validation, and rate limiting.

---

## Acceptance Criteria

### API Endpoints

- [ ] `POST /api/tool-registry/tools/:toolId/export` - Start export job
- [ ] `GET /api/tool-registry/export-jobs/:jobId` - Get export job status
- [ ] `POST /api/tool-registry/export-jobs/:jobId/cancel` - Cancel export job
- [ ] `GET /api/tool-registry/export-jobs` - List user's export jobs (optional)
- [ ] All endpoints require JWT authentication
- [ ] All endpoints return JSON responses
- [ ] All endpoints include proper HTTP status codes (200, 201, 400, 401, 403, 404, 500)

### Start Export Endpoint

- [ ] Validates toolId exists in tool registry
- [ ] Validates user has export permission (admin or 'export' permission)
- [ ] Creates export job record with status 'pending'
- [ ] Starts asynchronous export orchestration
- [ ] Returns job record with jobId immediately (non-blocking)
- [ ] HTTP 201 Created on success
- [ ] HTTP 404 if tool not found
- [ ] HTTP 403 if user lacks permission

### Get Status Endpoint

- [ ] Retrieves export job by jobId
- [ ] Returns current status, progress, and metadata
- [ ] Includes created_at, updated_at, started_at, completed_at timestamps
- [ ] Includes error_message if status is 'failed'
- [ ] HTTP 200 OK on success
- [ ] HTTP 404 if job not found
- [ ] Rate limited to 10 requests per second per client

### Cancel Export Endpoint

- [ ] Validates job exists and is in 'pending' or 'in_progress' status
- [ ] Validates requesting user is job creator or admin
- [ ] Triggers graceful cancellation via ExportOrchestratorService
- [ ] Updates job status to 'cancelling' immediately
- [ ] HTTP 200 OK on success
- [ ] HTTP 403 if user unauthorized
- [ ] HTTP 409 Conflict if job cannot be cancelled (already completed/failed)

### Validation

- [ ] toolId validated as UUID format
- [ ] jobId validated as UUID format
- [ ] Input validation errors return 400 Bad Request with details
- [ ] Use express-validator for request validation
- [ ] Validate request body fields (if any)

### Error Handling

- [ ] All errors return structured JSON response with message and code
- [ ] Orchestrator errors propagated to API response
- [ ] Database errors caught and logged (don't expose internals)
- [ ] Unexpected errors return 500 Internal Server Error
- [ ] All errors logged with request context (userId, jobId, toolId)

### Security

- [ ] JWT authentication middleware applied to all endpoints
- [ ] Permission checks for export operations (admin or export permission)
- [ ] User can only access their own export jobs (unless admin)
- [ ] Rate limiting prevents polling abuse (10 req/sec per client)
- [ ] Input sanitization to prevent SQL injection (use parameterized queries)

### Testing

- [ ] Integration tests for all endpoints (≥85% coverage)
- [ ] Test start export with valid and invalid toolId
- [ ] Test get status with valid and invalid jobId
- [ ] Test cancel export with valid and invalid jobId
- [ ] Test permission checks (admin, user with permission, user without permission)
- [ ] Test rate limiting on get status endpoint
- [ ] Test error scenarios (network errors, database errors)

---

## Tasks

### 1. Create Export Routes File

**Estimated:** 1 hour **Dependencies:** Story 33.1.1 (ExportOrchestratorService) **Description:**
Define routes for export endpoints.

**Subtasks:**

1. Create `apps/api/src/routes/export.routes.ts`
2. Import Express Router
3. Define POST /tools/:toolId/export route
4. Define GET /export-jobs/:jobId route
5. Define POST /export-jobs/:jobId/cancel route
6. Apply authentication middleware to all routes
7. Apply rate limiting to GET /export-jobs/:jobId
8. Export router from routes file
9. Import router in main app.ts
10. Mount router at `/api/tool-registry` path

### 2. Create Export Controller

**Estimated:** 4 hours **Dependencies:** Task 1 **Description:** Implement controller methods for
export operations.

**Subtasks:**

1. Create `apps/api/src/controllers/export.controller.ts`
2. Inject ExportOrchestratorService via constructor
3. Implement `startExport(req, res, next)` method
4. Implement `getExportStatus(req, res, next)` method
5. Implement `cancelExport(req, res, next)` method
6. Add JSDoc comments to all methods
7. Add error handling with try-catch blocks
8. Return structured JSON responses
9. Set appropriate HTTP status codes
10. Export controller class

### 3. Implement Start Export Endpoint Logic

**Estimated:** 3 hours **Dependencies:** Task 2 **Description:** Handle export job creation
requests.

**Subtasks:**

1. Extract toolId from URL parameters (req.params.toolId)
2. Extract userId from JWT payload (req.user.userId)
3. Validate user has export permission via AuthService
4. Call ExportOrchestratorService.startExport(toolId, userId)
5. Return 201 Created with job record in response body
6. Handle tool not found error (404)
7. Handle permission denied error (403)
8. Handle orchestrator errors (500)
9. Log successful export start with userId and toolId
10. Add integration test for start export endpoint

### 4. Implement Get Status Endpoint Logic

**Estimated:** 2 hours **Dependencies:** Task 2 **Description:** Handle export job status polling
requests.

**Subtasks:**

1. Extract jobId from URL parameters (req.params.jobId)
2. Call ExportOrchestratorService.getExportStatus(jobId)
3. Return 200 OK with job record in response body
4. Handle job not found error (404)
5. Calculate progress percentage if not stored (stepsCompleted / stepsTotal \* 100)
6. Include all job fields in response (status, progress, timestamps)
7. Handle orchestrator errors (500)
8. Log status retrieval with jobId
9. Add caching headers (Cache-Control: no-cache)
10. Add integration test for get status endpoint

### 5. Implement Cancel Export Endpoint Logic

**Estimated:** 3 hours **Dependencies:** Task 2 **Description:** Handle export job cancellation
requests.

**Subtasks:**

1. Extract jobId from URL parameters (req.params.jobId)
2. Extract userId from JWT payload (req.user.userId)
3. Retrieve job record from ExportOrchestratorService.getExportStatus(jobId)
4. Validate requesting user is job creator or admin
5. Validate job status is 'pending' or 'in_progress'
6. Call ExportOrchestratorService.cancelExport(jobId, userId)
7. Return 200 OK with cancellation message
8. Handle job not found error (404)
9. Handle unauthorized error (403)
10. Handle invalid status error (409 Conflict)

### 6. Add Input Validation

**Estimated:** 2 hours **Dependencies:** Task 1 **Description:** Validate request parameters and
body with express-validator.

**Subtasks:**

1. Create `apps/api/src/validators/export.validator.ts`
2. Add validation for toolId (must be UUID)
3. Add validation for jobId (must be UUID)
4. Create validation middleware for start export endpoint
5. Create validation middleware for get status endpoint
6. Create validation middleware for cancel export endpoint
7. Apply validation middleware to routes
8. Return 400 Bad Request with validation errors
9. Add unit tests for validators
10. Document validation rules in JSDoc

### 7. Implement Permission Checks

**Estimated:** 2 hours **Dependencies:** Task 2 **Description:** Verify user has export permission
before allowing export operations.

**Subtasks:**

1. Create `apps/api/src/middleware/export-permission.middleware.ts`
2. Extract user role and permissions from JWT payload (req.user)
3. Allow admin users to export any tool
4. Allow users with 'export' permission to export tools
5. Deny users without permission (403 Forbidden)
6. Apply middleware to start export endpoint
7. Log permission check results
8. Add unit tests for permission middleware
9. Document permission requirements in JSDoc
10. Update API documentation with permission rules

### 8. Add Rate Limiting for Status Endpoint

**Estimated:** 2 hours **Dependencies:** Task 4 **Description:** Prevent abuse of status polling
endpoint.

**Subtasks:**

1. Install express-rate-limit package (`npm install express-rate-limit`)
2. Create rate limiter instance with 10 requests per second limit
3. Apply rate limiter to GET /export-jobs/:jobId endpoint
4. Return 429 Too Many Requests when limit exceeded
5. Include Retry-After header in 429 response
6. Add per-client rate limiting (by IP address or userId)
7. Log rate limit violations
8. Test rate limiting with rapid requests
9. Document rate limits in API documentation
10. Add rate limit configuration to environment variables

### 9. Implement Error Response Format

**Estimated:** 1 hour **Dependencies:** Task 2 **Description:** Standardize error responses across
all endpoints.

**Subtasks:**

1. Create `apps/api/src/types/api-response.types.ts`
2. Define `ApiErrorResponse` interface with status, message, code properties
3. Define `ApiSuccessResponse` interface with data property
4. Create error response helper function
5. Apply error format to all controller methods
6. Include error codes for different error types (TOOL_NOT_FOUND, PERMISSION_DENIED, etc.)
7. Add timestamp to error responses
8. Add request ID to error responses (correlation)
9. Document error response format in API docs
10. Add examples of error responses in JSDoc

### 10. Add Logging and Monitoring

**Estimated:** 2 hours **Dependencies:** Task 2 **Description:** Comprehensive logging for export
operations.

**Subtasks:**

1. Log export job creation (userId, toolId, jobId)
2. Log export status polling (jobId, userId, status)
3. Log export cancellation (jobId, userId)
4. Log permission check failures
5. Log validation errors
6. Log rate limit violations
7. Log orchestrator errors with full context
8. Use structured logging (JSON format)
9. Include correlation ID in all logs (request ID)
10. Add log level configuration (debug, info, warn, error)

### 11. Integration Tests for Start Export

**Estimated:** 3 hours **Dependencies:** Task 3 **Description:** Test start export endpoint with
various scenarios.

**Subtasks:**

1. Create `apps/api/tests/integration/export-start.test.ts`
2. Setup test database with tool registry and user records
3. Test start export with valid toolId (201 Created)
4. Test start export returns jobId in response
5. Test start export with invalid toolId (404 Not Found)
6. Test start export without authentication (401 Unauthorized)
7. Test start export without permission (403 Forbidden)
8. Test admin user can start export (permission bypass)
9. Test concurrent export requests for same tool (both succeed)
10. Cleanup test data after tests

### 12. Integration Tests for Get Status

**Estimated:** 2 hours **Dependencies:** Task 4 **Description:** Test get status endpoint with
various job states.

**Subtasks:**

1. Create `apps/api/tests/integration/export-status.test.ts`
2. Create test export job in database
3. Test get status returns job record (200 OK)
4. Test get status with invalid jobId (404 Not Found)
5. Test get status with pending job (status=pending, progress=0%)
6. Test get status with in_progress job (status=in_progress, progress=50%)
7. Test get status with completed job (status=completed, progress=100%)
8. Test get status with failed job (includes error_message)
9. Test rate limiting (11 rapid requests, 11th returns 429)
10. Cleanup test data after tests

### 13. Integration Tests for Cancel Export

**Estimated:** 3 hours **Dependencies:** Task 5 **Description:** Test cancel export endpoint with
various scenarios.

**Subtasks:**

1. Create `apps/api/tests/integration/export-cancel.test.ts`
2. Create test export job in 'in_progress' status
3. Test cancel export by job creator (200 OK)
4. Test cancel export updates status to 'cancelling'
5. Test cancel export by admin (200 OK)
6. Test cancel export by different user (403 Forbidden)
7. Test cancel completed export (409 Conflict)
8. Test cancel non-existent export (404 Not Found)
9. Test cancel without authentication (401 Unauthorized)
10. Cleanup test data after tests

### 14. API Documentation with Swagger

**Estimated:** 2 hours **Dependencies:** All endpoint tasks **Description:** Document export
endpoints in Swagger/OpenAPI.

**Subtasks:**

1. Add JSDoc comments with Swagger annotations to controller
2. Document POST /tools/:toolId/export endpoint
3. Document GET /export-jobs/:jobId endpoint
4. Document POST /export-jobs/:jobId/cancel endpoint
5. Add request/response examples in JSDoc
6. Add authentication requirements (Bearer token)
7. Add error response examples (400, 401, 403, 404, 500)
8. Generate Swagger JSON specification
9. Verify endpoints appear in /api-docs UI
10. Add link to export API docs in README.md

### 15. End-to-End Test: Complete Export Flow

**Estimated:** 3 hours **Dependencies:** All previous tasks **Description:** Test complete export
workflow from start to completion.

**Subtasks:**

1. Create `apps/api/tests/e2e/export-workflow.test.ts`
2. Login as admin user and get JWT token
3. Start export job for test tool
4. Poll status endpoint every 2 seconds
5. Verify status transitions: pending → in_progress → completed
6. Verify progress percentage increases (0% → 50% → 100%)
7. Verify completed_at timestamp set on completion
8. Verify package_path populated on completion
9. Test cancellation flow: start export → cancel → verify status=cancelled
10. Cleanup test data and export packages

---

## Dev Notes

### API Endpoint Specifications

**1. Start Export Job**

```
POST /api/tool-registry/tools/:toolId/export
Authorization: Bearer <jwt_token>

Request:
- No request body required
- toolId in URL path (UUID)

Response 201 Created:
{
  "jobId": "job-abc-123",
  "toolId": "tool-forms-456",
  "userId": "user-789",
  "status": "pending",
  "stepsCompleted": 0,
  "stepsTotal": 0,
  "currentStep": "Initializing...",
  "createdAt": "2025-10-24T10:30:00Z",
  "updatedAt": "2025-10-24T10:30:00Z"
}

Response 404 Not Found:
{
  "status": "error",
  "message": "Tool tool-invalid not found",
  "code": "TOOL_NOT_FOUND",
  "timestamp": "2025-10-24T10:30:00Z"
}

Response 403 Forbidden:
{
  "status": "error",
  "message": "User does not have export permission",
  "code": "PERMISSION_DENIED",
  "timestamp": "2025-10-24T10:30:00Z"
}
```

**2. Get Export Job Status**

```
GET /api/tool-registry/export-jobs/:jobId
Authorization: Bearer <jwt_token>

Response 200 OK:
{
  "jobId": "job-abc-123",
  "toolId": "tool-forms-456",
  "userId": "user-789",
  "status": "in_progress",
  "stepsCompleted": 5,
  "stepsTotal": 8,
  "currentStep": "Generating Docker configuration...",
  "progressPercentage": 62,
  "packagePath": null,
  "packageSizeBytes": null,
  "errorMessage": null,
  "createdAt": "2025-10-24T10:30:00Z",
  "updatedAt": "2025-10-24T10:32:15Z",
  "startedAt": "2025-10-24T10:30:05Z",
  "completedAt": null
}

Response 404 Not Found:
{
  "status": "error",
  "message": "Export job job-invalid not found",
  "code": "JOB_NOT_FOUND",
  "timestamp": "2025-10-24T10:30:00Z"
}

Response 429 Too Many Requests:
{
  "status": "error",
  "message": "Rate limit exceeded. Please wait before retrying.",
  "code": "RATE_LIMIT_EXCEEDED",
  "timestamp": "2025-10-24T10:30:00Z",
  "retryAfter": 1
}
```

**3. Cancel Export Job**

```
POST /api/tool-registry/export-jobs/:jobId/cancel
Authorization: Bearer <jwt_token>

Response 200 OK:
{
  "message": "Export job cancelled successfully",
  "jobId": "job-abc-123",
  "status": "cancelling"
}

Response 403 Forbidden:
{
  "status": "error",
  "message": "Unauthorized to cancel this export job",
  "code": "UNAUTHORIZED_CANCELLATION",
  "timestamp": "2025-10-24T10:30:00Z"
}

Response 409 Conflict:
{
  "status": "error",
  "message": "Cannot cancel job with status: completed",
  "code": "INVALID_JOB_STATUS",
  "timestamp": "2025-10-24T10:30:00Z"
}
```

### Controller Implementation

```typescript
// apps/api/src/controllers/export.controller.ts
import { Request, Response, NextFunction } from 'express';
import { ExportOrchestratorService } from '../services/export-orchestrator.service';
import { AuthService } from '../services/auth.service';

/**
 * Export controller
 * Handles export job creation, status tracking, and cancellation
 */
export class ExportController {
  constructor(
    private readonly orchestratorService: ExportOrchestratorService,
    private readonly authService: AuthService
  ) {}

  /**
   * Start export job for a tool
   *
   * @route POST /api/tool-registry/tools/:toolId/export
   * @param req - Express request with toolId in params
   * @param res - Express response
   * @param next - Express next function
   * @returns 201 Created with export job record
   *
   * @swagger
   * /api/tool-registry/tools/{toolId}/export:
   *   post:
   *     summary: Start export job for a tool
   *     tags: [Export]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - in: path
   *         name: toolId
   *         required: true
   *         schema:
   *           type: string
   *           format: uuid
   *         description: Tool registry ID
   *     responses:
   *       201:
   *         description: Export job created successfully
   *       403:
   *         description: User does not have export permission
   *       404:
   *         description: Tool not found
   */
  async startExport(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { toolId } = req.params;
      const userId = req.user!.userId; // From JWT middleware

      // Verify export permission
      const hasPermission = await this.authService.hasPermission(userId, 'export');
      const isAdmin = req.user!.role === 'admin';

      if (!hasPermission && !isAdmin) {
        res.status(403).json({
          status: 'error',
          message: 'User does not have export permission',
          code: 'PERMISSION_DENIED',
          timestamp: new Date().toISOString(),
        });
        return;
      }

      // Start export job
      const job = await this.orchestratorService.startExport(toolId, userId);

      res.status(201).json(job);
    } catch (error: any) {
      if (error.message.includes('not found')) {
        res.status(404).json({
          status: 'error',
          message: error.message,
          code: 'TOOL_NOT_FOUND',
          timestamp: new Date().toISOString(),
        });
      } else {
        next(error); // Pass to error middleware
      }
    }
  }

  /**
   * Get export job status
   *
   * @route GET /api/tool-registry/export-jobs/:jobId
   * @param req - Express request with jobId in params
   * @param res - Express response
   * @param next - Express next function
   * @returns 200 OK with export job record
   *
   * @swagger
   * /api/tool-registry/export-jobs/{jobId}:
   *   get:
   *     summary: Get export job status
   *     tags: [Export]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - in: path
   *         name: jobId
   *         required: true
   *         schema:
   *           type: string
   *           format: uuid
   *         description: Export job ID
   *     responses:
   *       200:
   *         description: Export job status retrieved successfully
   *       404:
   *         description: Export job not found
   *       429:
   *         description: Rate limit exceeded
   */
  async getExportStatus(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { jobId } = req.params;

      const job = await this.orchestratorService.getExportStatus(jobId);

      // Set cache control headers (no caching for real-time data)
      res.set('Cache-Control', 'no-cache, no-store, must-revalidate');
      res.set('Pragma', 'no-cache');
      res.set('Expires', '0');

      res.status(200).json(job);
    } catch (error: any) {
      if (error.message.includes('not found')) {
        res.status(404).json({
          status: 'error',
          message: error.message,
          code: 'JOB_NOT_FOUND',
          timestamp: new Date().toISOString(),
        });
      } else {
        next(error);
      }
    }
  }

  /**
   * Cancel export job
   *
   * @route POST /api/tool-registry/export-jobs/:jobId/cancel
   * @param req - Express request with jobId in params
   * @param res - Express response
   * @param next - Express next function
   * @returns 200 OK with cancellation confirmation
   *
   * @swagger
   * /api/tool-registry/export-jobs/{jobId}/cancel:
   *   post:
   *     summary: Cancel export job
   *     tags: [Export]
   *     security:
   *       - bearerAuth: []
   *     parameters:
   *       - in: path
   *         name: jobId
   *         required: true
   *         schema:
   *           type: string
   *           format: uuid
   *         description: Export job ID
   *     responses:
   *       200:
   *         description: Export job cancelled successfully
   *       403:
   *         description: Unauthorized to cancel this job
   *       404:
   *         description: Export job not found
   *       409:
   *         description: Cannot cancel job in current status
   */
  async cancelExport(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { jobId } = req.params;
      const userId = req.user!.userId;

      // Retrieve job to check ownership and status
      const job = await this.orchestratorService.getExportStatus(jobId);

      // Verify user is job creator or admin
      const isAdmin = req.user!.role === 'admin';
      if (job.userId !== userId && !isAdmin) {
        res.status(403).json({
          status: 'error',
          message: 'Unauthorized to cancel this export job',
          code: 'UNAUTHORIZED_CANCELLATION',
          timestamp: new Date().toISOString(),
        });
        return;
      }

      // Verify job can be cancelled
      if (job.status !== 'pending' && job.status !== 'in_progress') {
        res.status(409).json({
          status: 'error',
          message: `Cannot cancel job with status: ${job.status}`,
          code: 'INVALID_JOB_STATUS',
          timestamp: new Date().toISOString(),
        });
        return;
      }

      // Cancel job
      await this.orchestratorService.cancelExport(jobId, userId);

      res.status(200).json({
        message: 'Export job cancelled successfully',
        jobId,
        status: 'cancelling',
      });
    } catch (error: any) {
      if (error.message.includes('not found')) {
        res.status(404).json({
          status: 'error',
          message: error.message,
          code: 'JOB_NOT_FOUND',
          timestamp: new Date().toISOString(),
        });
      } else {
        next(error);
      }
    }
  }
}
```

**Why This Implementation:**

- **Permission Checks:** Validates user has export permission before allowing operations
- **Error Handling:** Structured error responses with codes and timestamps
- **HTTP Status Codes:** Proper codes for success (200, 201) and errors (400, 401, 403, 404,
  409, 429)
- **Cache Headers:** Prevents caching of real-time job status data
- **Swagger Annotations:** Auto-generates API documentation

### Routes Configuration

```typescript
// apps/api/src/routes/export.routes.ts
import { Router } from 'express';
import { ExportController } from '../controllers/export.controller';
import { authMiddleware } from '../middleware/auth.middleware';
import { validateExportStart, validateJobId } from '../validators/export.validator';
import rateLimit from 'express-rate-limit';

// Create rate limiter for status endpoint
const statusRateLimiter = rateLimit({
  windowMs: 1000, // 1 second
  max: 10, // 10 requests per second
  message: {
    status: 'error',
    message: 'Rate limit exceeded. Please wait before retrying.',
    code: 'RATE_LIMIT_EXCEEDED',
  },
  standardHeaders: true,
  legacyHeaders: false,
});

export function createExportRoutes(controller: ExportController): Router {
  const router = Router();

  // All routes require authentication
  router.use(authMiddleware);

  // Start export job
  router.post('/tools/:toolId/export', validateExportStart, (req, res, next) =>
    controller.startExport(req, res, next)
  );

  // Get export job status (with rate limiting)
  router.get('/export-jobs/:jobId', statusRateLimiter, validateJobId, (req, res, next) =>
    controller.getExportStatus(req, res, next)
  );

  // Cancel export job
  router.post('/export-jobs/:jobId/cancel', validateJobId, (req, res, next) =>
    controller.cancelExport(req, res, next)
  );

  return router;
}
```

**Why This Pattern:**

- **Middleware Chain:** auth → rate limit → validation → controller
- **Factory Function:** `createExportRoutes()` accepts controller (dependency injection)
- **Rate Limiting:** Applied only to status endpoint (most frequent)
- **Validation:** Applied to all routes for input sanitization

### Validation Middleware

```typescript
// apps/api/src/validators/export.validator.ts
import { param, validationResult } from 'express-validator';
import { Request, Response, NextFunction } from 'express';

/**
 * Validate toolId parameter (UUID format)
 */
export const validateExportStart = [
  param('toolId').isUUID().withMessage('toolId must be a valid UUID'),

  (req: Request, res: Response, next: NextFunction) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        code: 'VALIDATION_ERROR',
        errors: errors.array(),
        timestamp: new Date().toISOString(),
      });
    }
    next();
  },
];

/**
 * Validate jobId parameter (UUID format)
 */
export const validateJobId = [
  param('jobId').isUUID().withMessage('jobId must be a valid UUID'),

  (req: Request, res: Response, next: NextFunction) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        code: 'VALIDATION_ERROR',
        errors: errors.array(),
        timestamp: new Date().toISOString(),
      });
    }
    next();
  },
];
```

**Why express-validator:**

- **Declarative:** Validation rules defined as middleware
- **Composable:** Chain multiple validations (isUUID, isInt, etc.)
- **Error Details:** Returns detailed validation errors to client

### Integration Test Example

```typescript
// apps/api/tests/integration/export-start.test.ts
import request from 'supertest';
import app from '../../src/app';
import { getTestJWT } from '../helpers/auth-helpers';

describe('POST /api/tool-registry/tools/:toolId/export', () => {
  let adminToken: string;
  let userToken: string;
  let toolId: string;

  beforeAll(async () => {
    // Get JWT tokens for admin and regular user
    adminToken = await getTestJWT('admin@example.com', 'Admin123!@#');
    userToken = await getTestJWT('user@example.com', 'User123!@#');

    // Get test tool ID from database
    toolId = 'tool-forms-test-123'; // Assumes seeded tool
  });

  it('should start export job with admin user (201 Created)', async () => {
    const response = await request(app)
      .post(`/api/tool-registry/tools/${toolId}/export`)
      .set('Authorization', `Bearer ${adminToken}`)
      .expect(201);

    expect(response.body).toHaveProperty('jobId');
    expect(response.body.toolId).toBe(toolId);
    expect(response.body.status).toBe('pending');
    expect(response.body.stepsCompleted).toBe(0);
  });

  it('should return 404 if tool not found', async () => {
    const response = await request(app)
      .post('/api/tool-registry/tools/invalid-tool-id/export')
      .set('Authorization', `Bearer ${adminToken}`)
      .expect(404);

    expect(response.body.code).toBe('TOOL_NOT_FOUND');
  });

  it('should return 401 without authentication', async () => {
    await request(app).post(`/api/tool-registry/tools/${toolId}/export`).expect(401);
  });

  it('should return 403 if user lacks export permission', async () => {
    const response = await request(app)
      .post(`/api/tool-registry/tools/${toolId}/export`)
      .set('Authorization', `Bearer ${userToken}`)
      .expect(403);

    expect(response.body.code).toBe('PERMISSION_DENIED');
  });
});
```

**Why Integration Tests:**

- Test real HTTP requests (not just controller logic)
- Verify middleware chain (auth → validation → controller)
- Verify status codes and response formats
- Catch integration bugs (missing middleware, wrong route paths)

---

## Testing

### Manual Test Script

```bash
#!/bin/bash
# tests/manual/test-export-api.sh

echo "=== Export API Manual Test ==="

# Step 1: Start backend API
npm --workspace=apps/api run dev &
API_PID=$!
sleep 3

# Step 2: Login and get JWT token
echo "Logging in as admin..."
TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@example.com","password":"Admin123!@#"}' \
  | jq -r '.accessToken')

echo "Token: ${TOKEN:0:20}..."

# Step 3: Start export job
echo "Starting export job..."
EXPORT_RESPONSE=$(curl -s -X POST http://localhost:3000/api/tool-registry/tools/tool-forms-123/export \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json")

JOB_ID=$(echo $EXPORT_RESPONSE | jq -r '.jobId')
echo "Export job started: $JOB_ID"
echo "Response: $EXPORT_RESPONSE" | jq .

# Step 4: Poll job status 5 times (every 2 seconds)
for i in {1..5}; do
  echo "[$i] Polling job status..."

  STATUS_RESPONSE=$(curl -s -X GET http://localhost:3000/api/tool-registry/export-jobs/$JOB_ID \
    -H "Authorization: Bearer $TOKEN")

  STATUS=$(echo $STATUS_RESPONSE | jq -r '.status')
  PROGRESS=$(echo $STATUS_RESPONSE | jq -r '.progressPercentage')
  CURRENT_STEP=$(echo $STATUS_RESPONSE | jq -r '.currentStep')

  echo "    Status: $STATUS, Progress: $PROGRESS%, Step: $CURRENT_STEP"

  if [ "$STATUS" == "completed" ] || [ "$STATUS" == "failed" ]; then
    break
  fi

  sleep 2
done

# Step 5: Test cancellation (if still in progress)
if [ "$STATUS" == "in_progress" ] || [ "$STATUS" == "pending" ]; then
  echo "Cancelling export job..."

  CANCEL_RESPONSE=$(curl -s -X POST http://localhost:3000/api/tool-registry/export-jobs/$JOB_ID/cancel \
    -H "Authorization: Bearer $TOKEN")

  echo "Cancel response: $CANCEL_RESPONSE" | jq .
fi

# Step 6: Cleanup
kill $API_PID
echo "Test complete"
```

---

## Dependencies

### Blocked By:

- Story 33.1.1: Export Orchestrator Service (service methods)
- Story 33.1.2: Export Jobs Database Schema (database persistence)

### Blocks:

- Story 32.2.4: Export Progress Modal (consumes these APIs)
- Story 33.2.1: Export Package Download (requires job completion)

### Related:

- Story 30.1.2: Tool Registry Repository (tool validation)

---

## QA Gate

**Gate File:** `docs/qa/gates/33.1.3-export-job-status-tracking.yml`

### Quality Criteria (Weighted):

| Criterion                 | Weight | Target                   | Validation Method |
| ------------------------- | ------ | ------------------------ | ----------------- |
| Integration Test Coverage | 30%    | ≥85% endpoints tested    | Jest coverage     |
| API Documentation         | 20%    | All endpoints documented | Swagger UI review |
| Error Handling            | 15%    | All error paths tested   | Manual testing    |
| Permission Checks         | 15%    | RBAC enforced            | Security tests    |
| Rate Limiting             | 10%    | 10 req/sec enforced      | Load tests        |
| Input Validation          | 10%    | All inputs validated     | Validation tests  |

**Minimum Score:** 90/100 to pass gate

---

## Notes

### ★ Insight ─────────────────────────────────────

**REST API Design Principles:**

- **Resource-Oriented:** URLs represent resources (`/tools/:toolId/export`, `/export-jobs/:jobId`)
- **HTTP Verbs:** POST for creation/actions, GET for retrieval (semantic correctness)
- **Status Codes:** 201 Created, 200 OK, 404 Not Found, 403 Forbidden (proper HTTP semantics)

**Rate Limiting Strategy:**

- **Why Only Status Endpoint:** Polling is most frequent operation (every 2 seconds)
- **10 req/sec Limit:** Allows polling but prevents abuse (600 requests per minute)
- **Per-Client:** Rate limit per IP or userId (not global)

**Permission Model:**

- **Admin Bypass:** Admins can export any tool (full access)
- **export Permission:** Regular users need explicit permission (RBAC)
- **Job Ownership:** Only job creator or admin can cancel (prevents unauthorized cancellations)

─────────────────────────────────────────────────

**Story State:** Draft **Last Updated:** 2025-10-24 **Next Review:** After implementation completion
