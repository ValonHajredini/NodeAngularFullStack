# Story 33.1.4: Pre-flight Validation

**Epic:** 33.1 Export Core Infrastructure (23 pts) **Story Points:** 5 **Priority:** High
**Status:** Draft **Created:** 2025-10-24

---

## Description

Implement comprehensive pre-flight validation system to verify tool data integrity, system
readiness, and resource availability before initiating export jobs. Prevent export failures by
detecting issues early (missing data, insufficient disk space, broken dependencies) and provide
detailed validation reports to users.

---

## Acceptance Criteria

### Validation Framework

- [ ] Create `PreFlightValidator` service in `apps/api/src/services/pre-flight-validator.service.ts`
- [ ] Implement validation pipeline with ordered validation steps
- [ ] Each validation step returns success/failure with detailed messages
- [ ] Validation executed before `ExportOrchestratorService.startExport()`
- [ ] Failed validations prevent export job creation
- [ ] Validation results returned to client with HTTP 422 Unprocessable Entity

### Tool Data Validation

- [ ] Validate tool exists in tool registry
- [ ] Validate tool status is 'active' (inactive tools cannot be exported)
- [ ] Validate tool type is supported (forms, workflows, themes)
- [ ] Validate tool metadata is complete (no null required fields)
- [ ] Validate tool references exist (formSchemaId, workflowId, themeId)
- [ ] Validate tool manifest is valid JSON

### Database Integrity Checks

- [ ] For forms: Validate form schema exists in `form_schemas` table
- [ ] For forms: Validate form has at least 1 field defined
- [ ] For forms: Check if form has submissions (warning if zero)
- [ ] For workflows: Validate workflow definition exists
- [ ] For themes: Validate theme configuration exists
- [ ] Check foreign key integrity (no orphaned references)

### System Resource Checks

- [ ] Check available disk space (minimum 500MB required)
- [ ] Check temporary directory exists and is writable (`/tmp/exports/`)
- [ ] Validate export package storage directory accessible
- [ ] Check database connection pool has available connections
- [ ] Verify no concurrent export for same tool (optional: allow concurrent)

### Dependency Validation

- [ ] Check required Node.js packages installed (express, pg, etc.)
- [ ] Validate Docker is available if Docker export enabled
- [ ] Check npm/yarn available for package generation
- [ ] Validate tar command available for archive creation
- [ ] Check external service connectivity (if required)

### Configuration Validation

- [ ] Validate environment variables are set (DATABASE_URL, etc.)
- [ ] Check export configuration is valid (timeout, max retries)
- [ ] Validate strategy configuration for tool type
- [ ] Check template files exist for boilerplate generation
- [ ] Verify export settings are within limits (max package size)

### Validation Report

- [ ] Return structured validation report with all check results
- [ ] Include validation severity (error, warning, info)
- [ ] Errors prevent export, warnings allow export with notice
- [ ] Provide actionable error messages (how to fix)
- [ ] Include estimated export duration based on tool complexity

### API Integration

- [ ] Add `POST /api/tool-registry/tools/:toolId/export/validate` endpoint
- [ ] Validation endpoint accessible to authenticated users
- [ ] Returns validation report without creating export job
- [ ] Frontend can call validation before showing export modal
- [ ] Validation cached for 5 minutes per tool (performance)

### Testing

- [ ] Unit tests for each validation step (≥90% coverage)
- [ ] Integration tests with real tool data
- [ ] Test validation prevents invalid exports
- [ ] Test validation report format
- [ ] Test validation caching behavior

---

## Tasks

### 1. Create PreFlightValidator Service

**Estimated:** 3 hours **Dependencies:** Story 33.1.1 (ExportOrchestratorService) **Description:**
Implement validation pipeline framework.

**Subtasks:**

1. Create `apps/api/src/services/pre-flight-validator.service.ts`
2. Define `ValidationResult` interface (success, errors, warnings, info)
3. Define `ValidationStep` interface (name, validate(), severity)
4. Implement validation pipeline executor (runs steps sequentially)
5. Add dependency injection for repositories (ToolRegistry, Forms, etc.)
6. Implement `validate(toolId)` method returning ValidationResult
7. Add JSDoc documentation for all methods
8. Export service from `apps/api/src/services/index.ts`
9. Create shared types in `packages/shared/src/types/validation.types.ts`
10. Build shared package (`npm run build:shared`)

### 2. Implement Tool Existence Validation

**Estimated:** 1 hour **Dependencies:** Task 1 **Description:** Validate tool exists and is
exportable.

**Subtasks:**

1. Create `validateToolExists` step
2. Query ToolRegistryRepository for tool by toolId
3. Return error if tool not found
4. Check tool status is 'active'
5. Return warning if tool status is 'inactive' (not error)
6. Validate tool type is in supported list (forms, workflows, themes)
7. Return error if tool type unsupported
8. Add unit test for tool existence validation
9. Add unit test for inactive tool (warning)
10. Add unit test for unsupported tool type (error)

### 3. Implement Tool Data Completeness Validation

**Estimated:** 2 hours **Dependencies:** Task 2 **Description:** Validate tool metadata is complete
and valid.

**Subtasks:**

1. Create `validateToolDataCompleteness` step
2. Check tool name is not null or empty
3. Check tool metadata object exists
4. For forms: Validate `formSchemaId` exists in metadata
5. For workflows: Validate `workflowId` exists in metadata
6. For themes: Validate `themeId` exists in metadata
7. Validate tool manifest is valid JSON (if present)
8. Check required fields based on tool type
9. Return detailed error for each missing field
10. Add unit tests for each validation rule

### 4. Implement Database Integrity Checks

**Estimated:** 3 hours **Dependencies:** Task 3 **Description:** Validate referenced data exists in
database.

**Subtasks:**

1. Create `validateDatabaseIntegrity` step
2. For forms: Query `form_schemas` table for formSchemaId
3. For forms: Return error if form schema not found
4. For forms: Count fields in form schema
5. For forms: Return error if field count is 0
6. For forms: Count submissions for form
7. For forms: Return warning if submission count is 0 (not error)
8. For workflows: Query workflows table for workflowId
9. For themes: Query themes table for themeId
10. Add integration tests with real database

### 5. Implement System Resource Checks

**Estimated:** 3 hours **Dependencies:** Task 1 **Description:** Validate system has sufficient
resources for export.

**Subtasks:**

1. Create `validateSystemResources` step
2. Check available disk space using `fs.statfs()` (Node.js)
3. Return error if available space < 500MB
4. Check `/tmp/exports/` directory exists
5. Create directory if doesn't exist (`fs.mkdir()`)
6. Check directory is writable (`fs.access()` with W_OK)
7. Return error if directory not writable
8. Check database connection pool status
9. Return warning if pool is near capacity (>80% used)
10. Add unit tests with mocked filesystem calls

### 6. Implement Dependency Validation

**Estimated:** 2 hours **Dependencies:** Task 1 **Description:** Validate required external
dependencies are available.

**Subtasks:**

1. Create `validateDependencies` step
2. Check tar command available (`which tar` or `tar --version`)
3. Return error if tar not found
4. Check npm available (`npm --version`)
5. Return warning if npm not found (only needed for package.json generation)
6. Check Docker available if Docker export enabled (`docker --version`)
7. Return info if Docker not found but not required
8. Validate Node.js version meets minimum requirement (>= 18)
9. Add timeout for dependency checks (max 2 seconds per check)
10. Add unit tests with mocked `child_process.exec()`

### 7. Implement Configuration Validation

**Estimated:** 2 hours **Dependencies:** Task 1 **Description:** Validate export configuration and
environment.

**Subtasks:**

1. Create `validateConfiguration` step
2. Check `DATABASE_URL` environment variable is set
3. Check `EXPORT_TEMP_DIR` environment variable (default: /tmp/exports/)
4. Validate export timeout configuration (default: 300000ms)
5. Check max retries configuration (default: 3)
6. Validate max export package size (default: 100MB)
7. Check strategy exists for tool type
8. Validate template directory exists for boilerplate generation
9. Return error for critical missing config (DATABASE_URL)
10. Add unit tests for configuration validation

### 8. Create Validation Report Builder

**Estimated:** 2 hours **Dependencies:** Tasks 2-7 **Description:** Aggregate validation results
into structured report.

**Subtasks:**

1. Create `ValidationReportBuilder` class
2. Implement `addError(message, field)` method
3. Implement `addWarning(message, field)` method
4. Implement `addInfo(message)` method
5. Implement `build()` method returning ValidationResult
6. Calculate overall validation status (passed/failed)
7. Group errors by validation step
8. Include validation timestamp in report
9. Add estimated export duration based on tool complexity
10. Add unit tests for report builder

### 9. Integrate Validation into ExportOrchestratorService

**Estimated:** 2 hours **Dependencies:** Task 8 **Description:** Call pre-flight validation before
starting export.

**Subtasks:**

1. Inject PreFlightValidator into ExportOrchestratorService
2. Call `validator.validate(toolId)` in `startExport()` method
3. Check validation result status before creating job
4. Throw ValidationError if validation failed
5. Include validation errors in error response
6. Log validation failures with toolId and userId
7. Allow export to proceed if only warnings (no errors)
8. Log warnings but don't block export
9. Update ExportOrchestratorService unit tests
10. Add integration test for validation preventing export

### 10. Create Validation API Endpoint

**Estimated:** 2 hours **Dependencies:** Task 9 **Description:** Expose validation endpoint for
frontend pre-checks.

**Subtasks:**

1. Add route `POST /api/tool-registry/tools/:toolId/export/validate`
2. Create `validateExport()` method in ExportController
3. Call PreFlightValidator.validate(toolId)
4. Return validation report with HTTP 200 (validation ran successfully)
5. Return HTTP 422 if validation has errors (but include report)
6. Apply authentication middleware to validation endpoint
7. Add rate limiting (5 requests per minute per user)
8. Cache validation results for 5 minutes per tool
9. Add unit tests for validation endpoint
10. Add integration test for validation API

### 11. Implement Validation Caching

**Estimated:** 2 hours **Dependencies:** Task 10 **Description:** Cache validation results to reduce
redundant checks.

**Subtasks:**

1. Install node-cache package (`npm install node-cache`)
2. Create validation cache instance (5 minute TTL)
3. Generate cache key from toolId and validation version
4. Check cache before running validation
5. Return cached result if exists and not expired
6. Store validation result in cache after successful validation
7. Invalidate cache when tool data changes
8. Add cache statistics logging (hit rate)
9. Add unit tests for caching behavior
10. Document caching strategy in dev notes

### 12. Unit Tests for Validation Steps

**Estimated:** 4 hours **Dependencies:** Tasks 2-7 **Description:** Comprehensive unit tests for
each validation step.

**Subtasks:**

1. Create `apps/api/tests/unit/services/pre-flight-validator.service.test.ts`
2. Mock all repository dependencies
3. Test tool existence validation (pass/fail scenarios)
4. Test tool data completeness validation (missing fields)
5. Test database integrity checks (missing references)
6. Test system resource checks (low disk space)
7. Test dependency validation (missing tar command)
8. Test configuration validation (missing env vars)
9. Test validation pipeline executes all steps
10. Achieve ≥90% test coverage for validator service

### 13. Integration Tests for Validation

**Estimated:** 3 hours **Dependencies:** Task 12 **Description:** Test validation with real database
and filesystem.

**Subtasks:**

1. Create `apps/api/tests/integration/pre-flight-validation.test.ts`
2. Setup test database with tool registry and form data
3. Test validation passes for valid tool
4. Test validation fails for tool with missing form schema
5. Test validation fails for tool with insufficient disk space (mock)
6. Test validation returns warnings for zero submissions
7. Test validation report includes all check results
8. Test validation caching works correctly
9. Test validation endpoint returns 422 for invalid tool
10. Cleanup test data after tests

### 14. Frontend Integration: Validation UI

**Estimated:** 3 hours **Dependencies:** Task 10 **Description:** Display validation results in
export modal (optional enhancement).

**Subtasks:**

1. Add `validateBeforeExport()` method to ExportJobService (frontend)
2. Call validation API before opening export progress modal
3. Display validation errors in ConfirmDialog
4. Show list of validation errors with icons (red X)
5. Show list of warnings with icons (yellow warning)
6. Disable "Start Export" button if validation has errors
7. Allow export if only warnings (show "Continue Anyway" option)
8. Add loading spinner during validation check
9. Add unit tests for validation UI component
10. Update story 32.2.4 dev notes with validation integration

### 15. Documentation and Examples

**Estimated:** 2 hours **Dependencies:** All previous tasks **Description:** Document validation
system and provide examples.

**Subtasks:**

1. Create `docs/architecture/pre-flight-validation.md`
2. Document validation pipeline architecture
3. List all validation steps with descriptions
4. Provide example validation report JSON
5. Document how to add new validation steps
6. Add troubleshooting guide for common validation errors
7. Document validation caching strategy
8. Add validation API endpoint to Swagger docs
9. Update ExportOrchestratorService JSDoc with validation flow
10. Add validation examples to root README.md

---

## Dev Notes

### Validation Pipeline Architecture

```
┌─────────────────────────────────────────────────┐
│         PreFlightValidator.validate()           │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────┐
│  Step 1: Tool Existence Validation             │
│  - Check tool exists in registry               │
│  - Verify tool status is 'active'              │
│  - Confirm tool type is supported              │
└────────────────┬───────────────────────────────┘
                 │ (pass)
                 ▼
┌────────────────────────────────────────────────┐
│  Step 2: Tool Data Completeness               │
│  - Validate required metadata fields           │
│  - Check tool manifest is valid JSON           │
│  - Verify tool references (formSchemaId, etc.) │
└────────────────┬───────────────────────────────┘
                 │ (pass)
                 ▼
┌────────────────────────────────────────────────┐
│  Step 3: Database Integrity Checks             │
│  - Verify referenced schemas exist             │
│  - Check form has fields defined               │
│  - Count submissions (warning if zero)         │
└────────────────┬───────────────────────────────┘
                 │ (pass)
                 ▼
┌────────────────────────────────────────────────┐
│  Step 4: System Resource Checks                │
│  - Check available disk space (>500MB)         │
│  - Verify temp directory writable              │
│  - Check database connection pool              │
└────────────────┬───────────────────────────────┘
                 │ (pass)
                 ▼
┌────────────────────────────────────────────────┐
│  Step 5: Dependency Validation                 │
│  - Check tar command available                 │
│  - Verify npm installed                        │
│  - Validate Docker available (if needed)       │
└────────────────┬───────────────────────────────┘
                 │ (pass)
                 ▼
┌────────────────────────────────────────────────┐
│  Step 6: Configuration Validation              │
│  - Check environment variables                 │
│  - Validate export settings                    │
│  - Verify template files exist                 │
└────────────────┬───────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────┐
│         Generate Validation Report             │
│  - Aggregate all check results                 │
│  - Determine overall status (pass/fail)        │
│  - Group errors, warnings, info                │
└────────────────────────────────────────────────┘
```

**Why Sequential Pipeline:**

- Early exit on critical failures (tool not found → no need to check disk space)
- Ordered by severity (data validation before resource checks)
- Fail fast for better user experience

### PreFlightValidator Implementation

```typescript
// apps/api/src/services/pre-flight-validator.service.ts
import { Injectable } from '@nestjs/common';
import { ToolRegistryRepository } from '../repositories/tool-registry.repository';
import { ValidationResult, ValidationSeverity } from '@nodeangularfullstack/shared';
import * as fs from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Pre-flight validation service
 * Validates tool data, system resources, and dependencies before export
 */
@Injectable()
export class PreFlightValidator {
  private readonly MIN_DISK_SPACE_MB = 500;
  private readonly EXPORT_TEMP_DIR = process.env.EXPORT_TEMP_DIR || '/tmp/exports';

  constructor(
    private readonly toolRegistryRepo: ToolRegistryRepository
    // Add other repositories as needed
  ) {}

  /**
   * Validate tool is ready for export
   * @param toolId - Tool registry ID
   * @returns Validation result with errors, warnings, and info
   */
  async validate(toolId: string): Promise<ValidationResult> {
    const report = new ValidationReportBuilder();

    try {
      // Step 1: Tool Existence
      const tool = await this.validateToolExists(toolId, report);
      if (!tool) {
        return report.build(); // Critical failure, stop validation
      }

      // Step 2: Tool Data Completeness
      await this.validateToolDataCompleteness(tool, report);

      // Step 3: Database Integrity
      await this.validateDatabaseIntegrity(tool, report);

      // Step 4: System Resources
      await this.validateSystemResources(report);

      // Step 5: Dependencies
      await this.validateDependencies(report);

      // Step 6: Configuration
      await this.validateConfiguration(report);

      return report.build();
    } catch (error) {
      report.addError(`Validation failed: ${error.message}`, 'system');
      return report.build();
    }
  }

  /**
   * Step 1: Validate tool exists
   */
  private async validateToolExists(
    toolId: string,
    report: ValidationReportBuilder
  ): Promise<any | null> {
    const tool = await this.toolRegistryRepo.findById(toolId);

    if (!tool) {
      report.addError(`Tool ${toolId} not found in registry`, 'tool_existence');
      return null;
    }

    if (tool.status !== 'active') {
      report.addWarning(
        `Tool status is '${tool.status}'. Only active tools should be exported.`,
        'tool_status'
      );
    }

    const supportedTypes = ['forms', 'workflows', 'themes'];
    if (!supportedTypes.includes(tool.toolType)) {
      report.addError(`Tool type '${tool.toolType}' is not supported for export`, 'tool_type');
      return null;
    }

    report.addInfo(`Tool '${tool.toolName}' (${tool.toolType}) found`);
    return tool;
  }

  /**
   * Step 2: Validate tool data completeness
   */
  private async validateToolDataCompleteness(
    tool: any,
    report: ValidationReportBuilder
  ): Promise<void> {
    // Check tool name
    if (!tool.toolName || tool.toolName.trim() === '') {
      report.addError('Tool name is missing or empty', 'tool_name');
    }

    // Check metadata exists
    if (!tool.toolMetadata || typeof tool.toolMetadata !== 'object') {
      report.addError('Tool metadata is missing or invalid', 'tool_metadata');
      return;
    }

    // Type-specific validation
    if (tool.toolType === 'forms') {
      if (!tool.toolMetadata.formSchemaId) {
        report.addError('Form schema ID is missing in tool metadata', 'form_schema_id');
      }
    } else if (tool.toolType === 'workflows') {
      if (!tool.toolMetadata.workflowId) {
        report.addError('Workflow ID is missing in tool metadata', 'workflow_id');
      }
    } else if (tool.toolType === 'themes') {
      if (!tool.toolMetadata.themeId) {
        report.addError('Theme ID is missing in tool metadata', 'theme_id');
      }
    }

    // Validate manifest if present
    if (tool.manifest) {
      try {
        JSON.parse(JSON.stringify(tool.manifest)); // Validate JSON
        report.addInfo('Tool manifest is valid JSON');
      } catch (error) {
        report.addError('Tool manifest is invalid JSON', 'manifest');
      }
    }
  }

  /**
   * Step 3: Validate database integrity
   */
  private async validateDatabaseIntegrity(
    tool: any,
    report: ValidationReportBuilder
  ): Promise<void> {
    if (tool.toolType === 'forms') {
      const formSchemaId = tool.toolMetadata.formSchemaId;

      // Check form schema exists
      // const formSchema = await this.formsRepo.findById(formSchemaId);
      // if (!formSchema) {
      //   report.addError(`Form schema ${formSchemaId} not found`, 'form_schema');
      //   return;
      // }

      // Mock for now - replace with actual repository call
      const formSchema = { fields: [{}, {}] }; // Simulate form with 2 fields

      // Check form has fields
      if (!formSchema.fields || formSchema.fields.length === 0) {
        report.addError('Form has no fields defined', 'form_fields');
      } else {
        report.addInfo(`Form has ${formSchema.fields.length} fields`);
      }

      // Check submissions (warning only)
      // const submissionCount = await this.formsRepo.countSubmissions(formSchemaId);
      const submissionCount = 0; // Mock

      if (submissionCount === 0) {
        report.addWarning('Form has no submissions yet', 'form_submissions');
      } else {
        report.addInfo(`Form has ${submissionCount} submissions`);
      }
    }

    // Similar validation for workflows and themes
  }

  /**
   * Step 4: Validate system resources
   */
  private async validateSystemResources(report: ValidationReportBuilder): Promise<void> {
    try {
      // Check disk space
      const stats = await fs.statfs(this.EXPORT_TEMP_DIR);
      const availableMB = (stats.bavail * stats.bsize) / (1024 * 1024);

      if (availableMB < this.MIN_DISK_SPACE_MB) {
        report.addError(
          `Insufficient disk space: ${availableMB.toFixed(0)}MB available, ${this.MIN_DISK_SPACE_MB}MB required`,
          'disk_space'
        );
      } else {
        report.addInfo(`Disk space: ${availableMB.toFixed(0)}MB available`);
      }

      // Check temp directory
      await fs.mkdir(this.EXPORT_TEMP_DIR, { recursive: true });
      await fs.access(this.EXPORT_TEMP_DIR, fs.constants.W_OK);
      report.addInfo('Export temp directory is writable');
    } catch (error) {
      report.addError(`System resource check failed: ${error.message}`, 'system_resources');
    }
  }

  /**
   * Step 5: Validate dependencies
   */
  private async validateDependencies(report: ValidationReportBuilder): Promise<void> {
    // Check tar command
    try {
      await execAsync('tar --version');
      report.addInfo('tar command available');
    } catch (error) {
      report.addError('tar command not found (required for package archiving)', 'tar');
    }

    // Check npm
    try {
      await execAsync('npm --version');
      report.addInfo('npm command available');
    } catch (error) {
      report.addWarning('npm command not found (optional for package.json generation)', 'npm');
    }

    // Check Node.js version
    const nodeVersion = process.version;
    const majorVersion = parseInt(nodeVersion.substring(1).split('.')[0]);
    if (majorVersion < 18) {
      report.addError(
        `Node.js version ${nodeVersion} is below minimum required version 18`,
        'node_version'
      );
    } else {
      report.addInfo(`Node.js version ${nodeVersion}`);
    }
  }

  /**
   * Step 6: Validate configuration
   */
  private async validateConfiguration(report: ValidationReportBuilder): Promise<void> {
    // Check DATABASE_URL
    if (!process.env.DATABASE_URL) {
      report.addError('DATABASE_URL environment variable not set', 'config_database_url');
    }

    // Check export timeout
    const timeout = parseInt(process.env.EXPORT_TIMEOUT_MS || '300000');
    if (timeout < 60000) {
      report.addWarning('Export timeout is less than 1 minute', 'config_timeout');
    }

    // Check max retries
    const maxRetries = parseInt(process.env.EXPORT_MAX_RETRIES || '3');
    if (maxRetries < 1 || maxRetries > 10) {
      report.addWarning('Export max retries should be between 1 and 10', 'config_max_retries');
    }

    report.addInfo('Configuration validation complete');
  }
}

/**
 * Validation report builder
 */
class ValidationReportBuilder {
  private errors: Array<{ message: string; field: string }> = [];
  private warnings: Array<{ message: string; field: string }> = [];
  private info: string[] = [];

  addError(message: string, field: string): void {
    this.errors.push({ message, field });
  }

  addWarning(message: string, field: string): void {
    this.warnings.push({ message, field });
  }

  addInfo(message: string): void {
    this.info.push(message);
  }

  build(): ValidationResult {
    return {
      success: this.errors.length === 0,
      errors: this.errors,
      warnings: this.warnings,
      info: this.info,
      timestamp: new Date(),
    };
  }
}
```

**Why This Implementation:**

- **Sequential Validation:** Steps run in order, fail fast on critical errors
- **Report Builder Pattern:** Aggregates validation results cleanly
- **Severity Levels:** Errors block export, warnings allow export, info is informational
- **Async/Await:** All validation steps are async for database/filesystem operations

### Validation Result Type

```typescript
// packages/shared/src/types/validation.types.ts

/**
 * Validation result from pre-flight checks
 */
export interface ValidationResult {
  /** Overall validation success (true if no errors) */
  success: boolean;

  /** List of validation errors (block export) */
  errors: ValidationError[];

  /** List of validation warnings (allow export with notice) */
  warnings: ValidationWarning[];

  /** Informational messages about validation checks */
  info: string[];

  /** Timestamp when validation was performed */
  timestamp: Date;

  /** Estimated export duration in milliseconds (optional) */
  estimatedDurationMs?: number;
}

/**
 * Validation error
 */
export interface ValidationError {
  /** Human-readable error message */
  message: string;

  /** Field or check that failed (e.g., 'disk_space', 'form_schema') */
  field: string;

  /** Error severity level */
  severity?: ValidationSeverity;
}

/**
 * Validation warning
 */
export interface ValidationWarning {
  /** Human-readable warning message */
  message: string;

  /** Field or check that triggered warning */
  field: string;
}

/**
 * Validation severity levels
 */
export enum ValidationSeverity {
  ERROR = 'error', // Blocks export
  WARNING = 'warning', // Allows export but shows notice
  INFO = 'info', // Informational only
}
```

### Validation API Endpoint

```typescript
// apps/api/src/controllers/export.controller.ts (addition)

/**
 * Validate tool before export
 *
 * @route POST /api/tool-registry/tools/:toolId/export/validate
 * @param req - Express request with toolId in params
 * @param res - Express response
 * @param next - Express next function
 * @returns 200 OK with validation result (even if validation failed)
 *
 * @swagger
 * /api/tool-registry/tools/{toolId}/export/validate:
 *   post:
 *     summary: Validate tool before export
 *     tags: [Export]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: toolId
 *         required: true
 *         schema:
 *           type: string
 *           format: uuid
 *         description: Tool registry ID
 *     responses:
 *       200:
 *         description: Validation completed (check success field)
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ValidationResult'
 *       422:
 *         description: Validation failed with errors (same as 200 but different status)
 */
async validateExport(req: Request, res: Response, next: NextFunction): Promise<void> {
  try {
    const { toolId } = req.params;

    // Check cache first
    const cacheKey = `validation:${toolId}`;
    const cachedResult = this.cache.get(cacheKey);
    if (cachedResult) {
      res.status(200).json(cachedResult);
      return;
    }

    // Run validation
    const result = await this.preFlightValidator.validate(toolId);

    // Cache for 5 minutes
    this.cache.set(cacheKey, result, 300);

    // Return 422 if validation failed, 200 if passed
    const statusCode = result.success ? 200 : 422;
    res.status(statusCode).json(result);
  } catch (error) {
    next(error);
  }
}
```

### Example Validation Report

```json
{
  "success": false,
  "errors": [
    {
      "message": "Form schema abc-123 not found",
      "field": "form_schema"
    },
    {
      "message": "Insufficient disk space: 250MB available, 500MB required",
      "field": "disk_space"
    }
  ],
  "warnings": [
    {
      "message": "Form has no submissions yet",
      "field": "form_submissions"
    },
    {
      "message": "npm command not found (optional for package.json generation)",
      "field": "npm"
    }
  ],
  "info": [
    "Tool 'Customer Registration Form' (forms) found",
    "Tool manifest is valid JSON",
    "Form has 12 fields",
    "tar command available",
    "Node.js version v18.16.0",
    "Configuration validation complete"
  ],
  "timestamp": "2025-10-24T14:30:00.000Z",
  "estimatedDurationMs": 45000
}
```

---

## Testing

### Unit Test Example

```typescript
// apps/api/tests/unit/services/pre-flight-validator.service.test.ts
import { PreFlightValidator } from '../../../src/services/pre-flight-validator.service';
import { ToolRegistryRepository } from '../../../src/repositories/tool-registry.repository';

describe('PreFlightValidator', () => {
  let validator: PreFlightValidator;
  let toolRegistryRepo: jest.Mocked<ToolRegistryRepository>;

  beforeEach(() => {
    toolRegistryRepo = {
      findById: jest.fn(),
    } as any;

    validator = new PreFlightValidator(toolRegistryRepo);
  });

  describe('validate', () => {
    it('should pass validation for valid tool', async () => {
      const mockTool = {
        toolId: 'tool-123',
        toolName: 'Test Form',
        toolType: 'forms',
        status: 'active',
        toolMetadata: { formSchemaId: 'form-456' },
      };

      toolRegistryRepo.findById.mockResolvedValue(mockTool);

      const result = await validator.validate('tool-123');

      expect(result.success).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should fail validation if tool not found', async () => {
      toolRegistryRepo.findById.mockResolvedValue(null);

      const result = await validator.validate('invalid-tool');

      expect(result.success).toBe(false);
      expect(result.errors).toContainEqual({
        message: expect.stringContaining('not found'),
        field: 'tool_existence',
      });
    });

    it('should add warning if tool status is inactive', async () => {
      const mockTool = {
        toolId: 'tool-123',
        toolName: 'Test Form',
        toolType: 'forms',
        status: 'inactive',
        toolMetadata: { formSchemaId: 'form-456' },
      };

      toolRegistryRepo.findById.mockResolvedValue(mockTool);

      const result = await validator.validate('tool-123');

      expect(result.warnings).toContainEqual({
        message: expect.stringContaining('inactive'),
        field: 'tool_status',
      });
    });
  });
});
```

### Manual Test Script

```bash
#!/bin/bash
# tests/manual/test-validation-api.sh

echo "=== Pre-flight Validation API Test ==="

TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@example.com","password":"Admin123!@#"}' \
  | jq -r '.accessToken')

echo "Testing validation for valid tool..."
curl -s -X POST http://localhost:3000/api/tool-registry/tools/tool-forms-123/export/validate \
  -H "Authorization: Bearer $TOKEN" \
  | jq .

echo -e "\nTesting validation for invalid tool..."
curl -s -X POST http://localhost:3000/api/tool-registry/tools/invalid-tool/export/validate \
  -H "Authorization: Bearer $TOKEN" \
  | jq .
```

---

## Dependencies

### Blocked By:

- Story 33.1.1: Export Orchestrator Service (integration point)
- Story 33.1.2: Export Jobs Database Schema (tool references)

### Blocks:

- Story 33.1.5: Integration Tests for Epic 33.1

### Related:

- Story 32.2.3: Export Button & Permission Checks (frontend validation UI)

---

## QA Gate

**Gate File:** `docs/qa/gates/33.1.4-pre-flight-validation.yml`

### Quality Criteria (Weighted):

| Criterion          | Weight | Target                      | Validation Method |
| ------------------ | ------ | --------------------------- | ----------------- |
| Unit Test Coverage | 30%    | ≥90% statements/branches    | Jest coverage     |
| Integration Tests  | 20%    | All validation steps tested | Manual review     |
| Error Detection    | 20%    | Catches invalid exports     | Test scenarios    |
| Performance        | 10%    | Validation < 2 seconds      | Performance tests |
| Documentation      | 10%    | All steps documented        | Code review       |
| API Documentation  | 10%    | Swagger docs complete       | Swagger UI        |

**Minimum Score:** 90/100 to pass gate

---

## Notes

### ★ Insight ─────────────────────────────────────

**Fail Fast Principle:**

- Validation runs **before** creating export job (no wasted resources)
- Early exit on critical failures (tool not found → skip disk space check)
- Prevents partial exports and rollback costs

**Severity Levels Strategy:**

- **Errors:** Block export (missing data, no disk space)
- **Warnings:** Allow export but inform user (no submissions, optional tools missing)
- **Info:** Helpful context (available disk space, dependency versions)

**Why Caching:**

- Validation can be expensive (database queries, filesystem checks)
- Users often validate → export immediately (cache avoids duplicate checks)
- 5-minute TTL balances freshness and performance

─────────────────────────────────────────────────

**Story State:** Draft **Last Updated:** 2025-10-24 **Next Review:** After implementation completion
