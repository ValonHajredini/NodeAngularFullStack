# Story 29.12: Appointment Booking Template with Time Slot Management

**Epic**: Epic 29 - Form Template System with Business Logic **Story ID**: 29.12 **Status**: Draft
**Story Points**: 8 **Priority**: High **Risk Level**: High (Concurrent booking conflicts)
**Dependencies**: Stories 29.1-29.5 (Backend Foundation), 29.11 (Base Executor Interface) **Related
Stories**: 29.13-29.15 (Other Template Types)

---

## User Story

**As a** service provider, **I want** an appointment booking template with conflict prevention, **so
that** customers can book without double-booking.

---

## Acceptance Criteria

| ID  | Criterion                                                                                                   | Validated By      |
| --- | ----------------------------------------------------------------------------------------------------------- | ----------------- |
| AC1 | "Appointment Booking" template created with category `SERVICES`                                             | Unit Tests        |
| AC2 | Schema: Service Type, Preferred Date, Time Slot, Customer Name, Email, Phone                                | Unit Tests        |
| AC3 | Business logic config: `{type: 'appointment', timeSlotField, dateField, maxBookingsPerSlot, bookingsTable}` | Unit Tests        |
| AC4 | `appointment_bookings` table: `id`, `form_id`, `date`, `time_slot`, `booked_at`, `status`                   | Migration Script  |
| AC5 | `AppointmentExecutor` strategy class created                                                                | Unit Tests        |
| AC6 | Checks existing bookings count                                                                              | Integration Tests |
| AC7 | Rejects if count >= maxBookingsPerSlot                                                                      | Integration Tests |
| AC8 | Inserts booking with status `confirmed`                                                                     | Integration Tests |
| AC9 | Frontend fetches available slots, disables booked ones                                                      | Component Tests   |

---

## Integration Verification

| ID  | Verification                               | Test Method       |
| --- | ------------------------------------------ | ----------------- |
| IV1 | Existing date/time fields unchanged        | Regression Tests  |
| IV2 | Booking logic executes within 150ms        | Performance Tests |
| IV3 | Conflict detection prevents double-booking | Concurrent Tests  |

---

## Dev Notes

### Architecture Context

**Source**: docs/architecture/backend-architecture.md (Repository Pattern),
docs/architecture/database-schema.md (PostgreSQL Best Practices)

This story implements the second template business logic executor following the Strategy Pattern
established in Story 29.11. The `AppointmentExecutor` handles time slot conflict detection with
transaction support to prevent double-booking scenarios.

**Key Architectural Patterns**:

1. **Strategy Pattern**: `AppointmentExecutor` implements `ITemplateExecutor` interface (defined in
   Story 29.11)
2. **Repository Pattern**: `AppointmentBookingRepository` encapsulates database operations
3. **Transaction Management**: Uses PostgreSQL transactions with row-level locking for conflict
   prevention
4. **Service Integration**: Integrates with `FormsService.submitForm()` workflow

**Performance Requirements**:

- Booking validation + conflict check: < 150ms (P95)
- Available slots API response: < 100ms (P95)
- Concurrent booking test: 20 simultaneous requests, max 5 bookings per slot

---

### Database Schema

**New Table Migration**:
`apps/forms-api/database/migrations/032_create_appointment_bookings_table.sql`

```sql
-- Create appointment_bookings table for time slot management
CREATE TABLE appointment_bookings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    form_id UUID NOT NULL REFERENCES forms(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    time_slot VARCHAR(50) NOT NULL,
    booked_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) NOT NULL DEFAULT 'confirmed' CHECK (status IN ('confirmed', 'cancelled', 'completed')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Index for fast conflict detection
CREATE INDEX idx_appointment_bookings_form_date_slot ON appointment_bookings(form_id, date, time_slot) WHERE status = 'confirmed';

-- Index for calendar queries
CREATE INDEX idx_appointment_bookings_date ON appointment_bookings(date, status);

-- Trigger for updated_at
CREATE TRIGGER update_appointment_bookings_updated_at
BEFORE UPDATE ON appointment_bookings
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Comments
COMMENT ON TABLE appointment_bookings IS 'Stores appointment bookings with conflict detection support for template business logic';
COMMENT ON COLUMN appointment_bookings.time_slot IS 'Time slot identifier (e.g., "09:00-10:00", "morning", custom labels)';
COMMENT ON COLUMN appointment_bookings.status IS 'Booking status: confirmed (active), cancelled (user cancelled), completed (past appointment)';
```

**Down Migration**:
`apps/forms-api/database/migrations/DOWN_032_remove_appointment_bookings_table.sql`

```sql
DROP TRIGGER IF EXISTS update_appointment_bookings_updated_at ON appointment_bookings;
DROP INDEX IF EXISTS idx_appointment_bookings_form_date_slot;
DROP INDEX IF EXISTS idx_appointment_bookings_date;
DROP TABLE IF EXISTS appointment_bookings;
```

---

### Backend Implementation

#### 1. Shared Types Extension

**File**: `packages/shared/src/types/templates.types.ts`

Add appointment-specific config type:

```typescript
/**
 * Business logic configuration for appointment booking templates
 * @since Epic 29, Story 29.12
 */
export interface AppointmentLogicConfig {
  type: 'appointment';
  timeSlotField: string; // Field ID containing time slot selection
  dateField: string; // Field ID containing date selection
  maxBookingsPerSlot: number; // Maximum concurrent bookings per slot (1-100)
  bookingsTable: 'appointment_bookings'; // Always use standard table
  requireConfirmation?: boolean; // Optional: send confirmation email
}

/**
 * Appointment booking record
 * @since Epic 29, Story 29.12
 */
export interface AppointmentBooking {
  id: string;
  form_id: string;
  date: string; // ISO date format YYYY-MM-DD
  time_slot: string; // Time slot identifier
  booked_at: Date;
  status: 'confirmed' | 'cancelled' | 'completed';
  created_at: Date;
  updated_at: Date;
}

/**
 * Available slot information
 * @since Epic 29, Story 29.12
 */
export interface AvailableSlot {
  date: string;
  time_slot: string;
  available_capacity: number;
  max_capacity: number;
  is_available: boolean;
}
```

Update union type:

```typescript
export type TemplateBusinessLogicConfig =
  | InventoryLogicConfig
  | AppointmentLogicConfig
  | QuizLogicConfig
  | PollLogicConfig
  | OrderLogicConfig;
```

Rebuild shared package:

```bash
npm run build:shared
```

---

#### 2. Repository Layer

**File**: `apps/forms-api/src/repositories/appointment-booking.repository.ts`

```typescript
import { Pool, PoolClient } from 'pg';
import { AppointmentBooking, AvailableSlot } from '@nodeangularfullstack/shared';

/**
 * Repository for appointment booking data access
 * @since Epic 29, Story 29.12
 * @source docs/architecture/backend-architecture.md (Repository Pattern)
 */
export class AppointmentBookingRepository {
  constructor(private readonly pool: Pool) {}

  /**
   * Check booking count for a specific slot (transaction-safe)
   * Uses row-level locking to prevent race conditions
   *
   * @param client - Database client (transaction context)
   * @param formId - Form UUID
   * @param date - ISO date YYYY-MM-DD
   * @param timeSlot - Time slot identifier
   * @returns Number of confirmed bookings
   */
  async getBookingCount(
    client: PoolClient,
    formId: string,
    date: string,
    timeSlot: string
  ): Promise<number> {
    const query = `
      SELECT COUNT(*) as count
      FROM appointment_bookings
      WHERE form_id = $1
        AND date = $2
        AND time_slot = $3
        AND status = 'confirmed'
      FOR UPDATE
    `;

    const result = await client.query(query, [formId, date, timeSlot]);
    return parseInt(result.rows[0].count, 10);
  }

  /**
   * Create appointment booking
   *
   * @param client - Database client (transaction context)
   * @param formId - Form UUID
   * @param date - ISO date YYYY-MM-DD
   * @param timeSlot - Time slot identifier
   * @returns Created booking record
   */
  async createBooking(
    client: PoolClient,
    formId: string,
    date: string,
    timeSlot: string
  ): Promise<AppointmentBooking> {
    const query = `
      INSERT INTO appointment_bookings (form_id, date, time_slot, status)
      VALUES ($1, $2, $3, 'confirmed')
      RETURNING *
    `;

    const result = await client.query(query, [formId, date, timeSlot]);
    return result.rows[0];
  }

  /**
   * Get available slots for a date range
   * Returns availability information without locking
   *
   * @param formId - Form UUID
   * @param startDate - Start date ISO YYYY-MM-DD
   * @param endDate - End date ISO YYYY-MM-DD
   * @param maxBookingsPerSlot - Maximum capacity per slot
   * @returns Array of available slots
   */
  async getAvailableSlots(
    formId: string,
    startDate: string,
    endDate: string,
    maxBookingsPerSlot: number
  ): Promise<AvailableSlot[]> {
    const query = `
      WITH booking_counts AS (
        SELECT
          date,
          time_slot,
          COUNT(*) as booked_count
        FROM appointment_bookings
        WHERE form_id = $1
          AND date BETWEEN $2 AND $3
          AND status = 'confirmed'
        GROUP BY date, time_slot
      )
      SELECT
        bc.date,
        bc.time_slot,
        ($4 - bc.booked_count) as available_capacity,
        $4 as max_capacity,
        (bc.booked_count < $4) as is_available
      FROM booking_counts bc
      ORDER BY bc.date, bc.time_slot
    `;

    const result = await this.pool.query(query, [formId, startDate, endDate, maxBookingsPerSlot]);
    return result.rows;
  }

  /**
   * Cancel booking by ID
   *
   * @param bookingId - Booking UUID
   * @returns Updated booking record
   */
  async cancelBooking(bookingId: string): Promise<AppointmentBooking | null> {
    const query = `
      UPDATE appointment_bookings
      SET status = 'cancelled', updated_at = CURRENT_TIMESTAMP
      WHERE id = $1 AND status = 'confirmed'
      RETURNING *
    `;

    const result = await this.pool.query(query, [bookingId]);
    return result.rows[0] || null;
  }
}
```

**Testing Note**: Repository uses `PoolClient` parameter for transaction context (not internal
BEGIN/COMMIT). This allows service layer to control transaction boundaries.

---

#### 3. Executor Strategy Class

**File**: `apps/forms-api/src/services/executors/appointment.executor.ts`

```typescript
import { PoolClient } from 'pg';
import {
  ITemplateExecutor,
  ExecutorValidation,
  ExecutorResult,
  FormTemplate,
  FormSubmission,
  AppointmentLogicConfig,
} from '@nodeangularfullstack/shared';
import { AppointmentBookingRepository } from '../../repositories/appointment-booking.repository';
import { ApiError } from '../../utils/api-error';

/**
 * Appointment booking executor with conflict detection
 * Prevents double-booking using transaction-level locking
 *
 * @since Epic 29, Story 29.12
 * @implements ITemplateExecutor (Story 29.11)
 * @source docs/architecture/backend-architecture.md (Strategy Pattern)
 */
export class AppointmentExecutor implements ITemplateExecutor {
  constructor(private readonly bookingRepo: AppointmentBookingRepository) {}

  /**
   * Validate appointment booking data
   * Checks required fields and date/time format
   */
  async validate(
    submission: Partial<FormSubmission>,
    template: FormTemplate,
    config: AppointmentLogicConfig
  ): Promise<ExecutorValidation> {
    const errors: string[] = [];
    const data = submission.data as Record<string, any>;

    // Validate date field
    const date = data[config.dateField];
    if (!date) {
      errors.push(`Date field '${config.dateField}' is required`);
    } else if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      errors.push('Date must be in YYYY-MM-DD format');
    } else {
      const bookingDate = new Date(date);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      if (bookingDate < today) {
        errors.push('Cannot book appointments in the past');
      }
    }

    // Validate time slot field
    const timeSlot = data[config.timeSlotField];
    if (!timeSlot || typeof timeSlot !== 'string' || timeSlot.trim() === '') {
      errors.push(`Time slot field '${config.timeSlotField}' is required`);
    }

    // Validate maxBookingsPerSlot
    if (config.maxBookingsPerSlot < 1 || config.maxBookingsPerSlot > 100) {
      errors.push('maxBookingsPerSlot must be between 1 and 100');
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Execute appointment booking with conflict detection
   * Uses transaction and row-level locking to prevent double-booking
   *
   * @param submission - Form submission record
   * @param template - Template configuration
   * @param config - Appointment logic configuration
   * @param client - Database client (transaction context)
   * @returns Executor result with booking details
   * @throws ApiError if slot is fully booked
   */
  async execute(
    submission: FormSubmission,
    template: FormTemplate,
    config: AppointmentLogicConfig,
    client: PoolClient
  ): Promise<ExecutorResult> {
    const data = submission.data as Record<string, any>;
    const date = data[config.dateField];
    const timeSlot = data[config.timeSlotField];

    // Check existing bookings with row-level lock
    const currentBookings = await this.bookingRepo.getBookingCount(
      client,
      submission.form_id,
      date,
      timeSlot
    );

    // Reject if fully booked
    if (currentBookings >= config.maxBookingsPerSlot) {
      throw new ApiError(
        409, // HTTP 409 Conflict
        `Time slot ${timeSlot} on ${date} is fully booked (${currentBookings}/${config.maxBookingsPerSlot})`
      );
    }

    // Create booking
    const booking = await this.bookingRepo.createBooking(
      client,
      submission.form_id,
      date,
      timeSlot
    );

    return {
      success: true,
      data: {
        booking_id: booking.id,
        date: booking.date,
        time_slot: booking.time_slot,
        status: booking.status,
        capacity: {
          current: currentBookings + 1,
          max: config.maxBookingsPerSlot,
          available: config.maxBookingsPerSlot - currentBookings - 1,
        },
      },
      message: 'Appointment booked successfully',
    };
  }
}
```

**Error Handling Note**: Uses HTTP 409 Conflict status code for double-booking attempts (per REST
best practices).

---

#### 4. Service Integration

**File**: `apps/forms-api/src/services/forms.service.ts`

Update executor factory and submission flow:

```typescript
import { AppointmentExecutor } from './executors/appointment.executor';
import { AppointmentBookingRepository } from '../repositories/appointment-booking.repository';

/**
 * Get executor instance based on config type
 * @source docs/architecture/backend-architecture.md (Strategy Pattern)
 */
private getExecutor(config: TemplateBusinessLogicConfig): ITemplateExecutor {
  switch (config.type) {
    case 'inventory':
      const inventoryRepo = new ProductInventoryRepository(this.pool);
      return new InventoryExecutor(inventoryRepo);

    case 'appointment':
      const bookingRepo = new AppointmentBookingRepository(this.pool);
      return new AppointmentExecutor(bookingRepo);

    default:
      throw new ApiError(400, `Unknown executor type: ${(config as any).type}`);
  }
}

/**
 * Submit form with optional template business logic
 * Handles appointment booking with conflict detection
 *
 * @param shortCode - Form short code
 * @param submissionData - Form data
 * @returns Created submission with booking details
 * @throws ApiError 409 if appointment slot is fully booked
 */
async submitForm(shortCode: string, submissionData: any): Promise<FormSubmission> {
  const form = await this.formsRepo.getFormByShortCode(shortCode);
  if (!form || !form.is_published) {
    throw new ApiError(404, 'Form not found or not published');
  }

  // Get template if form has one
  const template = form.template_id
    ? await this.templatesRepo.getTemplateById(form.template_id)
    : null;

  // Validate with executor before creating submission
  if (template?.business_logic_config) {
    const executor = this.getExecutor(template.business_logic_config);
    const validation = await executor.validate(
      { data: submissionData },
      template,
      template.business_logic_config
    );

    if (!validation.valid) {
      throw new ApiError(400, validation.errors.join(', '));
    }
  }

  // Create submission record
  const submission = await this.submissionsRepo.create({
    form_id: form.id,
    data: submissionData,
    submitted_at: new Date()
  });

  // Execute business logic with transaction
  if (template?.business_logic_config) {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      const executor = this.getExecutor(template.business_logic_config);
      const result = await executor.execute(
        submission,
        template,
        template.business_logic_config,
        client
      );

      // Store executor result in submission metadata
      await this.submissionsRepo.updateMetadata(
        client,
        submission.id,
        result.data
      );

      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');

      // Delete submission on executor failure (compensating transaction)
      await this.submissionsRepo.delete(submission.id);

      // Re-throw error (will be caught by error middleware)
      throw error;
    } finally {
      client.release();
    }
  }

  return submission;
}
```

---

#### 5. Controller Endpoint for Available Slots

**File**: `apps/forms-api/src/controllers/forms.controller.ts`

Add new endpoint:

```typescript
import { AppointmentBookingRepository } from '../repositories/appointment-booking.repository';

/**
 * GET /api/public/forms/:shortCode/available-slots
 * Get available appointment slots for a date range
 *
 * @query startDate - Start date YYYY-MM-DD (required)
 * @query endDate - End date YYYY-MM-DD (required)
 * @returns Array of available slots
 * @since Epic 29, Story 29.12
 */
router.get(
  '/:shortCode/available-slots',
  asyncHandler(async (req: Request, res: Response) => {
    const { shortCode } = req.params;
    const { startDate, endDate } = req.query;

    // Validate query parameters
    if (!startDate || !endDate) {
      throw new ApiError(400, 'startDate and endDate query parameters are required');
    }

    if (
      !/^\d{4}-\d{2}-\d{2}$/.test(startDate as string) ||
      !/^\d{4}-\d{2}-\d{2}$/.test(endDate as string)
    ) {
      throw new ApiError(400, 'Dates must be in YYYY-MM-DD format');
    }

    // Get form and template
    const form = await formsService.getFormByShortCode(shortCode);
    if (!form?.template_id) {
      throw new ApiError(404, 'Form not found or does not use appointment template');
    }

    const template = await templatesService.getTemplateById(form.template_id);
    if (template.business_logic_config?.type !== 'appointment') {
      throw new ApiError(400, 'Form does not use appointment booking template');
    }

    // Get available slots
    const bookingRepo = new AppointmentBookingRepository(pool);
    const slots = await bookingRepo.getAvailableSlots(
      form.id,
      startDate as string,
      endDate as string,
      template.business_logic_config.maxBookingsPerSlot
    );

    res.json({
      success: true,
      data: slots,
      message: 'Available slots retrieved successfully',
    });
  })
);
```

---

### Frontend Implementation

#### 1. API Service Extension

**File**: `apps/form-builder-ui/src/app/features/public/form-renderer/form-renderer.service.ts`

Add available slots method:

```typescript
import { AvailableSlot } from '@nodeangularfullstack/shared';

/**
 * Get available appointment slots
 * @param shortCode - Form short code
 * @param startDate - Start date YYYY-MM-DD
 * @param endDate - End date YYYY-MM-DD
 * @returns Observable of available slots
 * @since Epic 29, Story 29.12
 */
getAvailableSlots(
  shortCode: string,
  startDate: string,
  endDate: string
): Observable<AvailableSlot[]> {
  const params = new HttpParams()
    .set('startDate', startDate)
    .set('endDate', endDate);

  return this.http.get<ApiResponse<AvailableSlot[]>>(
    `${this.apiUrl}/api/public/forms/${shortCode}/available-slots`,
    { params }
  ).pipe(
    map(response => response.data)
  );
}
```

---

#### 2. Available Slots Display Component

**File**:
`apps/form-builder-ui/src/app/features/public/form-renderer/available-slots/available-slots.component.ts`

```typescript
import {
  Component,
  computed,
  inject,
  input,
  OnInit,
  signal,
  ChangeDetectionStrategy,
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { CalendarModule } from 'primeng/calendar';
import { ChipModule } from 'primeng/chip';
import { FormRendererService } from '../form-renderer.service';
import { AvailableSlot } from '@nodeangularfullstack/shared';

/**
 * Component displays available appointment slots for a date range
 * Integrates with appointment booking template
 *
 * @since Epic 29, Story 29.12
 * @source docs/architecture/frontend-architecture.md (Signal-based State)
 */
@Component({
  selector: 'app-available-slots',
  standalone: true,
  imports: [CommonModule, CalendarModule, ChipModule],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="available-slots-container">
      <h3>Select Date and Time</h3>

      <!-- Date Selection -->
      <p-calendar
        [(ngModel)]="selectedDate"
        [minDate]="minDate()"
        [inline]="true"
        dateFormat="yy-mm-dd"
        (onSelect)="handleDateChange($event)"
      />

      <!-- Time Slots for Selected Date -->
      @if (selectedDate && slotsForDate().length > 0) {
        <div class="time-slots-grid">
          @for (slot of slotsForDate(); track slot.time_slot) {
            <p-chip
              [label]="slot.time_slot"
              [styleClass]="getSlotClass(slot)"
              (click)="selectSlot(slot)"
              [disabled]="!slot.is_available"
            >
              <span class="capacity-badge">
                {{ slot.available_capacity }}/{{ slot.max_capacity }}
              </span>
            </p-chip>
          }
        </div>
      }

      @if (selectedSlot()) {
        <div class="selected-slot-info">
          <strong>Selected:</strong> {{ formatSlot(selectedSlot()) }}
        </div>
      }

      @if (loading()) {
        <div class="loading-spinner">Loading available slots...</div>
      }

      @if (error()) {
        <div class="error-message">{{ error() }}</div>
      }
    </div>
  `,
  styles: [
    `
      .available-slots-container {
        margin: 1rem 0;
      }

      .time-slots-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 0.75rem;
        margin-top: 1rem;
      }

      .capacity-badge {
        margin-left: 0.5rem;
        font-size: 0.875rem;
        color: var(--text-color-secondary);
      }

      .selected-slot-info {
        margin-top: 1rem;
        padding: 0.75rem;
        background: var(--surface-card);
        border-radius: 6px;
      }

      .loading-spinner {
        text-align: center;
        padding: 1rem;
        color: var(--text-color-secondary);
      }

      .error-message {
        color: var(--red-500);
        padding: 0.75rem;
        background: var(--red-50);
        border-radius: 6px;
        margin-top: 1rem;
      }

      /* Slot chip states */
      :host ::ng-deep {
        .slot-available {
          background: var(--green-500);
          color: white;
          cursor: pointer;
        }

        .slot-limited {
          background: var(--orange-500);
          color: white;
          cursor: pointer;
        }

        .slot-full {
          background: var(--surface-300);
          color: var(--text-color-secondary);
          cursor: not-allowed;
        }

        .slot-selected {
          background: var(--primary-color);
          color: white;
          border: 2px solid var(--primary-600);
        }
      }
    `,
  ],
})
export class AvailableSlotsComponent implements OnInit {
  // Inputs
  readonly shortCode = input.required<string>();

  // Services
  private readonly formService = inject(FormRendererService);

  // State
  readonly selectedDate = signal<Date | null>(null);
  readonly selectedSlot = signal<AvailableSlot | null>(null);
  readonly availableSlots = signal<AvailableSlot[]>([]);
  readonly loading = signal(false);
  readonly error = signal<string | null>(null);

  // Computed
  readonly minDate = computed(() => new Date());

  readonly slotsForDate = computed(() => {
    const date = this.selectedDate();
    if (!date) return [];

    const dateStr = this.formatDate(date);
    return this.availableSlots().filter((slot) => slot.date === dateStr);
  });

  ngOnInit(): void {
    this.loadNextWeekSlots();
  }

  /**
   * Load available slots for next 7 days
   */
  private loadNextWeekSlots(): void {
    const today = new Date();
    const nextWeek = new Date(today);
    nextWeek.setDate(nextWeek.getDate() + 7);

    this.loading.set(true);
    this.error.set(null);

    this.formService
      .getAvailableSlots(this.shortCode(), this.formatDate(today), this.formatDate(nextWeek))
      .subscribe({
        next: (slots) => {
          this.availableSlots.set(slots);
          this.loading.set(false);
        },
        error: (err) => {
          this.error.set('Failed to load available slots');
          this.loading.set(false);
          console.error('Error loading slots:', err);
        },
      });
  }

  /**
   * Handle date selection change
   */
  handleDateChange(event: Date): void {
    this.selectedDate.set(event);
    this.selectedSlot.set(null); // Reset slot selection
  }

  /**
   * Select a time slot
   */
  selectSlot(slot: AvailableSlot): void {
    if (!slot.is_available) return;
    this.selectedSlot.set(slot);
  }

  /**
   * Get CSS class for slot chip based on availability
   */
  getSlotClass(slot: AvailableSlot): string {
    if (this.selectedSlot()?.time_slot === slot.time_slot) {
      return 'slot-selected';
    }
    if (!slot.is_available) {
      return 'slot-full';
    }
    if (slot.available_capacity <= slot.max_capacity * 0.3) {
      return 'slot-limited';
    }
    return 'slot-available';
  }

  /**
   * Format date to YYYY-MM-DD
   */
  private formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }

  /**
   * Format slot for display
   */
  formatSlot(slot: AvailableSlot | null): string {
    if (!slot) return '';
    return `${slot.date} at ${slot.time_slot}`;
  }
}
```

---

#### 3. Integration with FormRendererComponent

**File**: `apps/form-builder-ui/src/app/features/public/form-renderer/form-renderer.component.ts`

Add conditional slots display:

```typescript
@if (formSchema()?.template_id && isAppointmentTemplate()) {
  <app-available-slots [shortCode]="shortCode()" />
}

<!-- Existing form rendering -->
<form [formGroup]="formGroup" (ngSubmit)="onSubmit()">
  <!-- Form fields -->
</form>
```

Add template detection:

```typescript
protected readonly isAppointmentTemplate = computed(() => {
  const template = this.formSchema()?.template;
  return template?.business_logic_config?.type === 'appointment';
});
```

---

### Testing Implementation

#### 1. Backend Unit Tests

**File**: `apps/forms-api/tests/unit/services/executors/appointment.executor.test.ts`

```typescript
import { AppointmentExecutor } from '../../../../src/services/executors/appointment.executor';
import { AppointmentBookingRepository } from '../../../../src/repositories/appointment-booking.repository';
import { FormTemplate, FormSubmission, AppointmentLogicConfig } from '@nodeangularfullstack/shared';
import { ApiError } from '../../../../src/utils/api-error';

describe('AppointmentExecutor', () => {
  let executor: AppointmentExecutor;
  let mockBookingRepo: jest.Mocked<AppointmentBookingRepository>;
  let mockClient: any;

  const mockConfig: AppointmentLogicConfig = {
    type: 'appointment',
    timeSlotField: 'time_slot',
    dateField: 'date',
    maxBookingsPerSlot: 5,
    bookingsTable: 'appointment_bookings',
  };

  const mockTemplate: FormTemplate = {
    id: 'template-123',
    name: 'Appointment Booking',
    category: 'SERVICES',
    template_schema: {} as any,
    business_logic_config: mockConfig,
    is_active: true,
    created_at: new Date(),
    updated_at: new Date(),
  };

  beforeEach(() => {
    mockBookingRepo = {
      getBookingCount: jest.fn(),
      createBooking: jest.fn(),
    } as any;

    mockClient = {
      query: jest.fn(),
    };

    executor = new AppointmentExecutor(mockBookingRepo);
  });

  describe('validate', () => {
    it('should pass validation for valid appointment data', async () => {
      const submission = {
        data: {
          date: '2025-12-01',
          time_slot: '09:00-10:00',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(true);
      expect(result.errors).toEqual([]);
    });

    it('should fail validation for missing date', async () => {
      const submission = {
        data: {
          time_slot: '09:00-10:00',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain("Date field 'date' is required");
    });

    it('should fail validation for invalid date format', async () => {
      const submission = {
        data: {
          date: '12/01/2025',
          time_slot: '09:00-10:00',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Date must be in YYYY-MM-DD format');
    });

    it('should fail validation for past dates', async () => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const pastDate = yesterday.toISOString().split('T')[0];

      const submission = {
        data: {
          date: pastDate,
          time_slot: '09:00-10:00',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Cannot book appointments in the past');
    });

    it('should fail validation for missing time slot', async () => {
      const submission = {
        data: {
          date: '2025-12-01',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain("Time slot field 'time_slot' is required");
    });
  });

  describe('execute', () => {
    const mockSubmission: FormSubmission = {
      id: 'sub-123',
      form_id: 'form-123',
      data: {
        date: '2025-12-01',
        time_slot: '09:00-10:00',
      },
      submitted_at: new Date(),
      created_at: new Date(),
    };

    it('should create booking when slot is available', async () => {
      mockBookingRepo.getBookingCount.mockResolvedValue(2); // 2 bookings, max 5
      mockBookingRepo.createBooking.mockResolvedValue({
        id: 'booking-123',
        form_id: 'form-123',
        date: '2025-12-01',
        time_slot: '09:00-10:00',
        booked_at: new Date(),
        status: 'confirmed',
        created_at: new Date(),
        updated_at: new Date(),
      });

      const result = await executor.execute(mockSubmission, mockTemplate, mockConfig, mockClient);

      expect(result.success).toBe(true);
      expect(result.data.booking_id).toBe('booking-123');
      expect(result.data.capacity.current).toBe(3);
      expect(result.data.capacity.max).toBe(5);
      expect(result.data.capacity.available).toBe(2);
      expect(mockBookingRepo.getBookingCount).toHaveBeenCalledWith(
        mockClient,
        'form-123',
        '2025-12-01',
        '09:00-10:00'
      );
      expect(mockBookingRepo.createBooking).toHaveBeenCalled();
    });

    it('should throw ApiError 409 when slot is fully booked', async () => {
      mockBookingRepo.getBookingCount.mockResolvedValue(5); // Full capacity

      await expect(
        executor.execute(mockSubmission, mockTemplate, mockConfig, mockClient)
      ).rejects.toThrow(ApiError);

      await expect(
        executor.execute(mockSubmission, mockTemplate, mockConfig, mockClient)
      ).rejects.toMatchObject({
        statusCode: 409,
        message: expect.stringContaining('fully booked'),
      });

      expect(mockBookingRepo.createBooking).not.toHaveBeenCalled();
    });

    it('should handle edge case: last available slot', async () => {
      mockBookingRepo.getBookingCount.mockResolvedValue(4); // 4/5 booked
      mockBookingRepo.createBooking.mockResolvedValue({
        id: 'booking-last',
        form_id: 'form-123',
        date: '2025-12-01',
        time_slot: '09:00-10:00',
        booked_at: new Date(),
        status: 'confirmed',
        created_at: new Date(),
        updated_at: new Date(),
      });

      const result = await executor.execute(mockSubmission, mockTemplate, mockConfig, mockClient);

      expect(result.success).toBe(true);
      expect(result.data.capacity.available).toBe(0);
    });
  });
});
```

---

#### 2. Backend Integration Tests

**File**: `apps/forms-api/tests/integration/appointment-booking.test.ts`

```typescript
import request from 'supertest';
import app from '../../src/server';
import { pool } from '../../src/config/database';
import { PoolClient } from 'pg';

describe('Appointment Booking Integration Tests', () => {
  let client: PoolClient;
  let formShortCode: string;
  let templateId: string;

  beforeAll(async () => {
    client = await pool.connect();
    await client.query('BEGIN');

    // Create appointment template
    const templateResult = await client.query(`
      INSERT INTO form_templates (name, category, template_schema, business_logic_config, is_active)
      VALUES (
        'Test Appointment Booking',
        'SERVICES',
        '{"fields": [{"id": "date", "type": "DATE"}, {"id": "time_slot", "type": "SELECT"}]}'::jsonb,
        '{"type": "appointment", "dateField": "date", "timeSlotField": "time_slot", "maxBookingsPerSlot": 3}'::jsonb,
        true
      )
      RETURNING id
    `);
    templateId = templateResult.rows[0].id;

    // Create form with template
    const formResult = await client.query(
      `
      INSERT INTO forms (title, is_published, template_id)
      VALUES ('Appointment Test Form', true, $1)
      RETURNING id
    `,
      [templateId]
    );

    const formId = formResult.rows[0].id;

    // Create short link
    const shortLinkResult = await client.query(
      `
      INSERT INTO short_links (short_code, form_schema_id)
      VALUES ('apt-test', $1)
      RETURNING short_code
    `,
      [formId]
    );
    formShortCode = shortLinkResult.rows[0].short_code;

    await client.query('COMMIT');
  });

  afterAll(async () => {
    await client.query('ROLLBACK');
    client.release();
    await pool.end();
  });

  describe('POST /api/public/forms/:shortCode/submit', () => {
    it('should create booking when slot is available', async () => {
      const response = await request(app).post(`/api/public/forms/${formShortCode}/submit`).send({
        date: '2025-12-15',
        time_slot: '10:00-11:00',
      });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.booking_id).toBeDefined();
      expect(response.body.data.capacity.current).toBe(1);
      expect(response.body.data.capacity.max).toBe(3);
    });

    it('should reject booking for fully booked slot', async () => {
      const slotData = {
        date: '2025-12-16',
        time_slot: '14:00-15:00',
      };

      // Book 3 times (max capacity)
      await request(app).post(`/api/public/forms/${formShortCode}/submit`).send(slotData);
      await request(app).post(`/api/public/forms/${formShortCode}/submit`).send(slotData);
      await request(app).post(`/api/public/forms/${formShortCode}/submit`).send(slotData);

      // 4th booking should fail
      const response = await request(app)
        .post(`/api/public/forms/${formShortCode}/submit`)
        .send(slotData);

      expect(response.status).toBe(409);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain('fully booked');
    });

    it('should reject booking for past date', async () => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const pastDate = yesterday.toISOString().split('T')[0];

      const response = await request(app).post(`/api/public/forms/${formShortCode}/submit`).send({
        date: pastDate,
        time_slot: '10:00-11:00',
      });

      expect(response.status).toBe(400);
      expect(response.body.message).toContain('past');
    });
  });

  describe('GET /api/public/forms/:shortCode/available-slots', () => {
    it('should return available slots', async () => {
      const today = new Date().toISOString().split('T')[0];
      const nextWeek = new Date();
      nextWeek.setDate(nextWeek.getDate() + 7);
      const endDate = nextWeek.toISOString().split('T')[0];

      const response = await request(app)
        .get(`/api/public/forms/${formShortCode}/available-slots`)
        .query({ startDate: today, endDate });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(Array.isArray(response.body.data)).toBe(true);
    });

    it('should require startDate and endDate query parameters', async () => {
      const response = await request(app).get(`/api/public/forms/${formShortCode}/available-slots`);

      expect(response.status).toBe(400);
      expect(response.body.message).toContain('required');
    });

    it('should reject invalid date format', async () => {
      const response = await request(app)
        .get(`/api/public/forms/${formShortCode}/available-slots`)
        .query({ startDate: '12/01/2025', endDate: '12/08/2025' });

      expect(response.status).toBe(400);
      expect(response.body.message).toContain('format');
    });
  });

  describe('Concurrent booking conflict prevention', () => {
    it('should prevent double-booking with concurrent requests', async () => {
      const slotData = {
        date: '2025-12-20',
        time_slot: '16:00-17:00',
      };

      // Create 20 concurrent booking requests
      const promises = Array(20)
        .fill(null)
        .map(() => request(app).post(`/api/public/forms/${formShortCode}/submit`).send(slotData));

      const responses = await Promise.allSettled(promises);

      // Count successful bookings
      const successful = responses.filter(
        (r) => r.status === 'fulfilled' && r.value.status === 200
      ).length;

      // Should have exactly 3 successful bookings (maxBookingsPerSlot)
      expect(successful).toBe(3);

      // Remaining should be 409 Conflict
      const conflicts = responses.filter(
        (r) => r.status === 'fulfilled' && r.value.status === 409
      ).length;
      expect(conflicts).toBe(17);
    });
  });
});
```

---

#### 3. Frontend Component Tests

**File**:
`apps/form-builder-ui/src/app/features/public/form-renderer/available-slots/available-slots.component.spec.ts`

```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { AvailableSlotsComponent } from './available-slots.component';
import { FormRendererService } from '../form-renderer.service';
import { of, throwError } from 'rxjs';
import { AvailableSlot } from '@nodeangularfullstack/shared';
import { signal } from '@angular/core';

describe('AvailableSlotsComponent', () => {
  let component: AvailableSlotsComponent;
  let fixture: ComponentFixture<AvailableSlotsComponent>;
  let mockFormService: jasmine.SpyObj<FormRendererService>;

  const mockSlots: AvailableSlot[] = [
    {
      date: '2025-12-01',
      time_slot: '09:00-10:00',
      available_capacity: 3,
      max_capacity: 5,
      is_available: true,
    },
    {
      date: '2025-12-01',
      time_slot: '10:00-11:00',
      available_capacity: 0,
      max_capacity: 5,
      is_available: false,
    },
  ];

  beforeEach(async () => {
    mockFormService = jasmine.createSpyObj('FormRendererService', ['getAvailableSlots']);

    await TestBed.configureTestingModule({
      imports: [AvailableSlotsComponent],
      providers: [{ provide: FormRendererService, useValue: mockFormService }],
    }).compileComponents();

    fixture = TestBed.createComponent(AvailableSlotsComponent);
    component = fixture.componentInstance;
    fixture.componentRef.setInput('shortCode', 'test-form');
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should load available slots on init', () => {
    mockFormService.getAvailableSlots.and.returnValue(of(mockSlots));

    fixture.detectChanges();

    expect(mockFormService.getAvailableSlots).toHaveBeenCalled();
    expect(component.availableSlots().length).toBe(2);
    expect(component.loading()).toBe(false);
  });

  it('should filter slots by selected date', () => {
    component.availableSlots.set(mockSlots);
    component.selectedDate.set(new Date('2025-12-01'));

    const filtered = component.slotsForDate();
    expect(filtered.length).toBe(2);
  });

  it('should return correct CSS class for available slot', () => {
    const slot = mockSlots[0];
    const cssClass = component.getSlotClass(slot);
    expect(cssClass).toBe('slot-available');
  });

  it('should return correct CSS class for full slot', () => {
    const slot = mockSlots[1];
    const cssClass = component.getSlotClass(slot);
    expect(cssClass).toBe('slot-full');
  });

  it('should select slot when clicked', () => {
    component.selectSlot(mockSlots[0]);
    expect(component.selectedSlot()).toEqual(mockSlots[0]);
  });

  it('should not select full slot', () => {
    component.selectSlot(mockSlots[1]);
    expect(component.selectedSlot()).toBeNull();
  });

  it('should handle API error gracefully', () => {
    mockFormService.getAvailableSlots.and.returnValue(throwError(() => new Error('API Error')));

    fixture.detectChanges();

    expect(component.error()).toBe('Failed to load available slots');
    expect(component.loading()).toBe(false);
  });
});
```

---

### Template Seed Data

**File**: `apps/forms-api/database/seeds/032_seed_appointment_template.ts`

```typescript
import { Pool } from 'pg';

/**
 * Seed appointment booking template
 * @since Epic 29, Story 29.12
 */
export async function seedAppointmentTemplate(pool: Pool): Promise<void> {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // Check if template already exists
    const existing = await client.query(
      `SELECT id FROM form_templates WHERE name = 'Appointment Booking'`
    );

    if (existing.rows.length > 0) {
      console.log('Appointment Booking template already exists, skipping...');
      await client.query('COMMIT');
      return;
    }

    // Create template
    const templateSchema = {
      fields: [
        {
          id: 'service_type',
          type: 'SELECT',
          label: 'Service Type',
          required: true,
          options: [
            { label: 'Consultation (30 min)', value: 'consultation' },
            { label: 'Full Session (60 min)', value: 'full_session' },
            { label: 'Follow-up (15 min)', value: 'followup' },
          ],
          order: 1,
        },
        {
          id: 'date',
          type: 'DATE',
          label: 'Preferred Date',
          required: true,
          order: 2,
        },
        {
          id: 'time_slot',
          type: 'SELECT',
          label: 'Time Slot',
          required: true,
          options: [
            { label: '09:00 - 10:00', value: '09:00-10:00' },
            { label: '10:00 - 11:00', value: '10:00-11:00' },
            { label: '11:00 - 12:00', value: '11:00-12:00' },
            { label: '14:00 - 15:00', value: '14:00-15:00' },
            { label: '15:00 - 16:00', value: '15:00-16:00' },
            { label: '16:00 - 17:00', value: '16:00-17:00' },
          ],
          order: 3,
        },
        {
          id: 'customer_name',
          type: 'TEXT',
          label: 'Full Name',
          required: true,
          order: 4,
        },
        {
          id: 'email',
          type: 'EMAIL',
          label: 'Email Address',
          required: true,
          order: 5,
        },
        {
          id: 'phone',
          type: 'TEL',
          label: 'Phone Number',
          required: true,
          order: 6,
        },
        {
          id: 'notes',
          type: 'TEXTAREA',
          label: 'Additional Notes',
          required: false,
          order: 7,
        },
      ],
    };

    const businessLogicConfig = {
      type: 'appointment',
      dateField: 'date',
      timeSlotField: 'time_slot',
      maxBookingsPerSlot: 3,
      bookingsTable: 'appointment_bookings',
      requireConfirmation: true,
    };

    await client.query(
      `
      INSERT INTO form_templates (
        name,
        category,
        description,
        template_schema,
        business_logic_config,
        is_active
      ) VALUES ($1, $2, $3, $4, $5, $6)
    `,
      [
        'Appointment Booking',
        'SERVICES',
        'Service provider appointment booking with automatic conflict detection and time slot management',
        JSON.stringify(templateSchema),
        JSON.stringify(businessLogicConfig),
        true,
      ]
    );

    console.log('✓ Appointment Booking template seeded successfully');

    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error seeding appointment template:', error);
    throw error;
  } finally {
    client.release();
  }
}
```

---

## Tasks

| ID        | Task                                                                         | Acceptance Criteria | Estimated Hours |
| --------- | ---------------------------------------------------------------------------- | ------------------- | --------------- |
| 1         | Create database migration for `appointment_bookings` table                   | AC4                 | 1.5             |
| 2         | Extend shared types with `AppointmentLogicConfig` and `AppointmentBooking`   | AC3                 | 1.0             |
| 3         | Implement `AppointmentBookingRepository` with row-level locking              | AC6                 | 3.0             |
| 4         | Create `AppointmentExecutor` strategy class implementing `ITemplateExecutor` | AC5, AC6, AC7       | 4.0             |
| 5         | Integrate `AppointmentExecutor` into `FormsService.submitForm()`             | AC8                 | 2.0             |
| 6         | Create `/api/public/forms/:shortCode/available-slots` endpoint               | AC9                 | 2.5             |
| 7         | Extend `FormRendererService` with `getAvailableSlots()` method               | AC9                 | 1.0             |
| 8         | Create `AvailableSlotsComponent` with calendar and slot selection            | AC9                 | 5.0             |
| 9         | Integrate `AvailableSlotsComponent` with `FormRendererComponent`             | AC9                 | 1.5             |
| 10        | Write backend unit tests for `AppointmentExecutor`                           | AC5-AC8             | 3.0             |
| 11        | Write backend integration tests with concurrent booking scenarios            | IV3                 | 4.0             |
| 12        | Write frontend component tests for `AvailableSlotsComponent`                 | AC9                 | 2.5             |
| 13        | Create seed data for appointment template                                    | AC1, AC2            | 1.5             |
| 14        | Write performance tests validating 150ms execution time                      | IV2                 | 1.5             |
| **Total** |                                                                              |                     | **34.0 hours**  |

---

## QA Results

_To be updated during development_

| Test Type         | Status  | Coverage                 | Notes |
| ----------------- | ------- | ------------------------ | ----- |
| Unit Tests        | Pending | Target: 90%+             | -     |
| Integration Tests | Pending | -                        | -     |
| Component Tests   | Pending | Target: 85%+             | -     |
| Performance Tests | Pending | Target: 150ms P95        | -     |
| Concurrent Tests  | Pending | 20 requests → 3 bookings | -     |

---

## Gate Status

**Quality Gate**: ❌ Not Started

**Checklist**:

- [ ] Database migration applied successfully
- [ ] All unit tests passing (90%+ coverage for executor)
- [ ] All integration tests passing (including concurrent scenarios)
- [ ] All component tests passing
- [ ] Performance requirement met (150ms P95)
- [ ] Concurrent booking test passes (20 requests → max 3 bookings per slot)
- [ ] No regression in existing date/time field functionality
- [ ] Code reviewed and approved
- [ ] TypeScript strict mode passing with no errors
- [ ] ESLint passing with no warnings

---

## Related Documentation

- **PRD**: docs/prd/epic-29-form-templates-system.md
- **Architecture**: docs/architecture/backend-architecture.md (Repository Pattern, Strategy Pattern,
  Transaction Management)
- **Architecture**: docs/architecture/database-schema.md (PostgreSQL Best Practices, Row-Level
  Locking)
- **Architecture**: docs/architecture/frontend-architecture.md (Signal-based State, Standalone
  Components)
- **Related Stories**:
  - Story 29.11: Product Template with Inventory Tracking (Base ITemplateExecutor Interface)
  - Story 29.13: Quiz Template with Scoring Logic (Next executor implementation)
- **Gate File**: docs/qa/gates/29.12-appointment-booking-template-time-slot-management.yml (to be
  created)

---

## Notes

### Transaction Handling Pattern

**Critical**: This story establishes the transaction pattern for all template executors:

1. **Service Layer Controls Transactions**: `FormsService.submitForm()` manages
   BEGIN/COMMIT/ROLLBACK
2. **Executor Receives Client**: Executors receive `PoolClient` parameter (no internal transaction
   management)
3. **Compensating Transactions**: On executor failure, service layer deletes submission record
4. **Row-Level Locking**: Prevents race conditions with `SELECT FOR UPDATE` in `getBookingCount()`

### Performance Optimization

**Indexing Strategy**:

- Composite index on `(form_id, date, time_slot)` with `WHERE status = 'confirmed'` partial index
- Date index for calendar queries
- Both indexes support fast conflict detection (< 150ms target)

### Frontend UX Considerations

**Available Slots Component**:

- Color-coded slots: Green (available), Orange (limited), Gray (full)
- Real-time capacity display (e.g., "3/5 available")
- Inline calendar with disabled past dates
- Responsive grid layout for time slots

### Double-Booking Prevention

**Concurrency Control**:

1. `getBookingCount()` uses `FOR UPDATE` to lock matching rows
2. Transaction holds lock until COMMIT
3. Concurrent requests queue (FIFO)
4. First request gets slot, others see incremented count
5. Integration test validates with 20 concurrent requests → exactly 3 bookings succeed

---

_Story created: 2025-01-09_ _Last updated: 2025-01-09_
