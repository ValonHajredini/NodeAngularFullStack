# Story 29.12: Appointment Booking Template with Time Slot Management

**Epic**: Epic 29 - Form Template System with Business Logic

**Story ID**: 29.12

**Status**: Review

**Story Points**: 8 **Priority**: High **Risk Level**: High (Concurrent booking conflicts)
**Dependencies**: Stories 29.1-29.5 (Backend Foundation), 29.11 (Base Executor Interface) **Related
Stories**: 29.13-29.15 (Other Template Types)

---

## User Story

**As a** service provider, **I want** an appointment booking template with conflict prevention, **so
that** customers can book without double-booking.

---

## Acceptance Criteria

| ID  | Criterion                                                                                                   | Validated By      |
| --- | ----------------------------------------------------------------------------------------------------------- | ----------------- |
| AC1 | "Appointment Booking" template created with category `SERVICES`                                             | Unit Tests        |
| AC2 | Schema: Service Type, Preferred Date, Time Slot, Customer Name, Email, Phone                                | Unit Tests        |
| AC3 | Business logic config: `{type: 'appointment', timeSlotField, dateField, maxBookingsPerSlot, bookingsTable}` | Unit Tests        |
| AC4 | `appointment_bookings` table: `id`, `form_id`, `date`, `time_slot`, `booked_at`, `status`                   | Migration Script  |
| AC5 | `AppointmentExecutor` strategy class created                                                                | Unit Tests        |
| AC6 | Checks existing bookings count                                                                              | Integration Tests |
| AC7 | Rejects if count >= maxBookingsPerSlot                                                                      | Integration Tests |
| AC8 | Inserts booking with status `confirmed`                                                                     | Integration Tests |
| AC9 | Frontend fetches available slots, disables booked ones                                                      | Component Tests   |

---

## Integration Verification

| ID  | Verification                               | Test Method       |
| --- | ------------------------------------------ | ----------------- |
| IV1 | Existing date/time fields unchanged        | Regression Tests  |
| IV2 | Booking logic executes within 150ms        | Performance Tests |
| IV3 | Conflict detection prevents double-booking | Concurrent Tests  |

---

## Dev Notes

### Architecture Context

**Source**: docs/architecture/backend-architecture.md (Repository Pattern),
docs/architecture/database-schema.md (PostgreSQL Best Practices)

This story implements the second template business logic executor following the Strategy Pattern
established in Story 29.11. The `AppointmentExecutor` handles time slot conflict detection with
transaction support to prevent double-booking scenarios.

**Key Architectural Patterns**:

1. **Strategy Pattern**: `AppointmentExecutor` implements `ITemplateExecutor` interface (defined in
   Story 29.11)
2. **Repository Pattern**: `AppointmentBookingRepository` encapsulates database operations
3. **Transaction Management**: Uses PostgreSQL transactions with row-level locking for conflict
   prevention
4. **Service Integration**: Integrates with `FormsService.submitForm()` workflow

**Performance Requirements**:

- Booking validation + conflict check: < 150ms (P95)
- Available slots API response: < 100ms (P95)
- Concurrent booking test: 20 simultaneous requests, max 5 bookings per slot

---

### Database Schema

**New Table Migration**:
`apps/forms-api/database/migrations/032_create_appointment_bookings_table.sql`

```sql
-- Create appointment_bookings table for time slot management
CREATE TABLE appointment_bookings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    form_id UUID NOT NULL REFERENCES forms(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    time_slot VARCHAR(50) NOT NULL,
    booked_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) NOT NULL DEFAULT 'confirmed' CHECK (status IN ('confirmed', 'cancelled', 'completed')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Index for fast conflict detection
CREATE INDEX idx_appointment_bookings_form_date_slot ON appointment_bookings(form_id, date, time_slot) WHERE status = 'confirmed';

-- Index for calendar queries
CREATE INDEX idx_appointment_bookings_date ON appointment_bookings(date, status);

-- Trigger for updated_at
CREATE TRIGGER update_appointment_bookings_updated_at
BEFORE UPDATE ON appointment_bookings
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Comments
COMMENT ON TABLE appointment_bookings IS 'Stores appointment bookings with conflict detection support for template business logic';
COMMENT ON COLUMN appointment_bookings.time_slot IS 'Time slot identifier (e.g., "09:00-10:00", "morning", custom labels)';
COMMENT ON COLUMN appointment_bookings.status IS 'Booking status: confirmed (active), cancelled (user cancelled), completed (past appointment)';
```

**Down Migration**:
`apps/forms-api/database/migrations/DOWN_032_remove_appointment_bookings_table.sql`

```sql
DROP TRIGGER IF EXISTS update_appointment_bookings_updated_at ON appointment_bookings;
DROP INDEX IF EXISTS idx_appointment_bookings_form_date_slot;
DROP INDEX IF EXISTS idx_appointment_bookings_date;
DROP TABLE IF EXISTS appointment_bookings;
```

---

### Backend Implementation

#### 1. Shared Types Extension

**File**: `packages/shared/src/types/templates.types.ts`

**NOTE**: The `AppointmentConfig` type already exists in shared types. Verify it matches
requirements:

```typescript
/**
 * Business logic configuration for appointment booking templates
 * @existing - Already defined in packages/shared/src/types/templates.types.ts
 * @since Epic 29, Story 29.12
 */
export interface AppointmentConfig {
  type: 'appointment';
  timeSlotField: string; // Field ID containing time slot selection
  dateField: string; // Field ID containing date selection
  maxBookingsPerSlot: number; // Maximum concurrent bookings per slot (1-100)
  bookingsTable: string; // Database table storing existing bookings
  allowOverbook?: boolean; // Optional: Whether to allow overbooking beyond maxBookingsPerSlot
}

/**
 * Appointment booking record
 * @since Epic 29, Story 29.12
 */
export interface AppointmentBooking {
  id: string;
  form_id: string;
  date: string; // ISO date format YYYY-MM-DD
  time_slot: string; // Time slot identifier
  booked_at: Date;
  status: 'confirmed' | 'cancelled' | 'completed';
  created_at: Date;
  updated_at: Date;
}

/**
 * Available slot information
 * @since Epic 29, Story 29.12
 */
export interface AvailableSlot {
  date: string;
  time_slot: string;
  available_capacity: number;
  max_capacity: number;
  is_available: boolean;
}
```

**Verify union type includes AppointmentConfig**:

```typescript
export type TemplateBusinessLogicConfig =
  | InventoryConfig
  | AppointmentConfig
  | QuizConfig
  | PollConfig
  | OrderConfig;
```

**NOTE**: This union type already exists. No changes needed if AppointmentConfig is already
included.

Rebuild shared package after type verification:

```bash
npm run build:shared
```

---

#### 2. Repository Layer

**File**: `apps/forms-api/src/repositories/appointment-booking.repository.ts`

```typescript
import { Pool, PoolClient } from 'pg';
import { AppointmentBooking, AvailableSlot } from '@nodeangularfullstack/shared';

/**
 * Repository for appointment booking data access
 * @since Epic 29, Story 29.12
 * @source docs/architecture/backend-architecture.md (Repository Pattern)
 */
export class AppointmentBookingRepository {
  constructor(private readonly pool: Pool) {}

  /**
   * Check booking count for a specific slot (transaction-safe)
   * Uses row-level locking to prevent race conditions
   *
   * @param client - Database client (transaction context)
   * @param formId - Form UUID
   * @param date - ISO date YYYY-MM-DD
   * @param timeSlot - Time slot identifier
   * @returns Number of confirmed bookings
   */
  async getBookingCount(
    client: PoolClient,
    formId: string,
    date: string,
    timeSlot: string
  ): Promise<number> {
    const query = `
      SELECT COUNT(*) as count
      FROM appointment_bookings
      WHERE form_id = $1
        AND date = $2
        AND time_slot = $3
        AND status = 'confirmed'
      FOR UPDATE
    `;

    const result = await client.query(query, [formId, date, timeSlot]);
    return parseInt(result.rows[0].count, 10);
  }

  /**
   * Create appointment booking
   *
   * @param client - Database client (transaction context)
   * @param formId - Form UUID
   * @param date - ISO date YYYY-MM-DD
   * @param timeSlot - Time slot identifier
   * @returns Created booking record
   */
  async createBooking(
    client: PoolClient,
    formId: string,
    date: string,
    timeSlot: string
  ): Promise<AppointmentBooking> {
    const query = `
      INSERT INTO appointment_bookings (form_id, date, time_slot, status)
      VALUES ($1, $2, $3, 'confirmed')
      RETURNING *
    `;

    const result = await client.query(query, [formId, date, timeSlot]);
    return result.rows[0];
  }

  /**
   * Get available slots for a date range
   * Returns availability information without locking
   *
   * @param formId - Form UUID
   * @param startDate - Start date ISO YYYY-MM-DD
   * @param endDate - End date ISO YYYY-MM-DD
   * @param maxBookingsPerSlot - Maximum capacity per slot
   * @returns Array of available slots
   */
  async getAvailableSlots(
    formId: string,
    startDate: string,
    endDate: string,
    maxBookingsPerSlot: number
  ): Promise<AvailableSlot[]> {
    const query = `
      WITH booking_counts AS (
        SELECT
          date,
          time_slot,
          COUNT(*) as booked_count
        FROM appointment_bookings
        WHERE form_id = $1
          AND date BETWEEN $2 AND $3
          AND status = 'confirmed'
        GROUP BY date, time_slot
      )
      SELECT
        bc.date,
        bc.time_slot,
        ($4 - bc.booked_count) as available_capacity,
        $4 as max_capacity,
        (bc.booked_count < $4) as is_available
      FROM booking_counts bc
      ORDER BY bc.date, bc.time_slot
    `;

    const result = await this.pool.query(query, [formId, startDate, endDate, maxBookingsPerSlot]);
    return result.rows;
  }

  /**
   * Cancel booking by ID
   *
   * @param bookingId - Booking UUID
   * @returns Updated booking record
   */
  async cancelBooking(bookingId: string): Promise<AppointmentBooking | null> {
    const query = `
      UPDATE appointment_bookings
      SET status = 'cancelled', updated_at = CURRENT_TIMESTAMP
      WHERE id = $1 AND status = 'confirmed'
      RETURNING *
    `;

    const result = await this.pool.query(query, [bookingId]);
    return result.rows[0] || null;
  }
}
```

**Testing Note**: Repository uses `PoolClient` parameter for transaction context (not internal
BEGIN/COMMIT). This allows service layer to control transaction boundaries.

---

#### 3. Executor Strategy Class

**File**: `apps/forms-api/src/services/executors/appointment.executor.ts`

```typescript
import { PoolClient } from 'pg';
import {
  ITemplateExecutor,
  ExecutorValidation,
  ExecutorResult,
  FormTemplate,
  FormSubmission,
  AppointmentConfig,
} from '@nodeangularfullstack/shared';
import { AppointmentBookingRepository } from '../../repositories/appointment-booking.repository';
import { ApiError } from '../../utils/api-error';

/**
 * Appointment booking executor with conflict detection
 * Prevents double-booking using transaction-level locking
 *
 * @since Epic 29, Story 29.12
 * @implements ITemplateExecutor (Story 29.11)
 * @source docs/architecture/backend-architecture.md (Strategy Pattern)
 */
export class AppointmentExecutor implements ITemplateExecutor {
  constructor(private readonly bookingRepo: AppointmentBookingRepository) {}

  /**
   * Validate appointment booking data
   * Checks required fields and date/time format
   */
  async validate(
    submission: Partial<FormSubmission>,
    template: FormTemplate,
    config: AppointmentConfig
  ): Promise<ExecutorValidation> {
    const errors: string[] = [];
    const data = submission.data as Record<string, any>;

    // Validate date field
    const date = data[config.dateField];
    if (!date) {
      errors.push(`Date field '${config.dateField}' is required`);
    } else if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      errors.push('Date must be in YYYY-MM-DD format');
    } else {
      const bookingDate = new Date(date);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      if (bookingDate < today) {
        errors.push('Cannot book appointments in the past');
      }
    }

    // Validate time slot field
    const timeSlot = data[config.timeSlotField];
    if (!timeSlot || typeof timeSlot !== 'string' || timeSlot.trim() === '') {
      errors.push(`Time slot field '${config.timeSlotField}' is required`);
    }

    // Validate maxBookingsPerSlot
    if (config.maxBookingsPerSlot < 1 || config.maxBookingsPerSlot > 100) {
      errors.push('maxBookingsPerSlot must be between 1 and 100');
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Execute appointment booking with conflict detection
   * Uses transaction and row-level locking to prevent double-booking
   *
   * @param submission - Form submission record
   * @param template - Template configuration
   * @param config - Appointment logic configuration
   * @param client - Database client (transaction context)
   * @returns Executor result with booking details
   * @throws ApiError if slot is fully booked
   */
  async execute(
    submission: FormSubmission,
    template: FormTemplate,
    config: AppointmentConfig,
    client: PoolClient
  ): Promise<ExecutorResult> {
    const data = submission.data as Record<string, any>;
    const date = data[config.dateField];
    const timeSlot = data[config.timeSlotField];

    // Check existing bookings with row-level lock
    const currentBookings = await this.bookingRepo.getBookingCount(
      client,
      submission.form_id,
      date,
      timeSlot
    );

    // Reject if fully booked
    if (currentBookings >= config.maxBookingsPerSlot) {
      throw new ApiError(
        409, // HTTP 409 Conflict
        `Time slot ${timeSlot} on ${date} is fully booked (${currentBookings}/${config.maxBookingsPerSlot})`
      );
    }

    // Create booking
    const booking = await this.bookingRepo.createBooking(
      client,
      submission.form_id,
      date,
      timeSlot
    );

    return {
      success: true,
      data: {
        booking_id: booking.id,
        date: booking.date,
        time_slot: booking.time_slot,
        status: booking.status,
        capacity: {
          current: currentBookings + 1,
          max: config.maxBookingsPerSlot,
          available: config.maxBookingsPerSlot - currentBookings - 1,
        },
      },
      message: 'Appointment booked successfully',
    };
  }
}
```

**Error Handling Note**: Uses HTTP 409 Conflict status code for double-booking attempts (per REST
best practices).

---

#### 4. Registry Integration

**File**: `apps/forms-api/src/services/template-executor-registry.service.ts`

**Register AppointmentExecutor in the existing registry**:

```typescript
import { AppointmentExecutor } from './template-executors/appointment.executor';
import { AppointmentBookingRepository } from '../repositories/appointment-booking.repository';

/**
 * Initializes executor registry with all available executors.
 * Called automatically on first use (lazy initialization).
 */
private static initializeExecutors(): void {
  if (this.executors.size === 0) {
    // Register inventory executor (Story 29.11)
    this.executors.set('inventory', new InventoryExecutor(inventoryRepository));

    // Register appointment executor (Story 29.12 - NEW)
    const appointmentBookingRepo = new AppointmentBookingRepository(pool);
    this.executors.set('appointment', new AppointmentExecutor(appointmentBookingRepo));

    // Future executors will be registered here:
    // this.executors.set('quiz', new QuizExecutor(...));
    // this.executors.set('poll', new PollExecutor(...));
    // this.executors.set('order', new OrderExecutor(...));
  }
}
```

**No changes needed to FormsService** - it already uses `TemplateExecutorRegistry`:

```typescript
// FormsService.submitForm() already handles template executors via registry
// Example flow (existing code):
async submitForm(shortCode: string, submissionData: any): Promise<FormSubmission> {
  const form = await this.formsRepo.getFormByShortCode(shortCode);
  const template = form.template_id
    ? await this.templatesRepo.getTemplateById(form.template_id)
    : null;

  // Validation (uses registry internally)
  if (template?.businessLogicConfig) {
    const validation = await TemplateExecutorRegistry.validateBeforeSubmission(
      { data: submissionData },
      template
    );
    if (!validation.valid) {
      throw new ApiError(400, validation.errors.join(', '));
    }
  }

  // Create submission
  const submission = await this.submissionsRepo.create({
    form_id: form.id,
    data: submissionData,
    submitted_at: new Date()
  });

  // Execute business logic (uses registry internally)
  if (template?.businessLogicConfig) {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      const result = await TemplateExecutorRegistry.executeAfterSubmission(
        submission,
        template,
        client // Pass transaction client
      );

      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      await this.submissionsRepo.delete(submission.id); // Compensating transaction
      throw error;
    } finally {
      client.release();
    }
  }

  return submission;
}
```

**Note**: The registry's `executeAfterSubmission` method signature needs updating to accept `client`
parameter. Update Story 29.11 registry implementation accordingly.

---

#### 5. Controller Endpoint for Available Slots

**File**: `apps/forms-api/src/controllers/forms.controller.ts`

Add new endpoint:

```typescript
import { AppointmentBookingRepository } from '../repositories/appointment-booking.repository';

/**
 * GET /api/public/forms/:shortCode/available-slots
 * Get available appointment slots for a date range
 *
 * @query startDate - Start date YYYY-MM-DD (required)
 * @query endDate - End date YYYY-MM-DD (required)
 * @returns Array of available slots
 * @since Epic 29, Story 29.12
 */
router.get(
  '/:shortCode/available-slots',
  asyncHandler(async (req: Request, res: Response) => {
    const { shortCode } = req.params;
    const { startDate, endDate } = req.query;

    // Validate query parameters
    if (!startDate || !endDate) {
      throw new ApiError(400, 'startDate and endDate query parameters are required');
    }

    if (
      !/^\d{4}-\d{2}-\d{2}$/.test(startDate as string) ||
      !/^\d{4}-\d{2}-\d{2}$/.test(endDate as string)
    ) {
      throw new ApiError(400, 'Dates must be in YYYY-MM-DD format');
    }

    // Get form and template
    const form = await formsService.getFormByShortCode(shortCode);
    if (!form?.template_id) {
      throw new ApiError(404, 'Form not found or does not use appointment template');
    }

    const template = await templatesService.getTemplateById(form.template_id);
    if (template.business_logic_config?.type !== 'appointment') {
      throw new ApiError(400, 'Form does not use appointment booking template');
    }

    // Get available slots
    const bookingRepo = new AppointmentBookingRepository(pool);
    const slots = await bookingRepo.getAvailableSlots(
      form.id,
      startDate as string,
      endDate as string,
      template.business_logic_config.maxBookingsPerSlot
    );

    res.json({
      success: true,
      data: slots,
      message: 'Available slots retrieved successfully',
    });
  })
);
```

---

### Frontend Implementation

#### 1. API Service Extension

**File**: `apps/form-builder-ui/src/app/features/public/form-renderer/form-renderer.service.ts`

Add available slots method:

```typescript
import { AvailableSlot } from '@nodeangularfullstack/shared';

/**
 * Get available appointment slots
 * @param shortCode - Form short code
 * @param startDate - Start date YYYY-MM-DD
 * @param endDate - End date YYYY-MM-DD
 * @returns Observable of available slots
 * @since Epic 29, Story 29.12
 */
getAvailableSlots(
  shortCode: string,
  startDate: string,
  endDate: string
): Observable<AvailableSlot[]> {
  const params = new HttpParams()
    .set('startDate', startDate)
    .set('endDate', endDate);

  return this.http.get<ApiResponse<AvailableSlot[]>>(
    `${this.apiUrl}/api/public/forms/${shortCode}/available-slots`,
    { params }
  ).pipe(
    map(response => response.data)
  );
}
```

---

#### 2. Available Slots Display Component

**File**:
`apps/form-builder-ui/src/app/features/public/form-renderer/available-slots/available-slots.component.ts`

```typescript
import {
  Component,
  computed,
  inject,
  input,
  OnInit,
  signal,
  ChangeDetectionStrategy,
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { CalendarModule } from 'primeng/calendar';
import { ChipModule } from 'primeng/chip';
import { FormRendererService } from '../form-renderer.service';
import { AvailableSlot } from '@nodeangularfullstack/shared';

/**
 * Component displays available appointment slots for a date range
 * Integrates with appointment booking template
 *
 * @since Epic 29, Story 29.12
 * @source docs/architecture/frontend-architecture.md (Signal-based State)
 */
@Component({
  selector: 'app-available-slots',
  standalone: true,
  imports: [CommonModule, CalendarModule, ChipModule],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="available-slots-container">
      <h3>Select Date and Time</h3>

      <!-- Date Selection -->
      <p-calendar
        [(ngModel)]="selectedDate"
        [minDate]="minDate()"
        [inline]="true"
        dateFormat="yy-mm-dd"
        (onSelect)="handleDateChange($event)"
      />

      <!-- Time Slots for Selected Date -->
      @if (selectedDate && slotsForDate().length > 0) {
        <div class="time-slots-grid">
          @for (slot of slotsForDate(); track slot.time_slot) {
            <p-chip
              [label]="slot.time_slot"
              [styleClass]="getSlotClass(slot)"
              (click)="selectSlot(slot)"
              [disabled]="!slot.is_available"
            >
              <span class="capacity-badge">
                {{ slot.available_capacity }}/{{ slot.max_capacity }}
              </span>
            </p-chip>
          }
        </div>
      }

      @if (selectedSlot()) {
        <div class="selected-slot-info">
          <strong>Selected:</strong> {{ formatSlot(selectedSlot()) }}
        </div>
      }

      @if (loading()) {
        <div class="loading-spinner">Loading available slots...</div>
      }

      @if (error()) {
        <div class="error-message">{{ error() }}</div>
      }
    </div>
  `,
  styles: [
    `
      .available-slots-container {
        margin: 1rem 0;
      }

      .time-slots-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 0.75rem;
        margin-top: 1rem;
      }

      .capacity-badge {
        margin-left: 0.5rem;
        font-size: 0.875rem;
        color: var(--text-color-secondary);
      }

      .selected-slot-info {
        margin-top: 1rem;
        padding: 0.75rem;
        background: var(--surface-card);
        border-radius: 6px;
      }

      .loading-spinner {
        text-align: center;
        padding: 1rem;
        color: var(--text-color-secondary);
      }

      .error-message {
        color: var(--red-500);
        padding: 0.75rem;
        background: var(--red-50);
        border-radius: 6px;
        margin-top: 1rem;
      }

      /* Slot chip states */
      :host ::ng-deep {
        .slot-available {
          background: var(--green-500);
          color: white;
          cursor: pointer;
        }

        .slot-limited {
          background: var(--orange-500);
          color: white;
          cursor: pointer;
        }

        .slot-full {
          background: var(--surface-300);
          color: var(--text-color-secondary);
          cursor: not-allowed;
        }

        .slot-selected {
          background: var(--primary-color);
          color: white;
          border: 2px solid var(--primary-600);
        }
      }
    `,
  ],
})
export class AvailableSlotsComponent implements OnInit {
  // Inputs
  readonly shortCode = input.required<string>();

  // Services
  private readonly formService = inject(FormRendererService);

  // State
  readonly selectedDate = signal<Date | null>(null);
  readonly selectedSlot = signal<AvailableSlot | null>(null);
  readonly availableSlots = signal<AvailableSlot[]>([]);
  readonly loading = signal(false);
  readonly error = signal<string | null>(null);

  // Computed
  readonly minDate = computed(() => new Date());

  readonly slotsForDate = computed(() => {
    const date = this.selectedDate();
    if (!date) return [];

    const dateStr = this.formatDate(date);
    return this.availableSlots().filter((slot) => slot.date === dateStr);
  });

  ngOnInit(): void {
    this.loadNextWeekSlots();
  }

  /**
   * Load available slots for next 7 days
   */
  private loadNextWeekSlots(): void {
    const today = new Date();
    const nextWeek = new Date(today);
    nextWeek.setDate(nextWeek.getDate() + 7);

    this.loading.set(true);
    this.error.set(null);

    this.formService
      .getAvailableSlots(this.shortCode(), this.formatDate(today), this.formatDate(nextWeek))
      .subscribe({
        next: (slots) => {
          this.availableSlots.set(slots);
          this.loading.set(false);
        },
        error: (err) => {
          this.error.set('Failed to load available slots');
          this.loading.set(false);
          console.error('Error loading slots:', err);
        },
      });
  }

  /**
   * Handle date selection change
   */
  handleDateChange(event: Date): void {
    this.selectedDate.set(event);
    this.selectedSlot.set(null); // Reset slot selection
  }

  /**
   * Select a time slot
   */
  selectSlot(slot: AvailableSlot): void {
    if (!slot.is_available) return;
    this.selectedSlot.set(slot);
  }

  /**
   * Get CSS class for slot chip based on availability
   */
  getSlotClass(slot: AvailableSlot): string {
    if (this.selectedSlot()?.time_slot === slot.time_slot) {
      return 'slot-selected';
    }
    if (!slot.is_available) {
      return 'slot-full';
    }
    if (slot.available_capacity <= slot.max_capacity * 0.3) {
      return 'slot-limited';
    }
    return 'slot-available';
  }

  /**
   * Format date to YYYY-MM-DD
   */
  private formatDate(date: Date): string {
    return date.toISOString().split('T')[0];
  }

  /**
   * Format slot for display
   */
  formatSlot(slot: AvailableSlot | null): string {
    if (!slot) return '';
    return `${slot.date} at ${slot.time_slot}`;
  }
}
```

---

#### 3. Integration with FormRendererComponent

**File**: `apps/form-builder-ui/src/app/features/public/form-renderer/form-renderer.component.ts`

Add conditional slots display:

```typescript
@if (formSchema()?.template_id && isAppointmentTemplate()) {
  <app-available-slots [shortCode]="shortCode()" />
}

<!-- Existing form rendering -->
<form [formGroup]="formGroup" (ngSubmit)="onSubmit()">
  <!-- Form fields -->
</form>
```

Add template detection:

```typescript
protected readonly isAppointmentTemplate = computed(() => {
  const template = this.formSchema()?.template;
  return template?.business_logic_config?.type === 'appointment';
});
```

---

### Testing Implementation

#### 1. Backend Unit Tests

**File**: `apps/forms-api/tests/unit/services/executors/appointment.executor.test.ts`

```typescript
import { AppointmentExecutor } from '../../../../src/services/executors/appointment.executor';
import { AppointmentBookingRepository } from '../../../../src/repositories/appointment-booking.repository';
import { FormTemplate, FormSubmission, AppointmentConfig } from '@nodeangularfullstack/shared';
import { ApiError } from '../../../../src/utils/api-error';

describe('AppointmentExecutor', () => {
  let executor: AppointmentExecutor;
  let mockBookingRepo: jest.Mocked<AppointmentBookingRepository>;
  let mockClient: any;

  const mockConfig: AppointmentConfig = {
    type: 'appointment',
    timeSlotField: 'time_slot',
    dateField: 'date',
    maxBookingsPerSlot: 5,
    bookingsTable: 'appointment_bookings',
  };

  const mockTemplate: FormTemplate = {
    id: 'template-123',
    name: 'Appointment Booking',
    category: 'SERVICES',
    template_schema: {} as any,
    business_logic_config: mockConfig,
    is_active: true,
    created_at: new Date(),
    updated_at: new Date(),
  };

  beforeEach(() => {
    mockBookingRepo = {
      getBookingCount: jest.fn(),
      createBooking: jest.fn(),
    } as any;

    mockClient = {
      query: jest.fn(),
    };

    executor = new AppointmentExecutor(mockBookingRepo);
  });

  describe('validate', () => {
    it('should pass validation for valid appointment data', async () => {
      const submission = {
        data: {
          date: '2025-12-01',
          time_slot: '09:00-10:00',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(true);
      expect(result.errors).toEqual([]);
    });

    it('should fail validation for missing date', async () => {
      const submission = {
        data: {
          time_slot: '09:00-10:00',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain("Date field 'date' is required");
    });

    it('should fail validation for invalid date format', async () => {
      const submission = {
        data: {
          date: '12/01/2025',
          time_slot: '09:00-10:00',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Date must be in YYYY-MM-DD format');
    });

    it('should fail validation for past dates', async () => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const pastDate = yesterday.toISOString().split('T')[0];

      const submission = {
        data: {
          date: pastDate,
          time_slot: '09:00-10:00',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Cannot book appointments in the past');
    });

    it('should fail validation for missing time slot', async () => {
      const submission = {
        data: {
          date: '2025-12-01',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain("Time slot field 'time_slot' is required");
    });
  });

  describe('execute', () => {
    const mockSubmission: FormSubmission = {
      id: 'sub-123',
      form_id: 'form-123',
      data: {
        date: '2025-12-01',
        time_slot: '09:00-10:00',
      },
      submitted_at: new Date(),
      created_at: new Date(),
    };

    it('should create booking when slot is available', async () => {
      mockBookingRepo.getBookingCount.mockResolvedValue(2); // 2 bookings, max 5
      mockBookingRepo.createBooking.mockResolvedValue({
        id: 'booking-123',
        form_id: 'form-123',
        date: '2025-12-01',
        time_slot: '09:00-10:00',
        booked_at: new Date(),
        status: 'confirmed',
        created_at: new Date(),
        updated_at: new Date(),
      });

      const result = await executor.execute(mockSubmission, mockTemplate, mockConfig, mockClient);

      expect(result.success).toBe(true);
      expect(result.data.booking_id).toBe('booking-123');
      expect(result.data.capacity.current).toBe(3);
      expect(result.data.capacity.max).toBe(5);
      expect(result.data.capacity.available).toBe(2);
      expect(mockBookingRepo.getBookingCount).toHaveBeenCalledWith(
        mockClient,
        'form-123',
        '2025-12-01',
        '09:00-10:00'
      );
      expect(mockBookingRepo.createBooking).toHaveBeenCalled();
    });

    it('should throw ApiError 409 when slot is fully booked', async () => {
      mockBookingRepo.getBookingCount.mockResolvedValue(5); // Full capacity

      await expect(
        executor.execute(mockSubmission, mockTemplate, mockConfig, mockClient)
      ).rejects.toThrow(ApiError);

      await expect(
        executor.execute(mockSubmission, mockTemplate, mockConfig, mockClient)
      ).rejects.toMatchObject({
        statusCode: 409,
        message: expect.stringContaining('fully booked'),
      });

      expect(mockBookingRepo.createBooking).not.toHaveBeenCalled();
    });

    it('should handle edge case: last available slot', async () => {
      mockBookingRepo.getBookingCount.mockResolvedValue(4); // 4/5 booked
      mockBookingRepo.createBooking.mockResolvedValue({
        id: 'booking-last',
        form_id: 'form-123',
        date: '2025-12-01',
        time_slot: '09:00-10:00',
        booked_at: new Date(),
        status: 'confirmed',
        created_at: new Date(),
        updated_at: new Date(),
      });

      const result = await executor.execute(mockSubmission, mockTemplate, mockConfig, mockClient);

      expect(result.success).toBe(true);
      expect(result.data.capacity.available).toBe(0);
    });
  });
});
```

---

#### 2. Backend Integration Tests

**File**: `apps/forms-api/tests/integration/appointment-booking.test.ts`

```typescript
import request from 'supertest';
import app from '../../src/server';
import { pool } from '../../src/config/database';
import { PoolClient } from 'pg';

describe('Appointment Booking Integration Tests', () => {
  let client: PoolClient;
  let formShortCode: string;
  let templateId: string;

  beforeAll(async () => {
    client = await pool.connect();
    await client.query('BEGIN');

    // Create appointment template
    const templateResult = await client.query(`
      INSERT INTO form_templates (name, category, template_schema, business_logic_config, is_active)
      VALUES (
        'Test Appointment Booking',
        'SERVICES',
        '{"fields": [{"id": "date", "type": "DATE"}, {"id": "time_slot", "type": "SELECT"}]}'::jsonb,
        '{"type": "appointment", "dateField": "date", "timeSlotField": "time_slot", "maxBookingsPerSlot": 3}'::jsonb,
        true
      )
      RETURNING id
    `);
    templateId = templateResult.rows[0].id;

    // Create form with template
    const formResult = await client.query(
      `
      INSERT INTO forms (title, is_published, template_id)
      VALUES ('Appointment Test Form', true, $1)
      RETURNING id
    `,
      [templateId]
    );

    const formId = formResult.rows[0].id;

    // Create short link
    const shortLinkResult = await client.query(
      `
      INSERT INTO short_links (short_code, form_schema_id)
      VALUES ('apt-test', $1)
      RETURNING short_code
    `,
      [formId]
    );
    formShortCode = shortLinkResult.rows[0].short_code;

    await client.query('COMMIT');
  });

  afterAll(async () => {
    await client.query('ROLLBACK');
    client.release();
    await pool.end();
  });

  describe('POST /api/public/forms/:shortCode/submit', () => {
    it('should create booking when slot is available', async () => {
      const response = await request(app).post(`/api/public/forms/${formShortCode}/submit`).send({
        date: '2025-12-15',
        time_slot: '10:00-11:00',
      });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.booking_id).toBeDefined();
      expect(response.body.data.capacity.current).toBe(1);
      expect(response.body.data.capacity.max).toBe(3);
    });

    it('should reject booking for fully booked slot', async () => {
      const slotData = {
        date: '2025-12-16',
        time_slot: '14:00-15:00',
      };

      // Book 3 times (max capacity)
      await request(app).post(`/api/public/forms/${formShortCode}/submit`).send(slotData);
      await request(app).post(`/api/public/forms/${formShortCode}/submit`).send(slotData);
      await request(app).post(`/api/public/forms/${formShortCode}/submit`).send(slotData);

      // 4th booking should fail
      const response = await request(app)
        .post(`/api/public/forms/${formShortCode}/submit`)
        .send(slotData);

      expect(response.status).toBe(409);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain('fully booked');
    });

    it('should reject booking for past date', async () => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const pastDate = yesterday.toISOString().split('T')[0];

      const response = await request(app).post(`/api/public/forms/${formShortCode}/submit`).send({
        date: pastDate,
        time_slot: '10:00-11:00',
      });

      expect(response.status).toBe(400);
      expect(response.body.message).toContain('past');
    });
  });

  describe('GET /api/public/forms/:shortCode/available-slots', () => {
    it('should return available slots', async () => {
      const today = new Date().toISOString().split('T')[0];
      const nextWeek = new Date();
      nextWeek.setDate(nextWeek.getDate() + 7);
      const endDate = nextWeek.toISOString().split('T')[0];

      const response = await request(app)
        .get(`/api/public/forms/${formShortCode}/available-slots`)
        .query({ startDate: today, endDate });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(Array.isArray(response.body.data)).toBe(true);
    });

    it('should require startDate and endDate query parameters', async () => {
      const response = await request(app).get(`/api/public/forms/${formShortCode}/available-slots`);

      expect(response.status).toBe(400);
      expect(response.body.message).toContain('required');
    });

    it('should reject invalid date format', async () => {
      const response = await request(app)
        .get(`/api/public/forms/${formShortCode}/available-slots`)
        .query({ startDate: '12/01/2025', endDate: '12/08/2025' });

      expect(response.status).toBe(400);
      expect(response.body.message).toContain('format');
    });
  });

  describe('Concurrent booking conflict prevention', () => {
    it('should prevent double-booking with concurrent requests', async () => {
      const slotData = {
        date: '2025-12-20',
        time_slot: '16:00-17:00',
      };

      // Create 20 concurrent booking requests
      const promises = Array(20)
        .fill(null)
        .map(() => request(app).post(`/api/public/forms/${formShortCode}/submit`).send(slotData));

      const responses = await Promise.allSettled(promises);

      // Count successful bookings
      const successful = responses.filter(
        (r) => r.status === 'fulfilled' && r.value.status === 200
      ).length;

      // Should have exactly 3 successful bookings (maxBookingsPerSlot)
      expect(successful).toBe(3);

      // Remaining should be 409 Conflict
      const conflicts = responses.filter(
        (r) => r.status === 'fulfilled' && r.value.status === 409
      ).length;
      expect(conflicts).toBe(17);
    });
  });
});
```

---

#### 3. Frontend Component Tests

**File**:
`apps/form-builder-ui/src/app/features/public/form-renderer/available-slots/available-slots.component.spec.ts`

```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { AvailableSlotsComponent } from './available-slots.component';
import { FormRendererService } from '../form-renderer.service';
import { of, throwError } from 'rxjs';
import { AvailableSlot } from '@nodeangularfullstack/shared';
import { signal } from '@angular/core';

describe('AvailableSlotsComponent', () => {
  let component: AvailableSlotsComponent;
  let fixture: ComponentFixture<AvailableSlotsComponent>;
  let mockFormService: jasmine.SpyObj<FormRendererService>;

  const mockSlots: AvailableSlot[] = [
    {
      date: '2025-12-01',
      time_slot: '09:00-10:00',
      available_capacity: 3,
      max_capacity: 5,
      is_available: true,
    },
    {
      date: '2025-12-01',
      time_slot: '10:00-11:00',
      available_capacity: 0,
      max_capacity: 5,
      is_available: false,
    },
  ];

  beforeEach(async () => {
    mockFormService = jasmine.createSpyObj('FormRendererService', ['getAvailableSlots']);

    await TestBed.configureTestingModule({
      imports: [AvailableSlotsComponent],
      providers: [{ provide: FormRendererService, useValue: mockFormService }],
    }).compileComponents();

    fixture = TestBed.createComponent(AvailableSlotsComponent);
    component = fixture.componentInstance;
    fixture.componentRef.setInput('shortCode', 'test-form');
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should load available slots on init', () => {
    mockFormService.getAvailableSlots.and.returnValue(of(mockSlots));

    fixture.detectChanges();

    expect(mockFormService.getAvailableSlots).toHaveBeenCalled();
    expect(component.availableSlots().length).toBe(2);
    expect(component.loading()).toBe(false);
  });

  it('should filter slots by selected date', () => {
    component.availableSlots.set(mockSlots);
    component.selectedDate.set(new Date('2025-12-01'));

    const filtered = component.slotsForDate();
    expect(filtered.length).toBe(2);
  });

  it('should return correct CSS class for available slot', () => {
    const slot = mockSlots[0];
    const cssClass = component.getSlotClass(slot);
    expect(cssClass).toBe('slot-available');
  });

  it('should return correct CSS class for full slot', () => {
    const slot = mockSlots[1];
    const cssClass = component.getSlotClass(slot);
    expect(cssClass).toBe('slot-full');
  });

  it('should select slot when clicked', () => {
    component.selectSlot(mockSlots[0]);
    expect(component.selectedSlot()).toEqual(mockSlots[0]);
  });

  it('should not select full slot', () => {
    component.selectSlot(mockSlots[1]);
    expect(component.selectedSlot()).toBeNull();
  });

  it('should handle API error gracefully', () => {
    mockFormService.getAvailableSlots.and.returnValue(throwError(() => new Error('API Error')));

    fixture.detectChanges();

    expect(component.error()).toBe('Failed to load available slots');
    expect(component.loading()).toBe(false);
  });
});
```

---

### Template Seed Data

**File**: `apps/forms-api/database/seeds/032_seed_appointment_template.ts`

```typescript
import { Pool } from 'pg';

/**
 * Seed appointment booking template
 * @since Epic 29, Story 29.12
 */
export async function seedAppointmentTemplate(pool: Pool): Promise<void> {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // Check if template already exists
    const existing = await client.query(
      `SELECT id FROM form_templates WHERE name = 'Appointment Booking'`
    );

    if (existing.rows.length > 0) {
      console.log('Appointment Booking template already exists, skipping...');
      await client.query('COMMIT');
      return;
    }

    // Create template
    const templateSchema = {
      fields: [
        {
          id: 'service_type',
          type: 'SELECT',
          label: 'Service Type',
          required: true,
          options: [
            { label: 'Consultation (30 min)', value: 'consultation' },
            { label: 'Full Session (60 min)', value: 'full_session' },
            { label: 'Follow-up (15 min)', value: 'followup' },
          ],
          order: 1,
        },
        {
          id: 'date',
          type: 'DATE',
          label: 'Preferred Date',
          required: true,
          order: 2,
        },
        {
          id: 'time_slot',
          type: 'SELECT',
          label: 'Time Slot',
          required: true,
          options: [
            { label: '09:00 - 10:00', value: '09:00-10:00' },
            { label: '10:00 - 11:00', value: '10:00-11:00' },
            { label: '11:00 - 12:00', value: '11:00-12:00' },
            { label: '14:00 - 15:00', value: '14:00-15:00' },
            { label: '15:00 - 16:00', value: '15:00-16:00' },
            { label: '16:00 - 17:00', value: '16:00-17:00' },
          ],
          order: 3,
        },
        {
          id: 'customer_name',
          type: 'TEXT',
          label: 'Full Name',
          required: true,
          order: 4,
        },
        {
          id: 'email',
          type: 'EMAIL',
          label: 'Email Address',
          required: true,
          order: 5,
        },
        {
          id: 'phone',
          type: 'TEL',
          label: 'Phone Number',
          required: true,
          order: 6,
        },
        {
          id: 'notes',
          type: 'TEXTAREA',
          label: 'Additional Notes',
          required: false,
          order: 7,
        },
      ],
    };

    const businessLogicConfig = {
      type: 'appointment',
      dateField: 'date',
      timeSlotField: 'time_slot',
      maxBookingsPerSlot: 3,
      bookingsTable: 'appointment_bookings',
      requireConfirmation: true,
    };

    await client.query(
      `
      INSERT INTO form_templates (
        name,
        category,
        description,
        template_schema,
        business_logic_config,
        is_active
      ) VALUES ($1, $2, $3, $4, $5, $6)
    `,
      [
        'Appointment Booking',
        'SERVICES',
        'Service provider appointment booking with automatic conflict detection and time slot management',
        JSON.stringify(templateSchema),
        JSON.stringify(businessLogicConfig),
        true,
      ]
    );

    console.log('✓ Appointment Booking template seeded successfully');

    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error seeding appointment template:', error);
    throw error;
  } finally {
    client.release();
  }
}
```

---

## Tasks

| ID        | Task                                                                         | Acceptance Criteria | Estimated Hours |
| --------- | ---------------------------------------------------------------------------- | ------------------- | --------------- |
| 1         | Create database migration for `appointment_bookings` table                   | AC4                 | 1.5             |
| 2         | Verify shared types `AppointmentConfig` and add `AppointmentBooking` types   | AC3                 | 1.0             |
| 3         | Implement `AppointmentBookingRepository` with row-level locking              | AC6                 | 3.0             |
| 4         | Create `AppointmentExecutor` strategy class implementing `ITemplateExecutor` | AC5, AC6, AC7       | 4.0             |
| 5         | Integrate `AppointmentExecutor` into `FormsService.submitForm()`             | AC8                 | 2.0             |
| 6         | Create `/api/public/forms/:shortCode/available-slots` endpoint               | AC9                 | 2.5             |
| 7         | Extend `FormRendererService` with `getAvailableSlots()` method               | AC9                 | 1.0             |
| 8         | Create `AvailableSlotsComponent` with calendar and slot selection            | AC9                 | 5.0             |
| 9         | Integrate `AvailableSlotsComponent` with `FormRendererComponent`             | AC9                 | 1.5             |
| 10        | Write backend unit tests for `AppointmentExecutor`                           | AC5-AC8             | 3.0             |
| 11        | Write backend integration tests with concurrent booking scenarios            | IV3                 | 4.0             |
| 12        | Write frontend component tests for `AvailableSlotsComponent`                 | AC9                 | 2.5             |
| 13        | Create seed data for appointment template                                    | AC1, AC2            | 1.5             |
| 14        | Write performance tests validating 150ms execution time                      | IV2                 | 1.5             |
| **Total** |                                                                              |                     | **34.0 hours**  |

---

## QA Results

### Review Date: 2025-11-09

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Score: 78/100** - Strong implementation with excellent code quality but missing critical
test coverage.

The implementation demonstrates exemplary architectural patterns and code quality. The executor
follows the Strategy Pattern correctly with comprehensive validation logic. Row-level locking
(SELECT FOR UPDATE) is properly implemented to prevent race conditions. However, the story is marked
"Review" without completing all critical test coverage requirements.

**Strengths:**

- ✅ Excellent database schema design with partial indexes for performance optimization
- ✅ Comprehensive executor validation with ISO 8601 date format enforcement
- ✅ Transaction safety with proper row-level locking to prevent double-booking
- ✅ Thorough unit test coverage (36 tests, all passing, >95% code coverage)
- ✅ Proper camelCase column mapping in repository for TypeScript consistency
- ✅ Well-documented code with JSDoc comments and usage examples
- ✅ Frontend component with signal-based state management (Angular 20+ best practices)
- ✅ Responsive HTML template with PrimeNG components

**Critical Gaps:**

- ❌ **MISSING**: Integration tests for concurrent booking scenarios (AC6, AC7, AC8, IV3)
- ❌ **MISSING**: Frontend component unit tests (AC9, Task 12)
- ❌ **MISSING**: Performance benchmarks validating 150ms P95 requirement (IV2, Task 14)
- ❌ **MISSING**: Seed data for appointment template (Task 13)
- ⚠️ **CONCERN**: Available slots component not integrated with form renderer (AC9 incomplete)

### Refactoring Performed

No refactoring was performed during this review. The code quality is excellent as-is, and changes
should focus on completing missing test coverage rather than modifying existing implementations.

### Compliance Check

- **Coding Standards**: ✅ **PASS** - Follows TypeScript strict mode, ESLint rules, proper error
  handling
- **Project Structure**: ✅ **PASS** - Correct directory structure for executors, repositories,
  migrations
- **Testing Strategy**: ❌ **FAIL** - Missing integration tests, component tests, and performance
  tests
- **All ACs Met**: ⚠️ **PARTIAL** - Core logic implemented but validation gaps exist

### Acceptance Criteria Status

| AC  | Criterion                               | Status      | Evidence                                 |
| --- | --------------------------------------- | ----------- | ---------------------------------------- |
| AC1 | Template created with category SERVICES | ⚠️ PARTIAL  | Shared types exist, seed data missing    |
| AC2 | Schema with required fields             | ✅ COMPLETE | Migration 032 validates schema           |
| AC3 | Business logic config structure         | ✅ COMPLETE | AppointmentConfig in shared types        |
| AC4 | Database table created                  | ✅ COMPLETE | Migration 032 with proper indexes        |
| AC5 | AppointmentExecutor strategy class      | ✅ COMPLETE | Implements ITemplateExecutor             |
| AC6 | Checks existing bookings count          | ✅ COMPLETE | getBookingCount with FOR UPDATE          |
| AC7 | Rejects if count >= max                 | ✅ COMPLETE | SLOT_FULL error with HTTP 409            |
| AC8 | Inserts booking with confirmed status   | ✅ COMPLETE | createBooking method validated           |
| AC9 | Frontend fetches/disables booked slots  | ⚠️ PARTIAL  | Component exists, integration incomplete |

### Integration Verification Status

| IV  | Verification                               | Status     | Evidence                    |
| --- | ------------------------------------------ | ---------- | --------------------------- |
| IV1 | Existing date/time fields unchanged        | ✅ PASS    | No conflicts found          |
| IV2 | Booking logic executes within 150ms        | ❌ MISSING | No performance benchmarks   |
| IV3 | Conflict detection prevents double-booking | ❌ MISSING | No concurrent test executed |

### Test Coverage Analysis

**Backend Unit Tests:** ✅ **EXCELLENT** (36/36 passing, ~95%+ coverage)

- Comprehensive validation test scenarios
- Edge case coverage (leap years, invalid dates, whitespace handling)
- Transaction flow testing (commit/rollback scenarios)
- Error handling verification

**Backend Integration Tests:** ❌ **MISSING** (Task 11)

- No tests for form submission workflow with template execution
- **CRITICAL**: No concurrent booking test (20 simultaneous requests scenario)
- No available slots endpoint integration test

**Frontend Component Tests:** ❌ **MISSING** (Task 12)

- AvailableSlotsComponent has no spec file
- No validation of signal-based state management
- No testing of slot selection behavior

**Performance Tests:** ❌ **MISSING** (Task 14)

- No benchmarks for 150ms P95 execution time requirement
- No load testing for concurrent scenarios

### Security Review

✅ **PASS** - No security vulnerabilities identified.

**Strengths:**

- ISO 8601 date format validation prevents injection attacks
- Time slot length validation (max 50 chars) prevents abuse
- Row-level locking prevents timing attack exploits
- Proper transaction isolation prevents race conditions
- Type validation for all inputs (string/non-string checks)

**Recommendations:**

- Consider rate limiting for slot availability endpoint (prevent abuse via rapid queries)
- Add CSRF protection for booking submission endpoints (if not already present)

### Performance Considerations

**Database Performance:** ✅ **EXCELLENT**

- Partial index on `(form_id, date, time_slot) WHERE status = 'confirmed'` reduces index size
- Composite index optimal for conflict detection query
- Row-level locking minimal overhead with proper index usage

**Concerns:**

- ❌ **UNVALIDATED**: 150ms P95 execution time requirement (IV2) has no benchmark
- ⚠️ **POTENTIAL ISSUE**: Available slots query may be slow for large date ranges (no LIMIT clause)
- ✅ **OPTIMIZED**: Repository uses connection pooling correctly

**Recommendations:**

- Add LIMIT parameter to getAvailableSlots() query
- Create performance test suite measuring P50, P95, P99 latencies
- Consider caching available slots for frequently queried date ranges

### Files Reviewed

**Backend:**

- ✅ `apps/forms-api/database/migrations/032_create_appointment_bookings_table.sql` - Excellent
  schema design
- ✅ `apps/forms-api/database/migrations/DOWN_032_drop_appointment_bookings_table.sql` - Proper
  rollback
- ✅ `apps/forms-api/src/repositories/appointment-booking.repository.ts` - Exemplary documentation
- ✅ `apps/forms-api/src/services/template-executors/appointment-executor.ts` - Clean implementation
- ✅ `apps/forms-api/src/services/template-executor-registry.service.ts` - Proper registration
- ✅ `apps/forms-api/src/controllers/public-forms.controller.ts` - Available slots endpoint exists
- ✅ `apps/forms-api/tests/unit/services/template-executors/appointment-executor.test.ts` - 36/36
  tests passing

**Frontend:**

- ✅ `apps/form-builder-ui/src/app/features/public/form-renderer/available-slots.component.ts` -
  Signal-based state
- ✅ `apps/form-builder-ui/src/app/features/public/form-renderer/available-slots.component.html` -
  Responsive UI
- ✅ `apps/form-builder-ui/src/app/features/public/form-renderer/available-slots.component.scss` -
  Styling exists
- ❌ Missing: `available-slots.component.spec.ts` (component unit tests)

**Shared:**

- ✅ `packages/shared/src/types/templates.types.ts` - Complete type definitions

### Missing Artifacts

| Artifact                       | Status     | Impact   | Task          |
| ------------------------------ | ---------- | -------- | ------------- |
| Appointment template seed data | ❌ MISSING | Medium   | Task 13       |
| Integration tests              | ❌ MISSING | **HIGH** | Task 11       |
| Frontend component tests       | ❌ MISSING | **HIGH** | Task 12       |
| Performance benchmarks         | ❌ MISSING | **HIGH** | Task 14       |
| E2E test for booking flow      | ❌ MISSING | Medium   | Not specified |

### Technical Debt Identified

1. **Available Slots Query Optimization** (Priority: Medium)
   - Current implementation returns ALL slots for date range without pagination
   - Recommendation: Add LIMIT/OFFSET parameters for large date ranges
   - Impact: Could cause slow response times for 90-day queries

2. **Component Integration Gap** (Priority: High)
   - AvailableSlotsComponent exists but not integrated into FormRendererComponent
   - Recommendation: Add conditional rendering based on template.businessLogicConfig.type
   - File: `apps/form-builder-ui/src/app/features/public/form-renderer/form-renderer.component.ts`

3. **Same-Day Booking Restriction** (Priority: Low)
   - Current implementation rejects today's date (`isPastDate` uses `<=` comparison)
   - Consideration: Business requirement vs technical limitation?
   - Recommendation: Clarify requirement or make configurable

### Critical Issues Requiring Immediate Attention

1. **Missing Concurrent Booking Test** (Severity: HIGH, Task 11)
   - **Risk**: Race conditions may exist despite row-level locking implementation
   - **Required**: Test with 20 simultaneous requests, verify max 3 bookings per slot
   - **Location**: `apps/forms-api/tests/integration/appointment-booking.test.ts`
   - **Test Scenario**:
     ```typescript
     it('should prevent double-booking with concurrent requests', async () => {
       const promises = Array(20)
         .fill(null)
         .map(() => submitBooking(slot));
       const results = await Promise.allSettled(promises);
       const successful = results.filter((r) => r.status === 'fulfilled' && r.value.status === 200);
       expect(successful.length).toBe(maxBookingsPerSlot); // e.g., 5
     });
     ```

2. **Missing Performance Benchmarks** (Severity: HIGH, Task 14)
   - **Risk**: Cannot validate 150ms P95 requirement without benchmarks
   - **Required**: Performance test suite measuring latency distribution
   - **Acceptance**: P95 < 150ms for booking validation + conflict check

3. **Missing Frontend Component Tests** (Severity: HIGH, Task 12)
   - **Risk**: UI behavior untested, regression likelihood high
   - **Required**: Component test file with signal state management validation
   - **Coverage Target**: 85%+ per story requirements

### Recommendations by Priority

**Immediate (Block Release):**

1. Create integration test for concurrent booking scenario (Task 11, IV3)
2. Create frontend component unit tests (Task 12, AC9)
3. Create performance benchmarks validating 150ms requirement (Task 14, IV2)

**Before Production (High Priority):** 4. Create seed data for appointment template (Task 13,
AC1) 5. Integrate AvailableSlotsComponent into FormRendererComponent (AC9 completion) 6. Add E2E
test for complete booking workflow

**Future Improvements (Medium Priority):** 7. Add pagination to available slots query 8. Consider
caching strategy for frequently queried date ranges 9. Add rate limiting to available-slots endpoint

### Gate Status

**Gate**: ⚠️ **CONCERNS** →
`docs/qa/gates/29.12-appointment-booking-template-time-slot-management.yml`

**Gate Decision Rationale:**

- Core implementation is excellent with proper concurrency controls
- Unit test coverage is comprehensive (36 tests, 100% passing)
- **CRITICAL GAP**: Integration tests missing (concurrent booking scenario UNTESTED)
- **CRITICAL GAP**: Frontend component tests missing
- **CRITICAL GAP**: Performance benchmarks missing
- Story marked "Review" status prematurely (Tasks 11, 12, 13, 14 incomplete)

### Recommended Status

❌ **Changes Required** - Complete missing test coverage before marking "Done"

**Blocking Items:**

1. Create and pass integration test for concurrent bookings (Task 11)
2. Create and pass frontend component tests (Task 12)
3. Create and pass performance benchmarks (Task 14)
4. Create seed data for template (Task 13)
5. Integrate available slots component with form renderer (AC9 completion)

**Non-Blocking (Can defer to follow-up story):**

- E2E test for complete workflow
- Available slots pagination
- Caching strategy

---

| Test Type         | Status     | Coverage     | Notes                                          |
| ----------------- | ---------- | ------------ | ---------------------------------------------- |
| Unit Tests        | ✅ PASS    | 95%+ (36/36) | Excellent coverage, all edge cases tested      |
| Integration Tests | ❌ MISSING | 0%           | **CRITICAL**: Concurrent booking test required |
| Component Tests   | ❌ MISSING | 0%           | Frontend component untested                    |
| Performance Tests | ❌ MISSING | 0%           | 150ms P95 requirement unvalidated              |
| Concurrent Tests  | ❌ MISSING | 0%           | **HIGH RISK**: 20 requests scenario untested   |

---

### Notes for Development Team

**Excellent Work On:**

- Transaction management and row-level locking implementation
- Comprehensive unit test suite with edge case coverage
- Well-documented code with JSDoc examples
- Clean separation of concerns (repository, executor, controller)
- Proper TypeScript typing with discriminated unions

**Focus Next On:**

- Complete integration test suite (especially concurrent scenarios)
- Add frontend component test coverage
- Validate performance requirements with benchmarks
- Integrate available slots component into public form renderer

**Quality Score Breakdown:**

- Code Quality: 95/100 (excellent)
- Test Coverage: 60/100 (unit tests complete, integration/component/performance missing)
- Documentation: 90/100 (excellent JSDoc, missing performance metrics)
- **Overall: 78/100**

---

## Gate Status

**Quality Gate**: ❌ Not Started

**Checklist**:

- [ ] Database migration applied successfully
- [ ] All unit tests passing (90%+ coverage for executor)
- [ ] All integration tests passing (including concurrent scenarios)
- [ ] All component tests passing
- [ ] Performance requirement met (150ms P95)
- [ ] Concurrent booking test passes (20 requests → max 3 bookings per slot)
- [ ] No regression in existing date/time field functionality
- [ ] Code reviewed and approved
- [ ] TypeScript strict mode passing with no errors
- [ ] ESLint passing with no warnings

---

## Related Documentation

- **PRD**: docs/prd/epic-29-form-templates-system.md
- **Architecture**: docs/architecture/backend-architecture.md (Repository Pattern, Strategy Pattern,
  Transaction Management)
- **Architecture**: docs/architecture/database-schema.md (PostgreSQL Best Practices, Row-Level
  Locking)
- **Architecture**: docs/architecture/frontend-architecture.md (Signal-based State, Standalone
  Components)
- **Related Stories**:
  - Story 29.11: Product Template with Inventory Tracking (Base ITemplateExecutor Interface)
  - Story 29.13: Quiz Template with Scoring Logic (Next executor implementation)
- **Gate File**: docs/qa/gates/29.12-appointment-booking-template-time-slot-management.yml

---

## Notes

### Transaction Handling Pattern

**Critical**: This story establishes the transaction pattern for all template executors:

1. **Service Layer Controls Transactions**: `FormsService.submitForm()` manages
   BEGIN/COMMIT/ROLLBACK
2. **Executor Receives Client**: Executors receive `PoolClient` parameter (no internal transaction
   management)
3. **Compensating Transactions**: On executor failure, service layer deletes submission record
4. **Row-Level Locking**: Prevents race conditions with `SELECT FOR UPDATE` in `getBookingCount()`

### Performance Optimization

**Indexing Strategy**:

- Composite index on `(form_id, date, time_slot)` with `WHERE status = 'confirmed'` partial index
- Date index for calendar queries
- Both indexes support fast conflict detection (< 150ms target)

### Frontend UX Considerations

**Available Slots Component**:

- Color-coded slots: Green (available), Orange (limited), Gray (full)
- Real-time capacity display (e.g., "3/5 available")
- Inline calendar with disabled past dates
- Responsive grid layout for time slots

### Double-Booking Prevention

**Concurrency Control**:

1. `getBookingCount()` uses `FOR UPDATE` to lock matching rows
2. Transaction holds lock until COMMIT
3. Concurrent requests queue (FIFO)
4. First request gets slot, others see incremented count
5. Integration test validates with 20 concurrent requests → exactly 3 bookings succeed

---

_Story created: 2025-01-09_ _Last updated: 2025-01-09_
