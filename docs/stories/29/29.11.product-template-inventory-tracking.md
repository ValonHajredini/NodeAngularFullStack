# Story 29.11: Product Template with Inventory Tracking

**Story Status:** Approved **Story Owner:** Product Manager **Developer:** TBD **QA Engineer:** TBD
**Epic:** 29 - Form Template System with Business Logic

## User Story

As a **form creator**, I want **an e-commerce product template with variants and inventory
management**, So that **I can sell products with automated stock tracking and prevent overselling**.

## Story Context

**Existing System Integration:**

- **Integrates with**: Form submission flow (`apps/forms-api/src/controllers/forms.controller.ts`),
  form templates system (Stories 29.1-29.10)
- **Technology**: PostgreSQL transactions with row-level locking, Express.js service layer, Strategy
  Pattern executor
- **Follows pattern**: Repository → Service → Controller architecture, async transaction handling
- **Touch points**: Form submissions, template business logic execution, real-time API endpoints

**Current System Behavior:**

- Form submissions processed via `POST /api/public/forms/:shortCode/submit`
- No business logic execution exists (forms are data collection only)
- No inventory tracking or stock management
- IMAGE_GALLERY field type exists but doesn't support variant metadata

**Enhancement Overview:**

This story implements the **first template-specific business logic executor**: product inventory
tracking with race condition prevention. When a form with product template is submitted, the system
automatically decrements stock using database transactions and row-level locks to prevent
overselling. The frontend displays real-time stock availability.

## Acceptance Criteria

### Functional Requirements:

1. **AC1: Product Template Creation**
   - "Product Order Form" template created with category `ECOMMERCE`
   - Template includes: Product Name, Product Description, Product Images (IMAGE_GALLERY), Quantity
     selector, Customer Information, Delivery Address
   - Template seed data created in `apps/forms-api/database/seeds/`

2. **AC2: Template Schema Structure**
   - Schema includes IMAGE_GALLERY field with variant metadata support
   - Each image can have associated metadata:
     `{ size: string, color: string, priceModifier: number, sku: string }`
   - Quantity field (NUMBER type) with min=1, max=99
   - Customer info fields (TEXT, EMAIL types)

3. **AC3: IMAGE_GALLERY Variant Metadata Extension**
   - Extend IMAGE_GALLERY field configuration to support `variantMetadata` property
   - Shared type updated: `FormField` interface extended with optional `variantMetadata`
   - Form renderer updated to handle variant selection (if selected image has metadata, display
     variant info)

4. **AC4: Business Logic Configuration**
   - Template `business_logic_config`:
     `{ type: 'inventory', variantField: 'product_images', quantityField: 'quantity', stockTable: 'product_inventory' }`
   - Configuration validates: referenced fields exist in schema, field types match expectations

5. **AC5: Product Inventory Table**
   - New table `product_inventory` created with columns:
     - `id` UUID PRIMARY KEY
     - `form_id` UUID REFERENCES forms(id) - links inventory to specific product form
     - `sku` VARCHAR(100) UNIQUE NOT NULL - product/variant SKU
     - `stock_quantity` INTEGER NOT NULL DEFAULT 0 - available stock
     - `reserved_quantity` INTEGER NOT NULL DEFAULT 0 - reserved for pending orders
     - `updated_at` TIMESTAMP WITH TIME ZONE
   - Migration script with rollback logic
   - Indexes: `idx_product_inventory_sku`, `idx_product_inventory_form_id`

6. **AC6: Inventory Executor Strategy Class**
   - `InventoryExecutor` class implements `ITemplateExecutor` interface (base executor interface)
   - Located: `apps/forms-api/src/services/template-executors/inventory-executor.ts`
   - Methods: `execute(submission, template, config)`, `validate(submission, template, config)`
   - Uses repository pattern: `InventoryRepository` for data access

7. **AC7: Stock Decrement with Transaction Locking**
   - On form submission, executor:
     1. Begins PostgreSQL transaction
     2. Queries inventory with row-level lock:
        `SELECT * FROM product_inventory WHERE sku = $1 FOR UPDATE`
     3. Checks if `stock_quantity >= requested_quantity`
     4. If sufficient, decrements:
        `UPDATE product_inventory SET stock_quantity = stock_quantity - $1`
     5. Commits transaction
     6. If insufficient or error, rolls back transaction
   - Locks prevent concurrent submissions from overselling

8. **AC8: Out-of-Stock Prevention**
   - If `stock_quantity < requested_quantity`, submission rejected with 400 error
   - Error response:
     `{ success: false, error: { message: 'Product out of stock. Only X units available.', code: 'OUT_OF_STOCK' } }`
   - No form submission record created (early validation)

9. **AC9: Real-Time Stock API**
   - New endpoint: `GET /api/inventory/:sku` (public, no auth required)
   - Returns: `{ success: true, data: { sku, stock_quantity, available: stock_quantity > 0 } }`
   - Response time: < 50ms (simple query, indexed)

10. **AC10: Frontend Stock Display**
    - Form renderer fetches stock when IMAGE_GALLERY with variants is selected
    - Displays stock badge: "X units available" (green if > 10, yellow if 1-10, red if 0)
    - Disables submit button when out of stock
    - Shows "Out of Stock" message instead of submit button

### Integration Verification:

- **IV1: Non-Product Forms Unchanged**
  - Forms without inventory business logic config submit normally
  - No performance impact on non-product forms
  - Executor only runs when `business_logic_config.type === 'inventory'`

- **IV2: Inventory Update Performance**
  - Stock decrement completes within 200ms (includes transaction overhead)
  - Measured from form submission start to inventory update completion
  - Performance test with 100 concurrent submissions

- **IV3: Concurrent Submission Handling**
  - 10 simultaneous submissions for same product (5 units available) → only 5 succeed
  - Remaining 5 receive out-of-stock error
  - No overselling occurs (validated with E2E test)
  - Database integrity maintained (stock never negative)

## Tasks / Subtasks

- [ ] **Task 1: Create Product Inventory Table Migration** (AC: 5)
  - [ ] Subtask 1.1: Create migration file:
        `apps/forms-api/database/migrations/031_create_product_inventory_table.sql`
  - [ ] Subtask 1.2: Define table schema with columns: id, form_id, sku, stock_quantity,
        reserved_quantity, updated_at
  - [ ] Subtask 1.3: Add foreign key constraint: `form_id REFERENCES forms(id) ON DELETE CASCADE`
  - [ ] Subtask 1.4: Add unique constraint on `sku`
  - [ ] Subtask 1.5: Create indexes:
        `CREATE INDEX idx_product_inventory_sku ON product_inventory(sku)`
  - [ ] Subtask 1.6: Create index:
        `CREATE INDEX idx_product_inventory_form_id ON product_inventory(form_id)`
  - [ ] Subtask 1.7: Add trigger for `updated_at` auto-update
  - [ ] Subtask 1.8: Create rollback migration: `DOWN_031_drop_product_inventory_table.sql`

- [ ] **Task 2: Create Inventory Repository** (AC: 6, 7)
  - [ ] Subtask 2.1: Create `InventoryRepository` class at
        `apps/forms-api/src/repositories/inventory.repository.ts`
  - [ ] Subtask 2.2: Extend `BaseRepository<ProductInventory>` pattern
  - [ ] Subtask 2.3: Implement `findBySku(sku: string)` method
  - [ ] Subtask 2.4: Implement `lockAndDecrement(sku: string, quantity: number)` method with
        `SELECT FOR UPDATE`
  - [ ] Subtask 2.5: Implement `checkAvailability(sku: string, quantity: number)` method
  - [ ] Subtask 2.6: All methods use parameterized queries (SQL injection prevention)
  - [ ] Subtask 2.7: Add comprehensive JSDoc documentation with transaction examples

- [ ] **Task 3: Define Base Template Executor Interface** (AC: 6)
  - [ ] Subtask 3.1: Create `ITemplateExecutor` interface at
        `apps/forms-api/src/services/template-executors/base-executor.interface.ts`
  - [ ] Subtask 3.2: Define methods: `execute(submission, template, config)`,
        `validate(submission, template, config)`
  - [ ] Subtask 3.3: Define types: `ExecutorResult<T>`, `ExecutorValidation`
  - [ ] Subtask 3.4: Export shared types to `@nodeangularfullstack/shared` if needed

- [ ] **Task 4: Implement Inventory Executor** (AC: 6, 7, 8)
  - [ ] Subtask 4.1: Create `InventoryExecutor` class at
        `apps/forms-api/src/services/template-executors/inventory-executor.ts`
  - [ ] Subtask 4.2: Implement `ITemplateExecutor` interface
  - [ ] Subtask 4.3: Inject `InventoryRepository` in constructor
  - [ ] Subtask 4.4: Implement `validate()` method: check config fields exist, check stock
        availability
  - [ ] Subtask 4.5: Implement `execute()` method with transaction logic
  - [ ] Subtask 4.6: Use `pool.query('BEGIN')` to start transaction
  - [ ] Subtask 4.7: Call `repository.lockAndDecrement()` within transaction
  - [ ] Subtask 4.8: Use `pool.query('COMMIT')` on success, `ROLLBACK` on error
  - [ ] Subtask 4.9: Handle out-of-stock error with specific error code

- [ ] **Task 5: Integrate Executor with Form Submission Flow** (AC: 6, 7)
  - [ ] Subtask 5.1: Update `FormsService.submitForm()` method to check for business logic config
  - [ ] Subtask 5.2: Add executor factory/registry to select correct executor based on `config.type`
  - [ ] Subtask 5.3: Call `executor.validate()` before creating submission record
  - [ ] Subtask 5.4: Call `executor.execute()` after submission record created
  - [ ] Subtask 5.5: If `execute()` fails, delete submission record (compensating transaction)
  - [ ] Subtask 5.6: Return executor result in submission response (if applicable)

- [ ] **Task 6: Extend IMAGE_GALLERY Field Type** (AC: 2, 3)
  - [ ] Subtask 6.1: Update `FormField` interface in `packages/shared/src/types/forms.types.ts`
  - [ ] Subtask 6.2: Add optional property:
        `variantMetadata?: { size?: string, color?: string, priceModifier?: number, sku?: string }[]`
  - [ ] Subtask 6.3: Update form builder UI to support variant metadata input (optional, future
        enhancement)
  - [ ] Subtask 6.4: For MVP: Variant metadata defined in template seed data (hardcoded in template)

- [ ] **Task 7: Create Real-Time Stock API Endpoint** (AC: 9)
  - [ ] Subtask 7.1: Add route: `GET /api/inventory/:sku` in
        `apps/forms-api/src/routes/inventory.routes.ts`
  - [ ] Subtask 7.2: Create `InventoryController.getStock()` method
  - [ ] Subtask 7.3: Call `inventoryRepository.findBySku(sku)`
  - [ ] Subtask 7.4: Return formatted response:
        `{ success: true, data: { sku, stock_quantity, available } }`
  - [ ] Subtask 7.5: Handle 404 if SKU not found
  - [ ] Subtask 7.6: Add JSDoc for Swagger/OpenAPI documentation

- [ ] **Task 8: Frontend Stock Display Integration** (AC: 10)
  - [ ] Subtask 8.1: Update `FormRendererComponent` to detect IMAGE_GALLERY fields with variant
        metadata
  - [ ] Subtask 8.2: On image selection, check if variant has SKU
  - [ ] Subtask 8.3: If SKU present, call `GET /api/inventory/:sku` to fetch stock
  - [ ] Subtask 8.4: Create `stockInfo` signal to store stock data
  - [ ] Subtask 8.5: Display stock badge: "X units available" with color-coded styling
  - [ ] Subtask 8.6: Disable submit button if `stock_quantity === 0`
  - [ ] Subtask 8.7: Show "Out of Stock" message instead of submit button when unavailable

- [ ] **Task 9: Create Product Template Seed Data** (AC: 1)
  - [ ] Subtask 9.1: Create seed file: `apps/forms-api/database/seeds/031_seed_product_template.ts`
  - [ ] Subtask 9.2: Define product template with all required fields
  - [ ] Subtask 9.3: Include IMAGE_GALLERY field with variant metadata (3 variants with different
        SKUs)
  - [ ] Subtask 9.4: Set business logic config:
        `{ type: 'inventory', variantField: 'product_images', quantityField: 'quantity' }`
  - [ ] Subtask 9.5: Insert template into `form_templates` table
  - [ ] Subtask 9.6: Insert initial inventory records for each variant SKU (stock_quantity: 10)

- [ ] **Task 10: Write Unit Tests** (AC: All)
  - [ ] Subtask 10.1: Create `inventory.repository.test.ts` - test all repository methods
  - [ ] Subtask 10.2: Test `lockAndDecrement()` with mocked transaction
  - [ ] Subtask 10.3: Create `inventory-executor.test.ts` - test executor logic
  - [ ] Subtask 10.4: Test `validate()` method: sufficient stock, insufficient stock, invalid config
  - [ ] Subtask 10.5: Test `execute()` method: successful decrement, out-of-stock error, rollback on
        error
  - [ ] Subtask 10.6: Create `inventory.controller.test.ts` - test stock API endpoint
  - [ ] Subtask 10.7: Test concurrent execution with mocked database (simulated race condition)

- [ ] **Task 11: Write Integration Tests** (AC: IV2, IV3)
  - [ ] Subtask 11.1: Create `product-template-submission.test.ts` integration test
  - [ ] Subtask 11.2: Test full submission flow: create form with product template, submit with
        valid stock
  - [ ] Subtask 11.3: Test out-of-stock rejection: submit with quantity > stock_quantity
  - [ ] Subtask 11.4: Test concurrent submissions: 10 parallel submissions, 5 units stock
  - [ ] Subtask 11.5: Verify only 5 submissions succeed, 5 receive out-of-stock error
  - [ ] Subtask 11.6: Verify final stock_quantity === 0 (no overselling)
  - [ ] Subtask 11.7: Measure performance: submission + stock update within 200ms

- [ ] **Task 12: Write E2E Tests** (AC: All, IV3)
  - [ ] Subtask 12.1: Create Playwright E2E test: `tests/e2e/product-template-inventory.spec.ts`
  - [ ] Subtask 12.2: Test scenario: Create product form, seed inventory, fill form, submit
  - [ ] Subtask 12.3: Verify stock decremented after submission
  - [ ] Subtask 12.4: Test out-of-stock UI: stock badge shows "0 units", submit button disabled
  - [ ] Subtask 12.5: Test concurrent submissions (if possible with Playwright parallel workers)

## Dev Notes

### Previous Story Insights

**From Story 29.4 (Templates Service Application Logic):**

- Template service validates business logic config matches category
- `applyTemplateToForm()` method increments usage_count
- Service uses repository pattern for data access

**From Story 29.5 (Templates Controller REST API):**

- Form submission endpoint: `POST /api/public/forms/:shortCode/submit`
- Current implementation: Creates submission record, sends email notifications (if configured)
- No business logic execution exists yet

**From Story 29.2 (Shared Template Types):**

- `TemplateBusinessLogicConfig` interface with discriminated union
- Need to extend with `InventoryConfig` type

### Database Schema

**Source**: [architecture/database-schema.md]

**Product Inventory Table:**

```sql
CREATE TABLE product_inventory (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    form_id UUID NOT NULL REFERENCES forms(id) ON DELETE CASCADE,
    sku VARCHAR(100) UNIQUE NOT NULL,
    stock_quantity INTEGER NOT NULL DEFAULT 0 CHECK (stock_quantity >= 0),
    reserved_quantity INTEGER NOT NULL DEFAULT 0 CHECK (reserved_quantity >= 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_product_inventory_sku ON product_inventory(sku);
CREATE INDEX idx_product_inventory_form_id ON product_inventory(form_id);

-- Trigger for updated_at auto-update
CREATE TRIGGER update_product_inventory_updated_at
    BEFORE UPDATE ON product_inventory
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

**Key Design Decisions:**

- `form_id` links inventory to specific product form (one form = one product with variants)
- `sku` is globally unique (prevents duplicate SKUs across forms)
- `reserved_quantity` for future feature: reserve stock during checkout (not implemented in MVP)
- CHECK constraints prevent negative stock (database-level validation)

**Source**: [architecture/database-schema.md], PRD Epic 29 AC5

### Repository Pattern with Transaction Locking

**Source**: [architecture/backend-architecture.md#data-access-layer]

**Inventory Repository Implementation:**

```typescript
import { Pool, PoolClient } from 'pg';
import { BaseRepository } from './base.repository';
import { ProductInventory } from '@nodeangularfullstack/shared';

/**
 * Repository for product inventory operations with transaction support.
 * Handles stock tracking, locking, and concurrent access control.
 */
export class InventoryRepository extends BaseRepository<ProductInventory> {
  constructor(pool: Pool) {
    super(pool, 'product_inventory');
  }

  /**
   * Finds inventory record by SKU.
   * @param sku - Product/variant SKU
   * @returns Inventory record or null if not found
   */
  async findBySku(sku: string): Promise<ProductInventory | null> {
    const query = `SELECT * FROM ${this.tableName} WHERE sku = $1`;
    const result = await this.pool.query(query, [sku]);
    return result.rows[0] || null;
  }

  /**
   * Locks inventory row and decrements stock quantity atomically.
   * Uses SELECT FOR UPDATE to prevent race conditions.
   * MUST be called within a transaction.
   *
   * @param client - PostgreSQL transaction client
   * @param sku - Product/variant SKU
   * @param quantity - Quantity to decrement
   * @returns Updated inventory record
   * @throws Error if insufficient stock or SKU not found
   *
   * @example
   * const client = await pool.connect();
   * try {
   *   await client.query('BEGIN');
   *   const inventory = await inventoryRepo.lockAndDecrement(client, 'SKU123', 2);
   *   await client.query('COMMIT');
   * } catch (error) {
   *   await client.query('ROLLBACK');
   *   throw error;
   * } finally {
   *   client.release();
   * }
   */
  async lockAndDecrement(
    client: PoolClient,
    sku: string,
    quantity: number
  ): Promise<ProductInventory> {
    // Lock row for update (blocks other transactions)
    const lockQuery = `
      SELECT * FROM ${this.tableName}
      WHERE sku = $1
      FOR UPDATE
    `;
    const lockResult = await client.query(lockQuery, [sku]);

    if (lockResult.rows.length === 0) {
      throw new Error(`SKU not found: ${sku}`);
    }

    const inventory = lockResult.rows[0];

    // Check sufficient stock
    if (inventory.stock_quantity < quantity) {
      throw new Error(
        `Insufficient stock. Available: ${inventory.stock_quantity}, Requested: ${quantity}`
      );
    }

    // Decrement stock
    const updateQuery = `
      UPDATE ${this.tableName}
      SET stock_quantity = stock_quantity - $1,
          updated_at = CURRENT_TIMESTAMP
      WHERE sku = $2
      RETURNING *
    `;
    const updateResult = await client.query(updateQuery, [quantity, sku]);

    return updateResult.rows[0];
  }

  /**
   * Checks if sufficient stock is available without locking.
   * Use for pre-validation before starting transaction.
   *
   * @param sku - Product/variant SKU
   * @param quantity - Required quantity
   * @returns True if sufficient stock available
   */
  async checkAvailability(sku: string, quantity: number): Promise<boolean> {
    const query = `
      SELECT stock_quantity >= $1 AS available
      FROM ${this.tableName}
      WHERE sku = $2
    `;
    const result = await this.pool.query(query, [quantity, sku]);

    if (result.rows.length === 0) {
      return false; // SKU not found
    }

    return result.rows[0].available;
  }
}

export const inventoryRepository = new InventoryRepository(pool);
```

**Source**: [architecture/backend-architecture.md#data-access-layer]

### Strategy Pattern: Template Executor

**Base Executor Interface:**

```typescript
import {
  FormSubmission,
  FormTemplate,
  TemplateBusinessLogicConfig,
} from '@nodeangularfullstack/shared';

/**
 * Result returned by executor after successful execution.
 */
export interface ExecutorResult<T = any> {
  success: boolean;
  data?: T;
  message?: string;
}

/**
 * Validation result before execution.
 */
export interface ExecutorValidation {
  valid: boolean;
  errors: string[];
}

/**
 * Base interface for all template business logic executors.
 * Executors implement template-specific behavior (inventory, appointments, scoring, etc.)
 */
export interface ITemplateExecutor {
  /**
   * Validates submission data and configuration before execution.
   * Called before creating submission record (early validation).
   *
   * @param submission - Form submission data
   * @param template - Template configuration
   * @param config - Business logic configuration
   * @returns Validation result with errors if invalid
   */
  validate(
    submission: Partial<FormSubmission>,
    template: FormTemplate,
    config: TemplateBusinessLogicConfig
  ): Promise<ExecutorValidation>;

  /**
   * Executes template-specific business logic after submission created.
   * Should use transactions for atomic operations.
   *
   * @param submission - Created form submission record
   * @param template - Template configuration
   * @param config - Business logic configuration
   * @returns Execution result
   */
  execute(
    submission: FormSubmission,
    template: FormTemplate,
    config: TemplateBusinessLogicConfig
  ): Promise<ExecutorResult>;
}
```

**Inventory Executor Implementation:**

```typescript
import { Pool, PoolClient } from 'pg';
import { ITemplateExecutor, ExecutorResult, ExecutorValidation } from './base-executor.interface';
import { FormSubmission, FormTemplate, InventoryConfig } from '@nodeangularfullstack/shared';
import { InventoryRepository } from '../../repositories/inventory.repository';

/**
 * Executor for inventory tracking business logic.
 * Handles stock decrementation with transaction locking.
 */
export class InventoryExecutor implements ITemplateExecutor {
  constructor(
    private pool: Pool,
    private inventoryRepository: InventoryRepository
  ) {}

  /**
   * Validates inventory availability before submission.
   */
  async validate(
    submission: Partial<FormSubmission>,
    template: FormTemplate,
    config: InventoryConfig
  ): Promise<ExecutorValidation> {
    const errors: string[] = [];

    // Validate config references exist
    if (!template.template_schema.fields.find((f) => f.name === config.variantField)) {
      errors.push(`Variant field "${config.variantField}" not found in schema`);
    }
    if (!template.template_schema.fields.find((f) => f.name === config.quantityField)) {
      errors.push(`Quantity field "${config.quantityField}" not found in schema`);
    }

    // Extract SKU from submission data
    const sku = this.extractSku(submission.data, config);
    const quantity = this.extractQuantity(submission.data, config);

    if (!sku) {
      errors.push('No SKU selected (variant selection required)');
    }
    if (!quantity || quantity < 1) {
      errors.push('Invalid quantity');
    }

    // Check stock availability (pre-validation without lock)
    if (sku && quantity) {
      const available = await this.inventoryRepository.checkAvailability(sku, quantity);
      if (!available) {
        const inventory = await this.inventoryRepository.findBySku(sku);
        const stockQty = inventory?.stock_quantity || 0;
        errors.push(`Insufficient stock. Only ${stockQty} units available.`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Executes inventory decrement with transaction locking.
   */
  async execute(
    submission: FormSubmission,
    template: FormTemplate,
    config: InventoryConfig
  ): Promise<ExecutorResult> {
    const sku = this.extractSku(submission.data, config);
    const quantity = this.extractQuantity(submission.data, config);

    const client: PoolClient = await this.pool.connect();

    try {
      // Begin transaction
      await client.query('BEGIN');

      // Lock and decrement stock
      const updatedInventory = await this.inventoryRepository.lockAndDecrement(
        client,
        sku,
        quantity
      );

      // Commit transaction
      await client.query('COMMIT');

      return {
        success: true,
        data: {
          sku: updatedInventory.sku,
          remaining_stock: updatedInventory.stock_quantity,
        },
        message: 'Inventory updated successfully',
      };
    } catch (error: any) {
      // Rollback on error
      await client.query('ROLLBACK');

      throw new Error(`Inventory update failed: ${error.message}`);
    } finally {
      client.release();
    }
  }

  /**
   * Extracts SKU from submission data based on variant field.
   */
  private extractSku(data: Record<string, any>, config: InventoryConfig): string {
    const variantValue = data[config.variantField];
    // Assuming variant field stores selected image index or metadata
    // Implementation depends on IMAGE_GALLERY structure
    return variantValue?.sku || variantValue; // Simplified
  }

  /**
   * Extracts quantity from submission data.
   */
  private extractQuantity(data: Record<string, any>, config: InventoryConfig): number {
    return parseInt(data[config.quantityField], 10) || 0;
  }
}
```

**Source**: Design pattern for template executors (Strategy Pattern)

### Integration with Form Submission Flow

**Modified `FormsService.submitForm()` Method:**

```typescript
async submitForm(shortCode: string, submissionData: Record<string, any>): Promise<FormSubmission> {
  // 1. Fetch form schema
  const form = await this.formsRepository.findByShortCode(shortCode);

  // 2. Check if form has template with business logic
  const template = form.template_id
    ? await this.templatesService.getTemplateById(form.template_id)
    : null;

  if (template?.business_logic_config) {
    // 3. Get appropriate executor
    const executor = this.getExecutor(template.business_logic_config.type);

    // 4. Validate before creating submission
    const validation = await executor.validate(
      { data: submissionData },
      template,
      template.business_logic_config
    );

    if (!validation.valid) {
      throw new ApiError(400, validation.errors.join(', '), 'VALIDATION_FAILED');
    }
  }

  // 5. Create submission record
  const submission = await this.formsRepository.createSubmission(form.id, submissionData);

  // 6. Execute business logic (if applicable)
  if (template?.business_logic_config) {
    const executor = this.getExecutor(template.business_logic_config.type);

    try {
      const result = await executor.execute(submission, template, template.business_logic_config);

      // Optionally attach result to submission metadata
      if (result.data) {
        await this.formsRepository.updateSubmissionMetadata(submission.id, {
          ...submission.metadata,
          executor_result: result.data
        });
      }
    } catch (error: any) {
      // Compensating transaction: delete submission if executor fails
      await this.formsRepository.deleteSubmission(submission.id);
      throw new ApiError(500, `Business logic execution failed: ${error.message}`);
    }
  }

  return submission;
}

/**
 * Factory method to get executor by type.
 */
private getExecutor(type: string): ITemplateExecutor {
  switch (type) {
    case 'inventory':
      return new InventoryExecutor(this.pool, inventoryRepository);
    case 'appointment':
      // Future: return new AppointmentExecutor(...);
    case 'quiz':
      // Future: return new QuizExecutor(...);
    default:
      throw new Error(`Unknown executor type: ${type}`);
  }
}
```

**Source**: Service layer pattern from [architecture/backend-architecture.md]

### IMAGE_GALLERY Variant Metadata Extension

**Shared Type Extension:**

```typescript
// packages/shared/src/types/forms.types.ts

export interface FormField {
  id: string;
  type: FieldType;
  name: string;
  label: string;
  required?: boolean;
  validation?: FieldValidation;

  // Existing properties...

  /**
   * Variant metadata for IMAGE_GALLERY fields (e.g., product variants).
   * Each array element corresponds to an image in the gallery.
   * Used by product templates for inventory tracking.
   */
  variantMetadata?: ImageVariantMetadata[];
}

export interface ImageVariantMetadata {
  /** Variant SKU for inventory tracking */
  sku: string;
  /** Variant size (e.g., 'S', 'M', 'L', 'XL') */
  size?: string;
  /** Variant color (e.g., 'Red', 'Blue', 'Black') */
  color?: string;
  /** Price modifier in cents (positive or negative) */
  priceModifier?: number;
  /** Variant display name (e.g., 'Red - Large') */
  displayName?: string;
}
```

**Form Renderer Update (Simplified for MVP):** For MVP, variant metadata is read-only in public
forms. Frontend displays variant info but doesn't require complex selection UI.

**Source**: Extension to existing form field types

### Real-Time Stock API

**Endpoint Implementation:**

```typescript
// apps/forms-api/src/controllers/inventory.controller.ts

/**
 * Controller for inventory-related operations.
 */
export class InventoryController {
  constructor(private inventoryRepository: InventoryRepository) {}

  /**
   * Get stock information for a SKU.
   *
   * @route GET /api/inventory/:sku
   * @access Public
   * @param sku - Product/variant SKU
   * @returns Stock information
   * @throws 404 if SKU not found
   */
  getStock = AsyncHandler(async (req: Request, res: Response) => {
    const { sku } = req.params;

    const inventory = await this.inventoryRepository.findBySku(sku);

    if (!inventory) {
      throw new ApiError(404, 'SKU not found');
    }

    res.json({
      success: true,
      data: {
        sku: inventory.sku,
        stock_quantity: inventory.stock_quantity,
        available: inventory.stock_quantity > 0,
      },
    });
  });
}
```

**Route Registration:**

```typescript
// apps/forms-api/src/routes/inventory.routes.ts

import { Router } from 'express';
import { InventoryController } from '../controllers/inventory.controller';

const router = Router();
const inventoryController = new InventoryController(inventoryRepository);

/**
 * @swagger
 * /api/inventory/{sku}:
 *   get:
 *     summary: Get stock availability for a product SKU
 *     tags: [Inventory]
 *     parameters:
 *       - in: path
 *         name: sku
 *         required: true
 *         schema:
 *           type: string
 *         description: Product/variant SKU
 *     responses:
 *       200:
 *         description: Stock information retrieved successfully
 *       404:
 *         description: SKU not found
 */
router.get('/:sku', inventoryController.getStock);

export default router;
```

**Source**: [architecture/backend-architecture.md#controller-template]

### Frontend Stock Display

**Form Renderer Integration:**

```typescript
// In FormRendererComponent

protected readonly stockInfo = signal<{ sku: string; stock_quantity: number; available: boolean } | null>(null);

/**
 * Fetches stock information when variant is selected.
 */
async fetchStockForVariant(sku: string): Promise<void> {
  try {
    const response = await fetch(`${environment.apiUrl}/api/inventory/${sku}`);
    const result = await response.json();

    if (result.success) {
      this.stockInfo.set(result.data);
    }
  } catch (error) {
    console.error('Failed to fetch stock:', error);
    this.stockInfo.set(null);
  }
}

// In template
@if (stockInfo()) {
  <div class="stock-badge" [class]="getStockBadgeClass()">
    <i class="pi pi-box"></i>
    {{ stockInfo()!.stock_quantity }} units available
  </div>
}

@if (stockInfo() && !stockInfo()!.available) {
  <div class="out-of-stock-message">
    <i class="pi pi-times-circle"></i>
    Out of Stock
  </div>
} @else {
  <button type="submit" [disabled]="!stockInfo()?.available">
    Submit Order
  </button>
}

// Stock badge styling
getStockBadgeClass(): string {
  const qty = this.stockInfo()?.stock_quantity || 0;
  if (qty === 0) return 'badge-red';
  if (qty <= 10) return 'badge-yellow';
  return 'badge-green';
}
```

**Source**: Reactive state management pattern

### Testing Standards

**Unit Test Example (Inventory Repository):**

```typescript
describe('InventoryRepository', () => {
  let repository: InventoryRepository;
  let mockPool: any;
  let mockClient: any;

  beforeEach(() => {
    mockPool = {
      connect: jest.fn(),
      query: jest.fn(),
    };
    mockClient = {
      query: jest.fn(),
      release: jest.fn(),
    };
    mockPool.connect.mockResolvedValue(mockClient);

    repository = new InventoryRepository(mockPool);
  });

  describe('lockAndDecrement', () => {
    it('should successfully decrement stock with sufficient quantity', async () => {
      // Mock SELECT FOR UPDATE
      mockClient.query.mockResolvedValueOnce({
        rows: [{ sku: 'SKU123', stock_quantity: 10 }],
      });

      // Mock UPDATE
      mockClient.query.mockResolvedValueOnce({
        rows: [{ sku: 'SKU123', stock_quantity: 8 }],
      });

      const result = await repository.lockAndDecrement(mockClient, 'SKU123', 2);

      expect(result.stock_quantity).toBe(8);
      expect(mockClient.query).toHaveBeenCalledWith(expect.stringContaining('FOR UPDATE'), [
        'SKU123',
      ]);
    });

    it('should throw error when insufficient stock', async () => {
      mockClient.query.mockResolvedValueOnce({
        rows: [{ sku: 'SKU123', stock_quantity: 1 }],
      });

      await expect(repository.lockAndDecrement(mockClient, 'SKU123', 5)).rejects.toThrow(
        'Insufficient stock'
      );
    });
  });
});
```

**Integration Test Example (Concurrent Submissions):**

```typescript
describe('Product Template - Concurrent Submissions', () => {
  it('should prevent overselling with concurrent requests', async () => {
    // Setup: Create product form with 5 units in stock
    const form = await createProductForm();
    await inventoryRepository.create({
      form_id: form.id,
      sku: 'TEST-SKU-001',
      stock_quantity: 5,
    });

    // Submit 10 concurrent orders (each for 1 unit)
    const submissions = Array(10)
      .fill(null)
      .map(() =>
        request(app).post(`/api/public/forms/${form.short_code}/submit`).send({
          product_images: 'TEST-SKU-001',
          quantity: 1,
          customer_name: 'Test User',
        })
      );

    const results = await Promise.allSettled(submissions);

    // Verify: Only 5 succeeded, 5 failed
    const succeeded = results.filter((r) => r.status === 'fulfilled').length;
    const failed = results.filter((r) => r.status === 'rejected').length;

    expect(succeeded).toBe(5);
    expect(failed).toBe(5);

    // Verify: Final stock is 0
    const inventory = await inventoryRepository.findBySku('TEST-SKU-001');
    expect(inventory!.stock_quantity).toBe(0);
  });
});
```

**Source**: [architecture/testing-strategy.md]

### Performance Considerations

**Transaction Overhead:**

- Row-level lock (`FOR UPDATE`) adds ~10-20ms latency
- Total submission time: ~150-200ms (within AC requirement)
- Index on `sku` ensures fast lookup (< 5ms)

**Concurrent Load:**

- PostgreSQL handles row-level locking efficiently
- Locks queue waiting transactions (first-come-first-served)
- No deadlocks possible (single table, single row)

**Optimization Strategies:**

- Cache stock availability for read-heavy scenarios (future)
- Use `reserved_quantity` for two-phase commit (checkout → payment)

**Source**: PRD Epic 29, NFR2 (Performance), IV2 (200ms requirement)

### File Locations

**New Files:**

- Migration: `apps/forms-api/database/migrations/031_create_product_inventory_table.sql`
- Rollback: `apps/forms-api/database/migrations/DOWN_031_drop_product_inventory_table.sql`
- Repository: `apps/forms-api/src/repositories/inventory.repository.ts`
- Base executor interface:
  `apps/forms-api/src/services/template-executors/base-executor.interface.ts`
- Inventory executor: `apps/forms-api/src/services/template-executors/inventory-executor.ts`
- Controller: `apps/forms-api/src/controllers/inventory.controller.ts`
- Routes: `apps/forms-api/src/routes/inventory.routes.ts`
- Seed: `apps/forms-api/database/seeds/031_seed_product_template.ts`

**Modified Files:**

- Shared types: `packages/shared/src/types/forms.types.ts` (add `variantMetadata`)
- Shared types: `packages/shared/src/types/templates.types.ts` (add `InventoryConfig`)
- Forms service: `apps/forms-api/src/services/forms.service.ts` (add executor integration)
- Form renderer:
  `apps/form-builder-ui/src/app/features/public/form-renderer/form-renderer.component.ts` (add stock
  display)

**Source**: [architecture/unified-project-structure.md]

### Dependencies

**Story Dependencies:**

- **Depends on**: Story 29.1 (Database Schema) - table migrations
- **Depends on**: Story 29.2 (Shared Types) - `TemplateBusinessLogicConfig`, `InventoryConfig`
- **Depends on**: Story 29.4 (Templates Service) - template application logic
- **Depends on**: Story 29.5 (Templates Controller) - form submission endpoint
- **Blocks**: Stories 29.12-29.15 (other executor implementations)

**External Dependencies:**

- PostgreSQL 15+ with transaction support
- `pg` library (node-postgres) for transaction control

**Source**: PRD Epic 29, Story Dependencies

## Change Log

| Date       | Version | Description                                                                                                        | Author             |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------ | ------------------ |
| 2025-01-09 | 1.0     | Story 29.11 created with full context including transaction locking, executor pattern, and race condition handling | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
