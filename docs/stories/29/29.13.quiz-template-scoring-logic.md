# Story 29.13: Quiz Template with Scoring Logic

**Epic**: Epic 29 - Form Template System with Business Logic **Story ID**: 29.13 **Status**: Draft
**Story Points**: 5 **Priority**: Medium **Risk Level**: Low (In-memory calculation, no database
concurrency) **Dependencies**: Stories 29.1-29.5 (Backend Foundation), 29.11 (Base Executor
Interface) **Related Stories**: 29.11-29.12, 29.14-29.15 (Other Template Types)

---

## User Story

**As an** educator, **I want** a quiz template with automatic scoring, **so that** I can create
assessments and track performance.

---

## Acceptance Criteria

| ID  | Criterion                                                                           | Validated By      |
| --- | ----------------------------------------------------------------------------------- | ----------------- |
| AC1 | "Quiz Assessment" template created with category `QUIZ`                             | Unit Tests        |
| AC2 | Schema includes 5 RADIO questions with 4 options each                               | Seed Data         |
| AC3 | Business logic config: `{type: 'quiz', scoringRules, passingScore, showResults}`    | Unit Tests        |
| AC4 | `QuizExecutor` strategy class created                                               | Unit Tests        |
| AC5 | Calculates percentage score on submission                                           | Unit Tests        |
| AC6 | Stores score in `metadata` JSONB: `{score, correctAnswers, totalQuestions, passed}` | Integration Tests |
| AC7 | Returns score in response if `showResults: true`                                    | Integration Tests |
| AC8 | Analytics include score distribution chart                                          | Component Tests   |

---

## Integration Verification

| ID  | Verification                                  | Test Method       |
| --- | --------------------------------------------- | ----------------- |
| IV1 | Non-quiz forms unchanged                      | Regression Tests  |
| IV2 | Scoring executes within 50ms                  | Performance Tests |
| IV3 | Charts render in existing analytics component | Component Tests   |

---

## Dev Notes

### Architecture Context

**Source**: docs/architecture/backend-architecture.md (Strategy Pattern),
docs/architecture/frontend-architecture.md (Chart.js Integration)

This story implements an in-memory template executor without database tables. The `QuizExecutor`
calculates scores synchronously using the Strategy Pattern and stores results in the existing
`form_submissions.metadata` JSONB column. This approach is simpler and faster than Stories
29.11-29.12 (no transactions, no row-level locking, no concurrent conflict detection).

**Key Architectural Patterns**:

1. **Strategy Pattern**: `QuizExecutor` implements `ITemplateExecutor` interface (defined in Story
   29.11)
2. **JSONB Metadata Storage**: Uses existing `form_submissions.metadata` column (no new tables)
3. **Synchronous Execution**: No async database operations during scoring (pure calculation)
4. **Service Integration**: Integrates with `FormsService.submitForm()` workflow
5. **Analytics Extension**: Extends existing analytics component with score distribution chart

**Performance Requirements**:

- Quiz scoring calculation: < 50ms (P95)
- Analytics chart rendering: < 200ms (P95)
- Support up to 100 questions per quiz

---

### Backend Implementation

#### 1. Shared Types Extension

**File**: `packages/shared/src/types/templates.types.ts`

Add quiz-specific config type:

```typescript
/**
 * Scoring rule for a single quiz question
 * @since Epic 29, Story 29.13
 */
export interface QuizScoringRule {
  fieldId: string; // Field ID of the question
  correctAnswer: string; // Correct answer value
  points?: number; // Optional: custom points (default 1)
}

/**
 * Business logic configuration for quiz templates
 * @since Epic 29, Story 29.13
 */
export interface QuizLogicConfig {
  type: 'quiz';
  scoringRules: QuizScoringRule[]; // Array of question scoring rules
  passingScore: number; // Passing percentage (0-100)
  showResults: boolean; // Show results to user after submission
  allowRetakes?: boolean; // Optional: allow multiple submissions
}

/**
 * Quiz submission metadata stored in form_submissions.metadata JSONB
 * @since Epic 29, Story 29.13
 */
export interface QuizResultMetadata {
  score: number; // Percentage score (0-100)
  correctAnswers: number; // Number of correct answers
  totalQuestions: number; // Total number of questions
  passed: boolean; // Whether user passed (score >= passingScore)
  pointsEarned?: number; // Optional: total points earned
  maxPoints?: number; // Optional: maximum possible points
  answeredAt: string; // ISO timestamp of submission
}
```

Update union type:

```typescript
export type TemplateBusinessLogicConfig =
  | InventoryLogicConfig
  | AppointmentLogicConfig
  | QuizLogicConfig
  | PollLogicConfig
  | OrderLogicConfig;
```

Rebuild shared package:

```bash
npm run build:shared
```

---

#### 2. Executor Strategy Class

**File**: `apps/forms-api/src/services/executors/quiz.executor.ts`

```typescript
import { PoolClient } from 'pg';
import {
  ITemplateExecutor,
  ExecutorValidation,
  ExecutorResult,
  FormTemplate,
  FormSubmission,
  QuizLogicConfig,
  QuizResultMetadata,
} from '@nodeangularfullstack/shared';
import { ApiError } from '../../utils/api-error';

/**
 * Quiz executor with automatic scoring logic
 * Calculates score synchronously without database operations
 *
 * @since Epic 29, Story 29.13
 * @implements ITemplateExecutor (Story 29.11)
 * @source docs/architecture/backend-architecture.md (Strategy Pattern)
 */
export class QuizExecutor implements ITemplateExecutor {
  /**
   * Validate quiz submission data
   * Checks that all required question fields are answered
   */
  async validate(
    submission: Partial<FormSubmission>,
    template: FormTemplate,
    config: QuizLogicConfig
  ): Promise<ExecutorValidation> {
    const errors: string[] = [];
    const data = submission.data as Record<string, any>;

    // Validate scoring rules configuration
    if (!config.scoringRules || config.scoringRules.length === 0) {
      errors.push('Quiz must have at least one scoring rule');
    }

    // Validate passing score
    if (config.passingScore < 0 || config.passingScore > 100) {
      errors.push('Passing score must be between 0 and 100');
    }

    // Validate that all quiz questions are answered
    for (const rule of config.scoringRules) {
      const answer = data[rule.fieldId];
      if (answer === undefined || answer === null || answer === '') {
        errors.push(`Question '${rule.fieldId}' is required`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Execute quiz scoring logic
   * Calculates score synchronously and stores in metadata
   *
   * @param submission - Form submission record
   * @param template - Template configuration
   * @param config - Quiz logic configuration
   * @param client - Database client (unused for quiz, required by interface)
   * @returns Executor result with score details
   */
  async execute(
    submission: FormSubmission,
    template: FormTemplate,
    config: QuizLogicConfig,
    client?: PoolClient
  ): Promise<ExecutorResult> {
    const data = submission.data as Record<string, any>;

    let correctAnswers = 0;
    let totalPoints = 0;
    let maxPoints = 0;

    // Calculate score
    for (const rule of config.scoringRules) {
      const userAnswer = data[rule.fieldId];
      const points = rule.points || 1;
      maxPoints += points;

      if (userAnswer === rule.correctAnswer) {
        correctAnswers++;
        totalPoints += points;
      }
    }

    const totalQuestions = config.scoringRules.length;
    const score = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;
    const passed = score >= config.passingScore;

    // Prepare metadata
    const metadata: QuizResultMetadata = {
      score,
      correctAnswers,
      totalQuestions,
      passed,
      pointsEarned: totalPoints,
      maxPoints,
      answeredAt: new Date().toISOString(),
    };

    // Prepare result
    const result: ExecutorResult = {
      success: true,
      data: metadata,
      message: passed
        ? `Quiz passed! Score: ${score}%`
        : `Quiz completed. Score: ${score}% (Passing: ${config.passingScore}%)`,
    };

    // Include full results if configured
    if (config.showResults) {
      result.data.detailedResults = config.scoringRules.map((rule) => ({
        fieldId: rule.fieldId,
        userAnswer: data[rule.fieldId],
        correctAnswer: rule.correctAnswer,
        isCorrect: data[rule.fieldId] === rule.correctAnswer,
        points: rule.points || 1,
      }));
    }

    return result;
  }
}
```

**Design Note**: Quiz executor does NOT use `client` parameter (no database operations). However, it
implements the interface with optional `client?: PoolClient` for consistency. This allows simpler
testing without database mocking.

---

#### 3. Service Integration

**File**: `apps/forms-api/src/services/forms.service.ts`

Update executor factory:

```typescript
import { QuizExecutor } from './executors/quiz.executor';

/**
 * Get executor instance based on config type
 * @source docs/architecture/backend-architecture.md (Strategy Pattern)
 */
private getExecutor(config: TemplateBusinessLogicConfig): ITemplateExecutor {
  switch (config.type) {
    case 'inventory':
      const inventoryRepo = new ProductInventoryRepository(this.pool);
      return new InventoryExecutor(inventoryRepo);

    case 'appointment':
      const bookingRepo = new AppointmentBookingRepository(this.pool);
      return new AppointmentExecutor(bookingRepo);

    case 'quiz':
      return new QuizExecutor(); // No repository needed

    default:
      throw new ApiError(400, `Unknown executor type: ${(config as any).type}`);
  }
}
```

Quiz executor integration (existing `submitForm()` flow works without changes):

```typescript
// Execute business logic with transaction
if (template?.business_logic_config) {
  const client = await this.pool.connect();
  try {
    await client.query('BEGIN');

    const executor = this.getExecutor(template.business_logic_config);

    // Quiz executor ignores client parameter (synchronous execution)
    const result = await executor.execute(
      submission,
      template,
      template.business_logic_config,
      client
    );

    // Store quiz results in submission metadata
    await this.submissionsRepo.updateMetadata(client, submission.id, result.data);

    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    await this.submissionsRepo.delete(submission.id);
    throw error;
  } finally {
    client.release();
  }
}
```

---

#### 4. Repository Extension for Metadata Update

**File**: `apps/forms-api/src/repositories/form-submissions.repository.ts`

Add metadata update method (if not already present):

```typescript
/**
 * Update submission metadata
 * Used to store executor results (quiz scores, booking details, etc.)
 *
 * @param client - Database client (transaction context)
 * @param submissionId - Submission UUID
 * @param metadata - Metadata object to store in JSONB column
 * @returns Updated submission record
 */
async updateMetadata(
  client: PoolClient,
  submissionId: string,
  metadata: Record<string, any>
): Promise<FormSubmission> {
  const query = `
    UPDATE form_submissions
    SET metadata = $1, updated_at = CURRENT_TIMESTAMP
    WHERE id = $2
    RETURNING *
  `;

  const result = await client.query(query, [JSON.stringify(metadata), submissionId]);
  return result.rows[0];
}
```

---

### Frontend Implementation

#### 1. Quiz Results Display Component

**File**:
`apps/form-builder-ui/src/app/features/public/form-renderer/quiz-results/quiz-results.component.ts`

```typescript
import { Component, computed, input, ChangeDetectionStrategy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { CardModule } from 'primeng/card';
import { ButtonModule } from 'primeng/button';
import { ProgressBarModule } from 'primeng/progressbar';
import { QuizResultMetadata } from '@nodeangularfullstack/shared';

/**
 * Component displays quiz results after submission
 * Shows score, pass/fail status, and detailed answer breakdown
 *
 * @since Epic 29, Story 29.13
 * @source docs/architecture/frontend-architecture.md (Signal-based State)
 */
@Component({
  selector: 'app-quiz-results',
  standalone: true,
  imports: [CommonModule, CardModule, ButtonModule, ProgressBarModule],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <p-card class="quiz-results-card">
      <ng-template pTemplate="header">
        <div
          class="results-header"
          [class.passed]="results().passed"
          [class.failed]="!results().passed"
        >
          <i [class]="results().passed ? 'pi pi-check-circle' : 'pi pi-times-circle'"></i>
          <h2>{{ results().passed ? 'Congratulations!' : 'Keep Trying!' }}</h2>
        </div>
      </ng-template>

      <div class="score-summary">
        <div class="score-display">
          <span class="score-value">{{ results().score }}%</span>
          <span class="score-label">Your Score</span>
        </div>

        <p-progressBar
          [value]="results().score"
          [showValue]="false"
          [style]="{ height: '20px', margin: '1rem 0' }"
        />

        <div class="score-breakdown">
          <div class="breakdown-item">
            <span class="label">Correct Answers:</span>
            <span class="value"
              >{{ results().correctAnswers }} / {{ results().totalQuestions }}</span
            >
          </div>

          @if (results().pointsEarned !== undefined) {
            <div class="breakdown-item">
              <span class="label">Points Earned:</span>
              <span class="value">{{ results().pointsEarned }} / {{ results().maxPoints }}</span>
            </div>
          }

          <div class="breakdown-item">
            <span class="label">Status:</span>
            <span
              class="value"
              [class.passed]="results().passed"
              [class.failed]="!results().passed"
            >
              {{ results().passed ? 'PASSED' : 'FAILED' }}
            </span>
          </div>
        </div>
      </div>

      @if (detailedResults() && detailedResults().length > 0) {
        <div class="detailed-results">
          <h3>Answer Breakdown</h3>
          @for (result of detailedResults(); track result.fieldId) {
            <div
              class="answer-item"
              [class.correct]="result.isCorrect"
              [class.incorrect]="!result.isCorrect"
            >
              <div class="answer-header">
                <i [class]="result.isCorrect ? 'pi pi-check' : 'pi pi-times'"></i>
                <span class="field-id">Question {{ $index + 1 }}</span>
                <span class="points">{{ result.points }} pt{{ result.points > 1 ? 's' : '' }}</span>
              </div>
              <div class="answer-body">
                <div class="user-answer"><strong>Your Answer:</strong> {{ result.userAnswer }}</div>
                @if (!result.isCorrect) {
                  <div class="correct-answer">
                    <strong>Correct Answer:</strong> {{ result.correctAnswer }}
                  </div>
                }
              </div>
            </div>
          }
        </div>
      }

      <ng-template pTemplate="footer">
        @if (allowRetake()) {
          <p-button
            label="Retake Quiz"
            icon="pi pi-refresh"
            (onClick)="onRetake()"
            [outlined]="true"
          />
        }
      </ng-template>
    </p-card>
  `,
  styles: [
    `
      .quiz-results-card {
        max-width: 600px;
        margin: 2rem auto;
      }

      .results-header {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 1.5rem;
        border-radius: 6px 6px 0 0;
      }

      .results-header.passed {
        background: linear-gradient(135deg, var(--green-500), var(--green-600));
        color: white;
      }

      .results-header.failed {
        background: linear-gradient(135deg, var(--red-500), var(--red-600));
        color: white;
      }

      .results-header i {
        font-size: 3rem;
      }

      .results-header h2 {
        margin: 0;
        font-size: 1.75rem;
      }

      .score-summary {
        padding: 1.5rem 0;
      }

      .score-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 1rem;
      }

      .score-value {
        font-size: 3.5rem;
        font-weight: bold;
        color: var(--primary-color);
      }

      .score-label {
        font-size: 1rem;
        color: var(--text-color-secondary);
      }

      .score-breakdown {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-top: 1.5rem;
      }

      .breakdown-item {
        display: flex;
        justify-content: space-between;
        padding: 0.75rem;
        background: var(--surface-50);
        border-radius: 6px;
      }

      .breakdown-item .label {
        font-weight: 500;
      }

      .breakdown-item .value {
        font-weight: bold;
      }

      .breakdown-item .value.passed {
        color: var(--green-600);
      }

      .breakdown-item .value.failed {
        color: var(--red-600);
      }

      .detailed-results {
        margin-top: 2rem;
        border-top: 1px solid var(--surface-border);
        padding-top: 1.5rem;
      }

      .detailed-results h3 {
        margin-bottom: 1rem;
        font-size: 1.25rem;
      }

      .answer-item {
        margin-bottom: 1rem;
        padding: 1rem;
        border-radius: 6px;
        border: 2px solid;
      }

      .answer-item.correct {
        background: var(--green-50);
        border-color: var(--green-500);
      }

      .answer-item.incorrect {
        background: var(--red-50);
        border-color: var(--red-500);
      }

      .answer-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 0.75rem;
        font-weight: 600;
      }

      .answer-header i {
        font-size: 1.25rem;
      }

      .answer-item.correct .answer-header i {
        color: var(--green-600);
      }

      .answer-item.incorrect .answer-header i {
        color: var(--red-600);
      }

      .answer-header .field-id {
        flex: 1;
      }

      .answer-header .points {
        color: var(--text-color-secondary);
        font-size: 0.875rem;
      }

      .answer-body {
        padding-left: 1.75rem;
      }

      .user-answer,
      .correct-answer {
        margin-bottom: 0.5rem;
      }

      .correct-answer {
        color: var(--green-700);
      }
    `,
  ],
})
export class QuizResultsComponent {
  // Inputs
  readonly results = input.required<QuizResultMetadata>();
  readonly allowRetake = input<boolean>(false);

  // Computed
  readonly detailedResults = computed(() => {
    const results = this.results();
    return (results as any).detailedResults || [];
  });

  /**
   * Handle retake button click
   */
  onRetake(): void {
    window.location.reload();
  }
}
```

---

#### 2. Integration with FormRendererComponent

**File**: `apps/form-builder-ui/src/app/features/public/form-renderer/form-renderer.component.ts`

Add quiz results handling:

```typescript
import { QuizResultsComponent } from './quiz-results/quiz-results.component';
import { QuizResultMetadata } from '@nodeangularfullstack/shared';

@Component({
  // ... existing config
  imports: [..., QuizResultsComponent]
})
export class FormRendererComponent {
  // ... existing state
  readonly quizResults = signal<QuizResultMetadata | null>(null);
  readonly showQuizResults = signal(false);

  readonly isQuizTemplate = computed(() => {
    const template = this.formSchema()?.template;
    return template?.business_logic_config?.type === 'quiz';
  });

  /**
   * Handle form submission with quiz result display
   */
  onSubmit(): void {
    if (this.formGroup.invalid) {
      this.markAllAsTouched();
      return;
    }

    this.submitting.set(true);
    this.errorMessage.set(null);

    const formData = this.formGroup.value;

    this.formService.submitForm(this.shortCode(), formData).subscribe({
      next: (response) => {
        this.submitting.set(false);

        // Check if response contains quiz results
        if (this.isQuizTemplate() && response.data?.metadata) {
          const metadata = response.data.metadata as QuizResultMetadata;
          this.quizResults.set(metadata);
          this.showQuizResults.set(true);
        } else {
          this.submitSuccess.set(true);
        }
      },
      error: (error) => {
        this.submitting.set(false);
        this.errorMessage.set(error.message || 'Submission failed');
      }
    });
  }
}
```

Update template:

```typescript
@if (showQuizResults() && quizResults()) {
  <app-quiz-results
    [results]="quizResults()!"
    [allowRetake]="formSchema()?.template?.business_logic_config?.allowRetakes ?? false"
  />
} @else {
  <!-- Existing form rendering -->
  <form [formGroup]="formGroup" (ngSubmit)="onSubmit()">
    <!-- Form fields -->
  </form>
}
```

---

#### 3. Analytics Chart Extension

**File**:
`apps/form-builder-ui/src/app/features/dashboard/form-analytics/statistics-engine.service.ts`

Add score distribution analysis:

```typescript
import { QuizResultMetadata } from '@nodeangularfullstack/shared';

/**
 * Analyze quiz score distribution
 * @param submissions - All form submissions
 * @returns Score distribution data for chart
 */
analyzeQuizScores(submissions: FormSubmission[]): ChartData {
  const scoreRanges = {
    '0-20%': 0,
    '21-40%': 0,
    '41-60%': 0,
    '61-80%': 0,
    '81-100%': 0
  };

  submissions.forEach(sub => {
    const metadata = sub.metadata as QuizResultMetadata;
    if (!metadata?.score) return;

    const score = metadata.score;
    if (score <= 20) scoreRanges['0-20%']++;
    else if (score <= 40) scoreRanges['21-40%']++;
    else if (score <= 60) scoreRanges['41-60%']++;
    else if (score <= 80) scoreRanges['61-80%']++;
    else scoreRanges['81-100%']++;
  });

  return {
    labels: Object.keys(scoreRanges),
    datasets: [{
      label: 'Number of Submissions',
      data: Object.values(scoreRanges),
      backgroundColor: [
        'rgba(244, 67, 54, 0.7)',  // Red (0-20%)
        'rgba(255, 152, 0, 0.7)',  // Orange (21-40%)
        'rgba(255, 235, 59, 0.7)', // Yellow (41-60%)
        'rgba(139, 195, 74, 0.7)', // Light Green (61-80%)
        'rgba(76, 175, 80, 0.7)'   // Green (81-100%)
      ]
    }]
  };
}
```

---

**File**:
`apps/form-builder-ui/src/app/features/dashboard/form-analytics/form-analytics.component.ts`

Add quiz chart rendering:

```typescript
@if (isQuizForm()) {
  <p-card header="Score Distribution">
    <canvas #quizScoreChart></canvas>
  </p-card>
}

protected readonly isQuizForm = computed(() => {
  const template = this.formSchema()?.template;
  return template?.business_logic_config?.type === 'quiz';
});

ngAfterViewInit(): void {
  // ... existing charts

  if (this.isQuizForm()) {
    this.renderQuizScoreChart();
  }
}

private renderQuizScoreChart(): void {
  const chartData = this.statisticsEngine.analyzeQuizScores(this.submissions());

  new Chart(this.quizScoreChart.nativeElement, {
    type: 'bar',
    data: chartData,
    options: {
      responsive: true,
      plugins: {
        title: {
          display: true,
          text: 'Score Distribution'
        },
        legend: {
          display: false
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            stepSize: 1
          }
        }
      }
    }
  });
}
```

---

### Testing Implementation

#### 1. Backend Unit Tests

**File**: `apps/forms-api/tests/unit/services/executors/quiz.executor.test.ts`

```typescript
import { QuizExecutor } from '../../../../src/services/executors/quiz.executor';
import { FormTemplate, FormSubmission, QuizLogicConfig } from '@nodeangularfullstack/shared';

describe('QuizExecutor', () => {
  let executor: QuizExecutor;

  const mockConfig: QuizLogicConfig = {
    type: 'quiz',
    scoringRules: [
      { fieldId: 'q1', correctAnswer: 'B', points: 2 },
      { fieldId: 'q2', correctAnswer: 'C', points: 2 },
      { fieldId: 'q3', correctAnswer: 'A', points: 1 },
      { fieldId: 'q4', correctAnswer: 'D', points: 1 },
      { fieldId: 'q5', correctAnswer: 'B', points: 1 },
    ],
    passingScore: 60,
    showResults: true,
  };

  const mockTemplate: FormTemplate = {
    id: 'template-123',
    name: 'Quiz Assessment',
    category: 'QUIZ',
    template_schema: {} as any,
    business_logic_config: mockConfig,
    is_active: true,
    created_at: new Date(),
    updated_at: new Date(),
  };

  beforeEach(() => {
    executor = new QuizExecutor();
  });

  describe('validate', () => {
    it('should pass validation for complete quiz submission', async () => {
      const submission = {
        data: {
          q1: 'B',
          q2: 'C',
          q3: 'A',
          q4: 'D',
          q5: 'B',
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(true);
      expect(result.errors).toEqual([]);
    });

    it('should fail validation for missing answers', async () => {
      const submission = {
        data: {
          q1: 'B',
          q2: 'C',
          // q3, q4, q5 missing
        },
      };

      const result = await executor.validate(submission, mockTemplate, mockConfig);

      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors.some((e) => e.includes('q3'))).toBe(true);
    });

    it('should fail validation for empty scoring rules', async () => {
      const invalidConfig: QuizLogicConfig = {
        ...mockConfig,
        scoringRules: [],
      };

      const submission = { data: {} };

      const result = await executor.validate(submission, mockTemplate, invalidConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Quiz must have at least one scoring rule');
    });

    it('should fail validation for invalid passing score', async () => {
      const invalidConfig: QuizLogicConfig = {
        ...mockConfig,
        passingScore: 150,
      };

      const submission = { data: { q1: 'A', q2: 'B', q3: 'C', q4: 'D', q5: 'A' } };

      const result = await executor.validate(submission, mockTemplate, invalidConfig);

      expect(result.valid).toBe(false);
      expect(result.errors).toContain('Passing score must be between 0 and 100');
    });
  });

  describe('execute', () => {
    const mockSubmission: FormSubmission = {
      id: 'sub-123',
      form_id: 'form-123',
      data: {
        q1: 'B', // Correct (2 pts)
        q2: 'C', // Correct (2 pts)
        q3: 'A', // Correct (1 pt)
        q4: 'A', // Wrong (0 pts)
        q5: 'B', // Correct (1 pt)
      },
      submitted_at: new Date(),
      created_at: new Date(),
    };

    it('should calculate correct score (80% with custom points)', async () => {
      const result = await executor.execute(mockSubmission, mockTemplate, mockConfig);

      expect(result.success).toBe(true);
      expect(result.data.score).toBe(80); // 4 correct out of 5 = 80%
      expect(result.data.correctAnswers).toBe(4);
      expect(result.data.totalQuestions).toBe(5);
      expect(result.data.pointsEarned).toBe(6); // 2+2+1+1 = 6 pts
      expect(result.data.maxPoints).toBe(7); // 2+2+1+1+1 = 7 pts
      expect(result.data.passed).toBe(true); // 80% >= 60%
    });

    it('should mark as failed when score below passing threshold', async () => {
      const failingSubmission: FormSubmission = {
        ...mockSubmission,
        data: {
          q1: 'A', // Wrong
          q2: 'B', // Wrong
          q3: 'B', // Wrong
          q4: 'D', // Correct (1 pt)
          q5: 'A', // Wrong
        },
      };

      const result = await executor.execute(failingSubmission, mockTemplate, mockConfig);

      expect(result.success).toBe(true);
      expect(result.data.score).toBe(20); // 1 correct out of 5 = 20%
      expect(result.data.passed).toBe(false); // 20% < 60%
      expect(result.message).toContain('Passing: 60%');
    });

    it('should include detailed results when showResults is true', async () => {
      const result = await executor.execute(mockSubmission, mockTemplate, mockConfig);

      expect(result.data.detailedResults).toBeDefined();
      expect(result.data.detailedResults.length).toBe(5);
      expect(result.data.detailedResults[0]).toMatchObject({
        fieldId: 'q1',
        userAnswer: 'B',
        correctAnswer: 'B',
        isCorrect: true,
        points: 2,
      });
      expect(result.data.detailedResults[3]).toMatchObject({
        fieldId: 'q4',
        userAnswer: 'A',
        correctAnswer: 'D',
        isCorrect: false,
        points: 1,
      });
    });

    it('should NOT include detailed results when showResults is false', async () => {
      const configNoResults: QuizLogicConfig = {
        ...mockConfig,
        showResults: false,
      };

      const result = await executor.execute(mockSubmission, mockTemplate, configNoResults);

      expect(result.data.detailedResults).toBeUndefined();
    });

    it('should handle perfect score (100%)', async () => {
      const perfectSubmission: FormSubmission = {
        ...mockSubmission,
        data: {
          q1: 'B',
          q2: 'C',
          q3: 'A',
          q4: 'D',
          q5: 'B',
        },
      };

      const result = await executor.execute(perfectSubmission, mockTemplate, mockConfig);

      expect(result.data.score).toBe(100);
      expect(result.data.correctAnswers).toBe(5);
      expect(result.data.passed).toBe(true);
      expect(result.data.pointsEarned).toBe(7);
      expect(result.message).toContain('passed');
    });

    it('should handle zero score (0%)', async () => {
      const zeroSubmission: FormSubmission = {
        ...mockSubmission,
        data: {
          q1: 'A',
          q2: 'A',
          q3: 'B',
          q4: 'A',
          q5: 'A',
        },
      };

      const result = await executor.execute(zeroSubmission, mockTemplate, mockConfig);

      expect(result.data.score).toBe(0);
      expect(result.data.correctAnswers).toBe(0);
      expect(result.data.passed).toBe(false);
      expect(result.data.pointsEarned).toBe(0);
    });

    it('should execute synchronously without database client', async () => {
      const startTime = Date.now();

      await executor.execute(mockSubmission, mockTemplate, mockConfig);

      const executionTime = Date.now() - startTime;

      // Should execute in < 50ms (in-memory calculation)
      expect(executionTime).toBeLessThan(50);
    });
  });
});
```

---

#### 2. Backend Integration Tests

**File**: `apps/forms-api/tests/integration/quiz-scoring.test.ts`

```typescript
import request from 'supertest';
import app from '../../src/server';
import { pool } from '../../src/config/database';
import { PoolClient } from 'pg';

describe('Quiz Scoring Integration Tests', () => {
  let client: PoolClient;
  let formShortCode: string;

  beforeAll(async () => {
    client = await pool.connect();
    await client.query('BEGIN');

    // Create quiz template
    const templateResult = await client.query(`
      INSERT INTO form_templates (name, category, template_schema, business_logic_config, is_active)
      VALUES (
        'Test Quiz',
        'QUIZ',
        '{"fields": [{"id": "q1", "type": "RADIO"}, {"id": "q2", "type": "RADIO"}]}'::jsonb,
        '{"type": "quiz", "scoringRules": [{"fieldId": "q1", "correctAnswer": "B"}, {"fieldId": "q2", "correctAnswer": "C"}], "passingScore": 50, "showResults": true}'::jsonb,
        true
      )
      RETURNING id
    `);

    const templateId = templateResult.rows[0].id;

    // Create form with template
    const formResult = await client.query(
      `
      INSERT INTO forms (title, is_published, template_id)
      VALUES ('Quiz Test Form', true, $1)
      RETURNING id
    `,
      [templateId]
    );

    const formId = formResult.rows[0].id;

    // Create short link
    const shortLinkResult = await client.query(
      `
      INSERT INTO short_links (short_code, form_schema_id)
      VALUES ('quiz-test', $1)
      RETURNING short_code
    `,
      [formId]
    );
    formShortCode = shortLinkResult.rows[0].short_code;

    await client.query('COMMIT');
  });

  afterAll(async () => {
    await client.query('ROLLBACK');
    client.release();
    await pool.end();
  });

  describe('POST /api/public/forms/:shortCode/submit', () => {
    it('should calculate score and mark as passed', async () => {
      const response = await request(app).post(`/api/public/forms/${formShortCode}/submit`).send({
        q1: 'B', // Correct
        q2: 'C', // Correct
      });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.metadata.score).toBe(100);
      expect(response.body.data.metadata.correctAnswers).toBe(2);
      expect(response.body.data.metadata.passed).toBe(true);
      expect(response.body.data.metadata.detailedResults).toBeDefined();
    });

    it('should calculate score and mark as failed', async () => {
      const response = await request(app).post(`/api/public/forms/${formShortCode}/submit`).send({
        q1: 'A', // Wrong
        q2: 'A', // Wrong
      });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data.metadata.score).toBe(0);
      expect(response.body.data.metadata.correctAnswers).toBe(0);
      expect(response.body.data.metadata.passed).toBe(false);
    });

    it('should reject submission with missing answers', async () => {
      const response = await request(app).post(`/api/public/forms/${formShortCode}/submit`).send({
        q1: 'B',
        // q2 missing
      });

      expect(response.status).toBe(400);
      expect(response.body.message).toContain('q2');
    });

    it('should store metadata in form_submissions table', async () => {
      const response = await request(app).post(`/api/public/forms/${formShortCode}/submit`).send({
        q1: 'B',
        q2: 'C',
      });

      const submissionId = response.body.data.id;

      const metadataResult = await client.query(
        'SELECT metadata FROM form_submissions WHERE id = $1',
        [submissionId]
      );

      expect(metadataResult.rows[0].metadata).toMatchObject({
        score: 100,
        correctAnswers: 2,
        totalQuestions: 2,
        passed: true,
      });
    });
  });

  describe('Performance', () => {
    it('should execute scoring in < 50ms', async () => {
      const startTime = Date.now();

      await request(app)
        .post(`/api/public/forms/${formShortCode}/submit`)
        .send({ q1: 'B', q2: 'C' });

      const executionTime = Date.now() - startTime;

      expect(executionTime).toBeLessThan(50);
    });
  });
});
```

---

#### 3. Frontend Component Tests

**File**:
`apps/form-builder-ui/src/app/features/public/form-renderer/quiz-results/quiz-results.component.spec.ts`

```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { QuizResultsComponent } from './quiz-results.component';
import { QuizResultMetadata } from '@nodeangularfullstack/shared';
import { signal } from '@angular/core';

describe('QuizResultsComponent', () => {
  let component: QuizResultsComponent;
  let fixture: ComponentFixture<QuizResultsComponent>;

  const mockPassedResults: QuizResultMetadata = {
    score: 80,
    correctAnswers: 4,
    totalQuestions: 5,
    passed: true,
    pointsEarned: 8,
    maxPoints: 10,
    answeredAt: '2025-01-09T12:00:00Z',
  };

  const mockFailedResults: QuizResultMetadata = {
    score: 40,
    correctAnswers: 2,
    totalQuestions: 5,
    passed: false,
    pointsEarned: 4,
    maxPoints: 10,
    answeredAt: '2025-01-09T12:00:00Z',
  };

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [QuizResultsComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(QuizResultsComponent);
    component = fixture.componentInstance;
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should display passed results correctly', () => {
    fixture.componentRef.setInput('results', mockPassedResults);
    fixture.detectChanges();

    const compiled = fixture.nativeElement;
    expect(compiled.textContent).toContain('80%');
    expect(compiled.textContent).toContain('Congratulations!');
    expect(compiled.textContent).toContain('PASSED');
    expect(compiled.querySelector('.results-header.passed')).toBeTruthy();
  });

  it('should display failed results correctly', () => {
    fixture.componentRef.setInput('results', mockFailedResults);
    fixture.detectChanges();

    const compiled = fixture.nativeElement;
    expect(compiled.textContent).toContain('40%');
    expect(compiled.textContent).toContain('Keep Trying!');
    expect(compiled.textContent).toContain('FAILED');
    expect(compiled.querySelector('.results-header.failed')).toBeTruthy();
  });

  it('should display score breakdown', () => {
    fixture.componentRef.setInput('results', mockPassedResults);
    fixture.detectChanges();

    const compiled = fixture.nativeElement;
    expect(compiled.textContent).toContain('4 / 5');
    expect(compiled.textContent).toContain('8 / 10');
  });

  it('should show retake button when allowRetake is true', () => {
    fixture.componentRef.setInput('results', mockPassedResults);
    fixture.componentRef.setInput('allowRetake', true);
    fixture.detectChanges();

    const retakeButton = fixture.nativeElement.querySelector('p-button[label="Retake Quiz"]');
    expect(retakeButton).toBeTruthy();
  });

  it('should hide retake button when allowRetake is false', () => {
    fixture.componentRef.setInput('results', mockPassedResults);
    fixture.componentRef.setInput('allowRetake', false);
    fixture.detectChanges();

    const retakeButton = fixture.nativeElement.querySelector('p-button[label="Retake Quiz"]');
    expect(retakeButton).toBeFalsy();
  });

  it('should display detailed results when available', () => {
    const resultsWithDetails = {
      ...mockPassedResults,
      detailedResults: [
        { fieldId: 'q1', userAnswer: 'B', correctAnswer: 'B', isCorrect: true, points: 2 },
        { fieldId: 'q2', userAnswer: 'A', correctAnswer: 'C', isCorrect: false, points: 2 },
      ],
    };

    fixture.componentRef.setInput('results', resultsWithDetails);
    fixture.detectChanges();

    const compiled = fixture.nativeElement;
    expect(compiled.textContent).toContain('Answer Breakdown');
    expect(compiled.querySelectorAll('.answer-item').length).toBe(2);
  });
});
```

---

### Template Seed Data

**File**: `apps/forms-api/database/seeds/033_seed_quiz_template.ts`

```typescript
import { Pool } from 'pg';

/**
 * Seed quiz assessment template
 * @since Epic 29, Story 29.13
 */
export async function seedQuizTemplate(pool: Pool): Promise<void> {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // Check if template already exists
    const existing = await client.query(
      `SELECT id FROM form_templates WHERE name = 'Quiz Assessment'`
    );

    if (existing.rows.length > 0) {
      console.log('Quiz Assessment template already exists, skipping...');
      await client.query('COMMIT');
      return;
    }

    // Create template
    const templateSchema = {
      fields: [
        {
          id: 'q1',
          type: 'RADIO',
          label: 'What is 2 + 2?',
          required: true,
          options: [
            { label: 'Three', value: 'A' },
            { label: 'Four', value: 'B' },
            { label: 'Five', value: 'C' },
            { label: 'Six', value: 'D' },
          ],
          order: 1,
        },
        {
          id: 'q2',
          type: 'RADIO',
          label: 'What is the capital of France?',
          required: true,
          options: [
            { label: 'London', value: 'A' },
            { label: 'Berlin', value: 'B' },
            { label: 'Paris', value: 'C' },
            { label: 'Madrid', value: 'D' },
          ],
          order: 2,
        },
        {
          id: 'q3',
          type: 'RADIO',
          label: 'Which planet is known as the Red Planet?',
          required: true,
          options: [
            { label: 'Mars', value: 'A' },
            { label: 'Venus', value: 'B' },
            { label: 'Jupiter', value: 'C' },
            { label: 'Saturn', value: 'D' },
          ],
          order: 3,
        },
        {
          id: 'q4',
          type: 'RADIO',
          label: 'What is the largest ocean on Earth?',
          required: true,
          options: [
            { label: 'Atlantic Ocean', value: 'A' },
            { label: 'Indian Ocean', value: 'B' },
            { label: 'Arctic Ocean', value: 'C' },
            { label: 'Pacific Ocean', value: 'D' },
          ],
          order: 4,
        },
        {
          id: 'q5',
          type: 'RADIO',
          label: 'How many continents are there?',
          required: true,
          options: [
            { label: 'Five', value: 'A' },
            { label: 'Seven', value: 'B' },
            { label: 'Six', value: 'C' },
            { label: 'Eight', value: 'D' },
          ],
          order: 5,
        },
      ],
    };

    const businessLogicConfig = {
      type: 'quiz',
      scoringRules: [
        { fieldId: 'q1', correctAnswer: 'B', points: 2 },
        { fieldId: 'q2', correctAnswer: 'C', points: 2 },
        { fieldId: 'q3', correctAnswer: 'A', points: 2 },
        { fieldId: 'q4', correctAnswer: 'D', points: 2 },
        { fieldId: 'q5', correctAnswer: 'B', points: 2 },
      ],
      passingScore: 60,
      showResults: true,
      allowRetakes: true,
    };

    await client.query(
      `
      INSERT INTO form_templates (
        name,
        category,
        description,
        template_schema,
        business_logic_config,
        is_active
      ) VALUES ($1, $2, $3, $4, $5, $6)
    `,
      [
        'Quiz Assessment',
        'QUIZ',
        'Educational quiz template with automatic scoring and immediate results',
        JSON.stringify(templateSchema),
        JSON.stringify(businessLogicConfig),
        true,
      ]
    );

    console.log('✓ Quiz Assessment template seeded successfully');

    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error seeding quiz template:', error);
    throw error;
  } finally {
    client.release();
  }
}
```

---

## Tasks

| ID        | Task                                                                    | Acceptance Criteria | Estimated Hours |
| --------- | ----------------------------------------------------------------------- | ------------------- | --------------- |
| 1         | Extend shared types with `QuizLogicConfig` and `QuizResultMetadata`     | AC3                 | 1.0             |
| 2         | Create `QuizExecutor` strategy class implementing `ITemplateExecutor`   | AC4, AC5            | 3.0             |
| 3         | Integrate `QuizExecutor` into `FormsService` executor factory           | AC6                 | 1.0             |
| 4         | Add `updateMetadata()` method to `FormSubmissionsRepository` if missing | AC6                 | 1.5             |
| 5         | Create `QuizResultsComponent` with score display and detailed breakdown | AC7                 | 4.5             |
| 6         | Integrate `QuizResultsComponent` with `FormRendererComponent`           | AC7                 | 2.0             |
| 7         | Extend `StatisticsEngineService` with `analyzeQuizScores()` method      | AC8                 | 2.5             |
| 8         | Update `FormAnalyticsComponent` to render score distribution chart      | AC8                 | 2.0             |
| 9         | Write backend unit tests for `QuizExecutor`                             | AC4-AC6             | 3.0             |
| 10        | Write backend integration tests for quiz scoring flow                   | AC6, AC7            | 2.5             |
| 11        | Write frontend component tests for `QuizResultsComponent`               | AC7                 | 2.0             |
| 12        | Write frontend component tests for analytics chart integration          | AC8                 | 1.5             |
| 13        | Create seed data for quiz template                                      | AC1, AC2            | 1.5             |
| 14        | Write performance tests validating 50ms execution time                  | IV2                 | 1.0             |
| **Total** |                                                                         |                     | **29.0 hours**  |

---

## QA Results

_To be updated during development_

| Test Type         | Status  | Coverage         | Notes |
| ----------------- | ------- | ---------------- | ----- |
| Unit Tests        | Pending | Target: 90%+     | -     |
| Integration Tests | Pending | -                | -     |
| Component Tests   | Pending | Target: 85%+     | -     |
| Performance Tests | Pending | Target: 50ms P95 | -     |

---

## Gate Status

**Quality Gate**: ❌ Not Started

**Checklist**:

- [ ] All unit tests passing (90%+ coverage for executor)
- [ ] All integration tests passing
- [ ] All component tests passing (quiz results + analytics chart)
- [ ] Performance requirement met (50ms P95 for scoring)
- [ ] No regression in existing form submission functionality
- [ ] Score distribution chart renders correctly in analytics
- [ ] Code reviewed and approved
- [ ] TypeScript strict mode passing with no errors
- [ ] ESLint passing with no warnings

---

## Related Documentation

- **PRD**: docs/prd/epic-29-form-templates-system.md
- **Architecture**: docs/architecture/backend-architecture.md (Strategy Pattern)
- **Architecture**: docs/architecture/frontend-architecture.md (Chart.js Integration)
- **Related Stories**:
  - Story 29.11: Product Template with Inventory Tracking (Base ITemplateExecutor Interface)
  - Story 29.12: Appointment Booking Template (Transaction Pattern)
  - Story 29.14: Poll Template with Vote Aggregation (Next story)
- **Gate File**: docs/qa/gates/29.13-quiz-template-scoring-logic.yml (to be created)

---

## Notes

### Simplicity Advantage

**Key Difference from Stories 29.11-29.12**: Quiz executor requires NO database tables, NO
transactions, NO row-level locking. This makes it:

- **Faster**: < 50ms (vs 150-200ms for inventory/appointment)
- **Simpler**: Pure calculation (no async database operations)
- **Easier to Test**: No database mocking required (can use in-memory data)

### Metadata Storage Pattern

**JSONB Column**: Uses existing `form_submissions.metadata` JSONB column for score storage:

- **Flexible Schema**: Can store any quiz result structure without migrations
- **Queryable**: PostgreSQL JSONB operators allow filtering by score (e.g.,
  `metadata->>'score' > 80`)
- **Backward Compatible**: Non-quiz submissions have `metadata = null` or empty object

### Score Distribution Chart

**Chart.js Integration**: Reuses existing Chart.js setup from form analytics:

- Bar chart with 5 score ranges (0-20%, 21-40%, 41-60%, 61-80%, 81-100%)
- Color-coded bars (red → green gradient)
- Renders alongside existing analytics charts (no UI refactoring)

### Privacy Consideration

**showResults Flag**: Controls whether detailed answers are included in response:

- `showResults: true` → User sees correct/incorrect answers immediately
- `showResults: false` → User only sees percentage score (prevents cheating on retakes)
- Detailed results stored in metadata regardless (admin analytics always have access)

---

_Story created: 2025-01-09_ _Last updated: 2025-01-09_
