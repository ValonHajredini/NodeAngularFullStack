# Story 3.1: Multi-Tenancy Database Design

## Status
Approved

## Story
**As a** system architect,
**I want** a database schema that supports both single-tenant and multi-tenant operations,
**so that** the same codebase can serve different business models without modification.

## Acceptance Criteria
1. Database schema includes tenant table with configuration and isolation settings
2. User table includes optional tenant_id foreign key for multi-tenant mode
3. Database queries automatically filter by tenant context when multi-tenancy is enabled
4. Single-tenant mode operates without tenant filtering or additional overhead
5. Migration scripts handle conversion between single-tenant and multi-tenant modes

## Tasks / Subtasks
- [ ] Task 1: Create enhanced tenant table with configuration and isolation settings (AC: 1)
  - [ ] Add tenant settings JSONB field for flexible configuration storage
  - [ ] Implement tenant plan levels with user limits
  - [ ] Add tenant status and activation controls
  - [ ] Create tenant slug for URL-safe identifiers
  - [ ] Add tenant branding and feature toggle support
- [ ] Task 2: Modify user table to support optional multi-tenancy (AC: 2)
  - [ ] Add optional tenant_id foreign key to users table
  - [ ] Update unique constraints to support tenant isolation
  - [ ] Implement composite unique constraint on (email, tenant_id)
  - [ ] Add tenant-aware indexes for performance
  - [ ] Ensure backward compatibility with existing user data
- [ ] Task 3: Implement tenant-aware repository pattern (AC: 3)
  - [ ] Extend BaseRepository with tenant filtering capabilities
  - [ ] Add automatic tenant context injection in data queries
  - [ ] Implement tenant isolation in all repository methods
  - [ ] Create tenant-aware findById, findMany, create, update, delete methods
  - [ ] Add tenant validation to prevent cross-tenant data access
- [ ] Task 4: Create single-tenant mode optimization (AC: 4)
  - [ ] Implement conditional tenant filtering based on environment
  - [ ] Optimize queries to skip tenant checks in single-tenant mode
  - [ ] Add tenant mode detection middleware
  - [ ] Ensure zero performance overhead in single-tenant deployments
  - [ ] Create feature flag system for multi-tenancy enable/disable
- [ ] Task 5: Create migration scripts for tenant mode conversion (AC: 5)
  - [ ] Create migration to add tenant table and relationships
  - [ ] Create reverse migration to remove multi-tenancy support
  - [ ] Add data migration scripts for existing user data
  - [ ] Create tenant seed data for development and testing
  - [ ] Add validation scripts to verify tenant data integrity
- [ ] Task 6: Implement Row-Level Security (RLS) policies (AC: 1, 3)
  - [ ] Enable RLS on tenant-aware tables
  - [ ] Create RLS policies for tenant data isolation
  - [ ] Add database-level tenant context functions
  - [ ] Implement secure tenant switching mechanisms
  - [ ] Add tenant access logging and audit trails

## Dev Notes

### Previous Story Insights
[Source: Story 2.4 completion notes]
- Comprehensive API testing suite implemented with database setup/teardown utilities
- Test data factories and fixtures available for consistent testing
- Transaction isolation patterns established for test environments
- Database connection and migration utilities already implemented

### Technology Stack for Multi-Tenancy
[Source: architecture/tech-stack.md]
- **Database**: PostgreSQL 15+ with JSONB support for tenant configuration
- **Authentication**: JWT + Passport.js for tenant-aware token handling
- **Migration Tool**: Custom migration utilities with TypeScript support
- **Testing**: Jest + Supertest with database transaction rollback for test isolation

### Database Schema Architecture
[Source: architecture/database-schema.md]
**Existing Schema Foundation:**
```sql
-- Tenants table (already defined, needs enhancement)
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255) UNIQUE NOT NULL,
    settings JSONB DEFAULT '{}',
    plan VARCHAR(50) DEFAULT 'free',
    max_users INTEGER DEFAULT 5,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT true
);

-- Users table with optional tenant support (existing)
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    role VARCHAR(50) DEFAULT 'user',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT true,
    email_verified BOOLEAN DEFAULT false,
    UNIQUE(email, tenant_id)
);
```

### Data Models for Multi-Tenancy
[Source: architecture/data-models.md]
**Enhanced Tenant Interface:**
```typescript
interface Tenant {
  id: string;
  name: string;
  slug: string;
  settings: {
    branding?: {
      primaryColor?: string;
      logo?: string;
    };
    features: {
      [key: string]: boolean;
    };
    isolation: {
      level: 'row' | 'schema' | 'database';
      rls: boolean;
    };
  };
  plan: 'free' | 'starter' | 'professional' | 'enterprise';
  maxUsers: number;
  createdAt: Date;
  isActive: boolean;
}

interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: 'admin' | 'user' | 'readonly';
  tenantId?: string; // Optional for multi-tenant mode
  createdAt: Date;
  updatedAt: Date;
  lastLogin?: Date;
  isActive: boolean;
  emailVerified: boolean;
}
```

### Repository Pattern with Tenant Awareness
[Source: architecture/backend-architecture.md]
**Base Repository Template:**
```typescript
// repositories/base.repository.ts
export abstract class BaseRepository<T> {
  constructor(
    protected pool: Pool,
    protected tableName: string
  ) {}

  async findById(id: string, tenantId?: string): Promise<T | null> {
    let query = `SELECT * FROM ${this.tableName} WHERE id = $1`;
    const params: any[] = [id];

    if (tenantId && this.supportsTenancy()) {
      query += ' AND tenant_id = $2';
      params.push(tenantId);
    }

    const result = await this.pool.query(query, params);
    return result.rows[0] || null;
  }

  protected supportsTenancy(): boolean {
    return ['users', 'audit_logs'].includes(this.tableName);
  }
}
```

### File Locations and Project Structure
[Source: architecture/unified-project-structure.md]
**Database Files:**
- Migration files: `apps/api/database/migrations/`
- Repository classes: `apps/api/src/repositories/`
- Database utilities: `apps/api/src/utils/`
- Seed data: `apps/api/database/seeds/`

**Key File Paths:**
- `apps/api/database/migrations/003_enhance_multi_tenancy.sql` - Enhanced tenant schema
- `apps/api/src/repositories/tenant.repository.ts` - Tenant data access
- `apps/api/src/repositories/base.repository.ts` - Enhanced base repository
- `apps/api/src/utils/tenant.utils.ts` - Tenant context utilities
- `apps/api/src/middleware/tenant.middleware.ts` - Tenant context middleware

### Migration Strategy
[Source: architecture/database-schema.md]
**Migration Files Required:**
1. `003_enhance_multi_tenancy.sql` - Enhance tenant table with advanced settings
2. `004_add_tenant_rls_policies.sql` - Implement Row-Level Security policies
3. `005_tenant_audit_logging.sql` - Add tenant-aware audit logging

**Migration Utilities:**
- Use existing migration utility: `apps/api/src/utils/migration.utils.ts`
- Follow established migration pattern with up/down functions
- Include data validation and rollback mechanisms

### Row-Level Security Implementation
[Source: architecture/database-schema.md]
**RLS Policy Pattern:**
```sql
-- Enable RLS on tenant-aware tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Policy for tenant isolation
CREATE POLICY tenant_isolation ON users
    FOR ALL TO application_role
    USING (tenant_id = current_setting('app.current_tenant_id')::UUID);
```

## Testing

### Test File Locations
[Source: architecture/testing-strategy.md]
- **Integration Tests**: `apps/api/tests/integration/`
- **Unit Tests**: `apps/api/tests/unit/repositories/`
- **Migration Tests**: `apps/api/tests/integration/migrations/`

### Testing Requirements
- Database migration testing with up/down validation
- Tenant isolation verification across all repository methods
- Performance testing for single-tenant vs multi-tenant mode
- Cross-tenant access prevention validation
- RLS policy effectiveness testing
- Migration rollback and data integrity verification

### Test Examples Pattern
```typescript
// Tenant isolation testing
describe('Tenant Isolation', () => {
  it('should prevent cross-tenant data access', async () => {
    const tenant1User = await createTestUser({ tenantId: 'tenant-1' });
    const tenant2User = await createTestUser({ tenantId: 'tenant-2' });

    const result = await usersRepository.findById(
      tenant1User.id,
      'tenant-2' // Wrong tenant context
    );

    expect(result).toBeNull();
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-21 | 1.0 | Initial story creation for multi-tenancy database design | Bob (Scrum Master) |