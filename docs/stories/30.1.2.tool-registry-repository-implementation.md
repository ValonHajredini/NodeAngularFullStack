# Story 30.1.2: Tool Registry Repository Implementation

## Status

Draft

## Story

**As a** backend developer, **I want** a repository class for tool registry data access, **so that**
business logic doesn't directly access the database.

## Acceptance Criteria

1. ✅ `ToolRegistryRepository` class implements CRUD operations
2. ✅ Methods: `findAll()`, `findById()`, `create()`, `update()`, `delete()`
3. ✅ Query methods: `findByStatus()`, `findExported()`, `search()`
4. ✅ Proper error handling and validation
5. ✅ Unit tests with ≥90% coverage

## Tasks / Subtasks

- [ ] **Task 1: Create ToolRegistryRepository class with CRUD methods** (AC: 1, 2)
  - [ ] Create `tool-registry.repository.ts` in `apps/api/src/repositories/`
  - [ ] Import Pool from pg and ToolRegistryRecord types from shared package
  - [ ] Implement constructor accepting Pool instance
  - [ ] Implement `findAll()` - returns all tools ordered by created_at DESC
  - [ ] Implement `findById(toolId: string)` - returns tool by tool_id or null
  - [ ] Implement `create(input: CreateToolInput)` - inserts new tool, returns record
  - [ ] Implement `update(toolId: string, input: UpdateToolInput)` - updates tool, returns record
  - [ ] Implement `delete(toolId: string)` - soft delete by setting is_active flag (if exists) or
        hard delete
  - [ ] Create private `mapRowToRecord(row: any)` helper to convert snake_case DB columns to
        camelCase

- [ ] **Task 2: Implement specialized query methods** (AC: 3)
  - [ ] Implement `findByStatus(status: string)` - filters by status, ordered by name ASC
  - [ ] Implement `findExported()` - returns tools where is_exported = true
  - [ ] Implement `search(searchTerm: string)` - ILIKE search on name and description
  - [ ] Implement `findNonExported()` - returns tools where is_exported = false (for dashboard)

- [ ] **Task 3: Add error handling and validation** (AC: 4)
  - [ ] Wrap database queries in try-catch blocks
  - [ ] Throw descriptive errors for common cases (tool not found, duplicate tool_id)
  - [ ] Add input validation in create() for required fields
  - [ ] Handle null/undefined edge cases gracefully
  - [ ] Log errors with Winston (follow logging standards from architecture)

- [ ] **Task 4: Add JSDoc documentation** (AC: 1-4)
  - [ ] Add class-level JSDoc describing repository responsibility
  - [ ] Document each public method with @param, @returns, @throws tags
  - [ ] Include usage examples in JSDoc for complex methods
  - [ ] Follow JSDoc standards from coding-standards.md

- [ ] **Task 5: Write comprehensive unit tests** (AC: 5)
  - [ ] Create `tool-registry.repository.test.ts` in `apps/api/tests/unit/repositories/`
  - [ ] Mock pg.Pool using Jest mocks
  - [ ] Test findAll() - verify query and result mapping
  - [ ] Test findById() - both found and not found cases
  - [ ] Test create() - verify INSERT query structure and parameterization
  - [ ] Test update() - verify dynamic SET clause and error when not found
  - [ ] Test delete() - verify DELETE query
  - [ ] Test findByStatus() - verify WHERE clause and ordering
  - [ ] Test search() - verify ILIKE query with wildcard placeholders
  - [ ] Test edge cases: null values, empty arrays, SQL injection attempts
  - [ ] Achieve ≥90% code coverage

- [ ] **Task 6: Export repository from index** (AC: 1)
  - [ ] Create or update `apps/api/src/repositories/index.ts`
  - [ ] Export `ToolRegistryRepository` for use in service layer

## Dev Notes

### Repository Pattern Architecture

[Source: architecture/backend-architecture.md#data-access-layer]

**Base Repository Pattern:** The codebase uses a BaseRepository pattern for common CRUD operations.
While we won't extend BaseRepository for this story (due to tool_registry unique fields), we should
follow the same patterns:

```typescript
export abstract class BaseRepository<T> {
  constructor(
    protected pool: Pool,
    protected tableName: string
  ) {}

  async findById(id: string, tenantId?: string): Promise<T | null> {
    // Parameterized queries
    const result = await this.pool.query(query, params);
    return result.rows[0] || null;
  }
}
```

**Key Principles:**

- Accept Pool in constructor (dependency injection)
- Use parameterized queries (`$1, $2, ...`) to prevent SQL injection
- Return domain objects (TypeScript interfaces), not raw database rows
- Map snake_case columns to camelCase in TypeScript

### Database Connection

[Source: architecture/backend-architecture.md#data-access-layer]

The repository receives a `Pool` instance from `pg`:

```typescript
import { Pool, QueryResult } from 'pg';

export class ToolRegistryRepository {
  constructor(private pool: Pool) {}

  async findAll(): Promise<ToolRegistryRecord[]> {
    const result = await this.pool.query('SELECT * FROM tool_registry ORDER BY created_at DESC');
    return result.rows.map(this.mapRowToRecord);
  }
}
```

### Project Structure

[Source: architecture/unified-project-structure.md]

```
apps/api/src/
├── repositories/
│   ├── tool-registry.repository.ts   # <-- New file
│   ├── users.repository.ts           # Existing pattern
│   ├── base.repository.ts            # Existing base class
│   └── index.ts                      # Export all repositories
├── services/                         # Service layer (Epic 30.2)
└── controllers/                      # Controllers (Epic 30.2)

apps/api/tests/unit/
└── repositories/
    ├── tool-registry.repository.test.ts   # <-- New test file
    └── users.repository.test.ts           # Existing pattern
```

### Type Safety with Shared Package

[Source: architecture/coding-standards.md#critical-fullstack-rules]

**CRITICAL:** Always import types from `@nodeangularfullstack/shared`:

```typescript
import { ToolRegistryRecord, CreateToolInput, UpdateToolInput } from '@nodeangularfullstack/shared';
```

These types were created in Story 30.1.1 and must be built before use:

```bash
npm run build:shared
```

### SQL Injection Prevention

[Source: architecture/coding-standards.md#critical-fullstack-rules]

**CRITICAL:** Use parameterized queries to prevent SQL injection:

```typescript
// ✅ CORRECT - Parameterized query
const result = await this.pool.query('SELECT * FROM tool_registry WHERE tool_id = $1', [toolId]);

// ❌ WRONG - SQL injection risk!
const result = await this.pool.query(`SELECT * FROM tool_registry WHERE tool_id = '${toolId}'`);
```

### Update Method Pattern

The `update()` method should build dynamic SET clauses only for provided fields:

```typescript
async update(toolId: string, input: UpdateToolInput): Promise<ToolRegistryRecord> {
  const updates: string[] = [];
  const values: any[] = [];
  let paramCount = 1;

  if (input.name !== undefined) {
    updates.push(`name = $${paramCount++}`);
    values.push(input.name);
  }
  if (input.status !== undefined) {
    updates.push(`status = $${paramCount++}`);
    values.push(input.status);
  }
  // ... more fields ...

  updates.push(`updated_at = CURRENT_TIMESTAMP`);
  values.push(toolId);

  const query = `
    UPDATE tool_registry
    SET ${updates.join(', ')}
    WHERE tool_id = $${paramCount}
    RETURNING *
  `;

  const result = await this.pool.query(query, values);

  if (result.rows.length === 0) {
    throw new Error(`Tool '${toolId}' not found`);
  }

  return this.mapRowToRecord(result.rows[0]);
}
```

### Row Mapping Pattern

Convert snake_case database columns to camelCase TypeScript:

```typescript
private mapRowToRecord(row: any): ToolRegistryRecord {
  return {
    id: row.id,
    toolId: row.tool_id,           // snake_case → camelCase
    name: row.name,
    description: row.description,
    version: row.version,
    icon: row.icon,
    route: row.route,
    apiBase: row.api_base,         // snake_case → camelCase
    permissions: row.permissions,
    status: row.status,
    isExported: row.is_exported,   // snake_case → camelCase
    exportedAt: row.exported_at,   // snake_case → camelCase
    serviceUrl: row.service_url,   // snake_case → camelCase
    databaseName: row.database_name, // snake_case → camelCase
    manifestJson: row.manifest_json, // snake_case → camelCase
    createdAt: row.created_at,     // snake_case → camelCase
    updatedAt: row.updated_at,     // snake_case → camelCase
    createdBy: row.created_by,     // snake_case → camelCase
  };
}
```

### Documentation Standards

[Source: architecture/coding-standards.md#documentation-standards]

**JSDoc Example for Repository:**

```typescript
/**
 * Repository for tool registry data access.
 * Provides CRUD operations and specialized queries for tool discovery.
 *
 * @example
 * const repository = new ToolRegistryRepository(pool);
 * const tools = await repository.findAll();
 */
export class ToolRegistryRepository {
  /**
   * Finds a tool by its unique tool ID.
   *
   * @param toolId - The tool's unique identifier (e.g., "inventory-tracker")
   * @returns The tool record if found, null otherwise
   * @throws {Error} If database query fails
   *
   * @example
   * const tool = await repository.findById('inventory-tracker');
   * if (tool) {
   *   console.log(`Found tool: ${tool.name}`);
   * }
   */
  async findById(toolId: string): Promise<ToolRegistryRecord | null> {
    // Implementation
  }
}
```

### Testing

[Source: architecture/testing-strategy.md#backend-tests]

**Unit Test Organization:**

- Location: `apps/api/tests/unit/repositories/`
- Framework: Jest with TypeScript
- Mock database with `jest.fn()`

**Repository Test Pattern:**

```typescript
import { ToolRegistryRepository } from '../../../src/repositories/tool-registry.repository';
import { Pool } from 'pg';

describe('ToolRegistryRepository', () => {
  let repository: ToolRegistryRepository;
  let mockPool: jest.Mocked<Pool>;

  beforeEach(() => {
    // Create mock pool
    mockPool = {
      query: jest.fn(),
    } as any;

    repository = new ToolRegistryRepository(mockPool);
  });

  describe('findAll', () => {
    it('should return all tools ordered by created_at DESC', async () => {
      const mockRows = [
        { tool_id: 'tool-1', name: 'Tool 1' /* ... */ },
        { tool_id: 'tool-2', name: 'Tool 2' /* ... */ },
      ];
      mockPool.query.mockResolvedValue({ rows: mockRows } as any);

      const result = await repository.findAll();

      expect(result).toHaveLength(2);
      expect(result[0].toolId).toBe('tool-1');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('ORDER BY created_at DESC')
      );
    });
  });

  describe('findById', () => {
    it('should return tool if found', async () => {
      const mockRow = { tool_id: 'test-tool', name: 'Test Tool' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.findById('test-tool');

      expect(result).not.toBeNull();
      expect(result?.toolId).toBe('test-tool');
      expect(mockPool.query).toHaveBeenCalledWith(expect.stringContaining('WHERE tool_id = $1'), [
        'test-tool',
      ]);
    });

    it('should return null if not found', async () => {
      mockPool.query.mockResolvedValue({ rows: [] } as any);

      const result = await repository.findById('nonexistent');

      expect(result).toBeNull();
    });
  });

  describe('create', () => {
    it('should insert tool and return record', async () => {
      const input = {
        toolId: 'new-tool',
        name: 'New Tool',
        version: '1.0.0',
        route: '/tools/new-tool',
        apiBase: '/api/tools/new-tool',
        manifestJson: {
          /* ... */
        },
        createdBy: 'user-id',
      };

      const mockRow = { tool_id: 'new-tool' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.create(input);

      expect(result.toolId).toBe('new-tool');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('INSERT INTO tool_registry'),
        expect.arrayContaining(['new-tool', 'New Tool'])
      );
    });
  });
});
```

**Coverage Requirements:**

- Minimum 90% statement coverage
- Test both success and error paths
- Verify SQL query structure (parameterization, ORDER BY, WHERE clauses)
- Test edge cases (null, empty strings, special characters)

### Error Handling Pattern

```typescript
async findById(toolId: string): Promise<ToolRegistryRecord | null> {
  try {
    const query = 'SELECT * FROM tool_registry WHERE tool_id = $1';
    const result = await this.pool.query(query, [toolId]);

    if (result.rows.length === 0) {
      return null; // Not an error, just not found
    }

    return this.mapRowToRecord(result.rows[0]);
  } catch (error) {
    // Log error with context
    console.error('Error finding tool by ID:', { toolId, error });
    throw new Error(`Failed to find tool: ${error.message}`);
  }
}
```

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-10-23 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent_

### Debug Log References

_To be completed by dev agent_

### Completion Notes List

_To be completed by dev agent_

### File List

_To be completed by dev agent_

## QA Results

_To be completed by QA agent_
