# Story 11.2: Inline Label Editing & Settings Modal

## Status

Draft

## Story

**As a** form creator, **I want** to edit field labels inline and configure field properties via a
modal dialog, **so that** I can quickly update field labels without opening a sidebar and access
advanced settings when needed.

---

## Acceptance Criteria

1. ✅ Labels are editable inline with click/focus interaction (contenteditable or input overlay)
2. ✅ Label changes update immediately in FormBuilderService state
3. ✅ Settings modal opens on field click (designated area, not label)
4. ✅ All field properties configurable in modal (name, placeholder, help text, validation, default
   value, required toggle)
5. ✅ Changes in modal update field preview in real-time
6. ✅ Modal validation prevents empty required fields (e.g., label cannot be blank)
7. ✅ Keyboard shortcuts work (Escape to cancel label edit, Enter to save)

---

## Tasks / Subtasks

- [ ] **Task 1: Implement inline label editing component** (AC: 1, 2, 7)
  - [ ] Create `inline-label-editor.component.ts` in `form-canvas/field-preview-renderer/` directory
  - [ ] Implement contenteditable label with click-to-edit behavior
  - [ ] Add visual indicators for editable state (border highlight, cursor change)
  - [ ] Handle click event to enter edit mode, blur event to save changes
  - [ ] Implement keyboard handlers:
    - [ ] Enter key saves and exits edit mode
    - [ ] Escape key cancels and reverts to original label
    - [ ] Tab key saves and moves to next field
  - [ ] Validate label is not empty before saving (show error if blank)
  - [ ] Call `FormBuilderService.updateFieldProperty(fieldId, { label })` on save
  - [ ] Add ARIA attributes for accessibility (role="textbox", aria-label)

- [ ] **Task 2: Integrate inline label editor into field preview renderer** (AC: 1)
  - [ ] Update `field-preview-renderer.component.ts` to include inline label editor
  - [ ] Position label editor above form control preview (matching final form layout)
  - [ ] Pass `field.label` and `field.id` as inputs to inline label editor
  - [ ] Handle label update events from inline editor
  - [ ] Prevent label click from triggering field selection (stopPropagation)
  - [ ] Apply Tailwind CSS classes for label styling (font-medium, text-gray-900)

- [ ] **Task 3: Create field settings modal dialog component** (AC: 3, 4, 5, 6)
  - [ ] Create `field-settings-modal.component.ts` in `form-canvas/` directory
  - [ ] Use PrimeNG `p-dialog` component for modal UI
  - [ ] Implement reactive form with Angular FormGroup for settings
  - [ ] Add form controls for all field properties:
    - [ ] Label (text input, required)
    - [ ] Field Name (text input, required, slug format)
    - [ ] Placeholder (text input, optional)
    - [ ] Help Text (textarea, optional)
    - [ ] Required toggle (p-inputSwitch)
    - [ ] Default Value (text input, type-specific)
    - [ ] Validation rules (min/max length, min/max value, pattern, conditional)
  - [ ] Implement field type-specific configuration sections:
    - [ ] Text fields: min/max length, pattern validation
    - [ ] Number fields: min/max value
    - [ ] File fields: accepted file types, max file size
    - [ ] Select/Radio/Checkbox: options list (separate component, Story 11.3)
  - [ ] Add Save and Cancel buttons with proper validation
  - [ ] Validate required fields before allowing save (disable Save button if invalid)
  - [ ] Call `FormBuilderService.updateFieldProperties(fieldId, updates)` on save
  - [ ] Close modal on successful save or cancel

- [ ] **Task 4: Connect settings modal to field click events** (AC: 3)
  - [ ] Update `field-preview-renderer.component.ts` to emit settings click event
  - [ ] Add settings icon/button in field preview (gear icon, bottom-right corner)
  - [ ] Prevent settings button click from triggering drag-drop
  - [ ] Update `form-canvas.component.ts` to handle settings modal open
  - [ ] Pass selected field data to modal via @Input or service
  - [ ] Show modal when settings button clicked
  - [ ] Update FormBuilderService `selectedField` signal when opening modal

- [ ] **Task 5: Implement real-time field preview updates** (AC: 5)
  - [ ] Subscribe to FormBuilderService `formFields()` signal in field preview renderer
  - [ ] Update preview display when field properties change (label, placeholder, help text,
        required)
  - [ ] Apply validation indicators dynamically (required badge, validation hints)
  - [ ] Use `OnPush` change detection strategy to optimize re-renders

- [ ] **Task 6: Add modal validation and error handling** (AC: 6)
  - [ ] Implement form validators for required fields (label, fieldName)
  - [ ] Validate fieldName format (alphanumeric + underscores, no spaces)
  - [ ] Check for duplicate fieldName values across form (unique constraint)
  - [ ] Display inline validation errors in modal form controls
  - [ ] Prevent save if form is invalid (disable Save button)
  - [ ] Show error message toast if save fails

- [ ] **Task 7: Convert existing field-properties sidebar to modal pattern** (AC: 4)
  - [ ] Review existing `field-properties.component.ts` implementation
  - [ ] Extract reusable form control logic for modal reuse
  - [ ] Remove or hide right sidebar in form-canvas layout (optional for this story)
  - [ ] Migrate validation logic from sidebar to modal component

- [ ] **Task 8: Add unit tests for inline label editing and settings modal**
  - [ ] Test suite for `inline-label-editor.component.spec.ts`:
    - [ ] Click to enter edit mode
    - [ ] Enter key saves label
    - [ ] Escape key cancels edit
    - [ ] Blur saves label changes
    - [ ] Validation prevents empty labels
  - [ ] Test suite for `field-settings-modal.component.spec.ts`:
    - [ ] Modal opens with field data pre-filled
    - [ ] Form validation prevents invalid saves
    - [ ] Save updates FormBuilderService state
    - [ ] Cancel closes modal without changes
    - [ ] Real-time preview updates on property changes
  - [ ] Update `field-preview-renderer.component.spec.ts` to test inline label integration

---

## Dev Notes

### Integration with Existing System

**Component Location:** `apps/web/src/app/features/tools/components/form-builder/form-canvas/`
[Source: architecture/unified-project-structure.md#frontend]

This story builds on Story 11.1 (Live Field Preview Rendering) by adding inline editing capabilities
to the field previews. The existing `field-properties.component.ts` sidebar will be replaced or
supplemented with a modal-based approach for a more streamlined WYSIWYG editing experience.

**Key Integration Points:**

- **FormBuilderService**
  ([form-builder.service.ts:1-150](apps/web/src/app/features/tools/components/form-builder/form-builder.service.ts#L1-L150)):
  - `updateField(index, field)`: Update entire field object at index
  - `updateFieldProperty(fieldId, property, value)`: Update single field property (may need to be
    added)
  - `updateFieldProperties(fieldId, updates)`: Update multiple field properties (may need to be
    added)
  - `selectedField()` signal: Currently selected field for editing
  - `selectField(field)`: Set selected field

**Note:** If `updateFieldProperty` and `updateFieldProperties` methods don't exist in
FormBuilderService, they must be added following the existing pattern:

```typescript
updateFieldProperty(fieldId: string, property: keyof FormField, value: any): void {
  this._formFields.update((fields) => {
    const index = fields.findIndex(f => f.id === fieldId);
    if (index === -1) return fields;
    const updated = [...fields];
    updated[index] = { ...updated[index], [property]: value };
    return updated;
  });
  this.markDirty();
}

updateFieldProperties(fieldId: string, updates: Partial<FormField>): void {
  this._formFields.update((fields) => {
    const index = fields.findIndex(f => f.id === fieldId);
    if (index === -1) return fields;
    const updated = [...fields];
    updated[index] = { ...updated[index], ...updates };
    return updated;
  });
  this.markDirty();
}
```

- **FieldPreviewRendererComponent** (Created in Story 11.1):
  - Currently renders disabled field previews
  - Will be extended to include inline label editor above each field
  - Will emit settings button click events to parent component

- **Existing field-properties.component.ts**:
  - Current right sidebar implementation
  - Contains form control logic for field configuration
  - May be migrated to modal or kept as alternative UI (decision to be made)

### Data Models

**FormField Interface**
([packages/shared/src/types/forms.types.ts:83-100](packages/shared/src/types/forms.types.ts#L83-L100)):
All properties that must be editable in the settings modal:

```typescript
interface FormField {
  id: string; // Read-only (auto-generated)
  type: FormFieldType; // Read-only (cannot change type after creation)
  label: string; // EDITABLE inline and in modal
  fieldName: string; // EDITABLE in modal (slug format, unique)
  placeholder?: string; // EDITABLE in modal
  helpText?: string; // EDITABLE in modal
  required: boolean; // EDITABLE in modal (toggle)
  validation?: FormFieldValidation; // EDITABLE in modal (complex object)
  defaultValue?: any; // EDITABLE in modal (type-specific)
  options?: FormFieldOption[]; // EDITABLE in Story 11.3 (inline option manager)
  conditional?: FormFieldConditional; // EDITABLE in modal (advanced)
}
```

[Source: architecture/data-models.md + packages/shared/src/types/forms.types.ts]

**FormFieldValidation Interface**
([packages/shared/src/types/forms.types.ts:38-56](packages/shared/src/types/forms.types.ts#L38-L56)):

```typescript
interface FormFieldValidation {
  minLength?: number; // For text inputs
  maxLength?: number; // For text inputs
  min?: number; // For numeric inputs
  max?: number; // For numeric inputs
  pattern?: string; // Regular expression for validation
  errorMessage?: string; // Custom error message
  acceptedFileTypes?: string[]; // For file uploads
  maxFileSize?: number; // For file uploads (bytes)
}
```

All validation properties are optional and field-type specific.

### PrimeNG Components for Modal UI

[Source: architecture/tech-stack.md#ui-component-library]

- **Modal Dialog:**
  `<p-dialog [(visible)]="displayModal" header="Field Settings" [modal]="true" [style]="{width: '50vw'}">`
- **Form Controls:**
  - Text inputs: `<input pInputText [(ngModel)]="field.label">`
  - Textarea: `<textarea pInputTextarea [(ngModel)]="field.helpText">`
  - Toggle switch: `<p-inputSwitch [(ngModel)]="field.required">`
  - Number inputs: `<p-inputNumber [(ngModel)]="validation.minLength">`
  - Dropdown: `<p-dropdown [options]="validationOptions" [(ngModel)]="selectedValidation">`
- **Buttons:** `<p-button label="Save" (onClick)="onSave()">`,
  `<p-button label="Cancel" (onClick)="onCancel()">`
- **Validation Messages:**
  `<small class="p-error" *ngIf="labelControl.invalid">Label is required</small>`

### Inline Label Editor Implementation

**ContentEditable Approach:**

```typescript
@Component({
  selector: 'app-inline-label-editor',
  standalone: true,
  imports: [CommonModule, FormsModule],
  template: `
    <div class="inline-label-editor" [class.editing]="isEditing" (click)="enterEditMode()">
      @if (isEditing) {
        <input
          #labelInput
          type="text"
          [(ngModel)]="editedLabel"
          (blur)="saveLabel()"
          (keydown.enter)="saveLabel(); $event.preventDefault()"
          (keydown.escape)="cancelEdit(); $event.preventDefault()"
          (click)="$event.stopPropagation()"
          class="inline-label-input"
          [attr.aria-label]="'Edit label for ' + originalLabel"
        />
      } @else {
        <label class="field-label">
          {{ label }}
          <i class="pi pi-pencil text-xs ml-2 text-gray-400"></i>
        </label>
      }
    </div>
  `,
  styles: [
    `
      .inline-label-editor {
        cursor: pointer;
        display: inline-block;
      }
      .inline-label-editor.editing {
        cursor: text;
      }
      .inline-label-input {
        border: 2px solid #3b82f6;
        outline: none;
        padding: 0.25rem;
        font-weight: 500;
      }
      .field-label:hover .pi-pencil {
        color: #3b82f6;
      }
    `,
  ],
})
export class InlineLabelEditorComponent {
  @Input({ required: true }) label!: string;
  @Input({ required: true }) fieldId!: string;
  @Output() labelChanged = new EventEmitter<string>();
  @ViewChild('labelInput') labelInput?: ElementRef<HTMLInputElement>;

  isEditing = false;
  editedLabel = '';
  originalLabel = '';

  enterEditMode(): void {
    this.isEditing = true;
    this.editedLabel = this.label;
    this.originalLabel = this.label;
    // Focus input after view update
    setTimeout(() => this.labelInput?.nativeElement.focus(), 0);
  }

  saveLabel(): void {
    if (!this.editedLabel.trim()) {
      // Validation: label cannot be empty
      alert('Label cannot be empty');
      return;
    }
    this.labelChanged.emit(this.editedLabel);
    this.isEditing = false;
  }

  cancelEdit(): void {
    this.editedLabel = this.originalLabel;
    this.isEditing = false;
  }
}
```

**Alternative Approach (contenteditable div):** Use native `contenteditable="true"` on a div instead
of input. Requires additional handling for paste events and HTML sanitization.

### Settings Modal Component Structure

**Component Architecture:**

```typescript
@Component({
  selector: 'app-field-settings-modal',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    DialogModule,
    InputTextModule,
    InputTextareaModule,
    InputSwitchModule,
    ButtonModule,
  ],
  template: `
    <p-dialog
      [(visible)]="displayModal"
      header="Field Settings"
      [modal]="true"
      [style]="{ width: '50vw' }"
      (onHide)="onCancel()"
    >
      <form [formGroup]="settingsForm" (ngSubmit)="onSave()">
        <!-- Label -->
        <div class="field mb-4">
          <label for="label" class="block font-medium mb-2">Label *</label>
          <input id="label" type="text" pInputText formControlName="label" class="w-full" />
          <small class="p-error" *ngIf="labelControl.invalid && labelControl.touched">
            Label is required
          </small>
        </div>

        <!-- Field Name -->
        <div class="field mb-4">
          <label for="fieldName" class="block font-medium mb-2">Field Name *</label>
          <input id="fieldName" type="text" pInputText formControlName="fieldName" class="w-full" />
          <small class="text-gray-500"
            >Used as key in form submission (alphanumeric, underscores)</small
          >
          <small class="p-error" *ngIf="fieldNameControl.invalid && fieldNameControl.touched">
            Field name is required and must be unique
          </small>
        </div>

        <!-- Placeholder -->
        <div class="field mb-4">
          <label for="placeholder" class="block font-medium mb-2">Placeholder</label>
          <input
            id="placeholder"
            type="text"
            pInputText
            formControlName="placeholder"
            class="w-full"
          />
        </div>

        <!-- Help Text -->
        <div class="field mb-4">
          <label for="helpText" class="block font-medium mb-2">Help Text</label>
          <textarea
            id="helpText"
            pInputTextarea
            formControlName="helpText"
            rows="3"
            class="w-full"
          ></textarea>
        </div>

        <!-- Required Toggle -->
        <div class="field mb-4 flex items-center">
          <p-inputSwitch formControlName="required" inputId="required" />
          <label for="required" class="ml-3">Required field</label>
        </div>

        <!-- Default Value -->
        <div class="field mb-4">
          <label for="defaultValue" class="block font-medium mb-2">Default Value</label>
          <input
            id="defaultValue"
            type="text"
            pInputText
            formControlName="defaultValue"
            class="w-full"
          />
        </div>

        <!-- Validation Rules (Field type specific) -->
        @if (showTextValidation()) {
          <div class="field mb-4">
            <label class="block font-medium mb-2">Text Validation</label>
            <div class="grid grid-cols-2 gap-4">
              <div>
                <label for="minLength" class="block text-sm mb-1">Min Length</label>
                <p-inputNumber id="minLength" formControlName="minLength" [min]="0" />
              </div>
              <div>
                <label for="maxLength" class="block text-sm mb-1">Max Length</label>
                <p-inputNumber id="maxLength" formControlName="maxLength" [min]="0" />
              </div>
            </div>
          </div>
        }

        @if (showNumberValidation()) {
          <div class="field mb-4">
            <label class="block font-medium mb-2">Number Validation</label>
            <div class="grid grid-cols-2 gap-4">
              <div>
                <label for="min" class="block text-sm mb-1">Min Value</label>
                <p-inputNumber id="min" formControlName="min" />
              </div>
              <div>
                <label for="max" class="block text-sm mb-1">Max Value</label>
                <p-inputNumber id="max" formControlName="max" />
              </div>
            </div>
          </div>
        }

        <!-- Pattern Validation -->
        @if (showPatternValidation()) {
          <div class="field mb-4">
            <label for="pattern" class="block font-medium mb-2">Validation Pattern (RegEx)</label>
            <input
              id="pattern"
              type="text"
              pInputText
              formControlName="pattern"
              class="w-full"
              placeholder="^[a-zA-Z]+$"
            />
            <small class="text-gray-500">Regular expression for custom validation</small>
          </div>
        }

        <!-- Custom Error Message -->
        <div class="field mb-4">
          <label for="errorMessage" class="block font-medium mb-2">Custom Error Message</label>
          <input
            id="errorMessage"
            type="text"
            pInputText
            formControlName="errorMessage"
            class="w-full"
          />
        </div>

        <!-- Footer Buttons -->
        <div class="flex justify-end gap-2 mt-6">
          <p-button label="Cancel" severity="secondary" (onClick)="onCancel()" />
          <p-button label="Save" type="submit" [disabled]="settingsForm.invalid" />
        </div>
      </form>
    </p-dialog>
  `,
})
export class FieldSettingsModalComponent {
  @Input() field: FormField | null = null;
  @Input() displayModal = false;
  @Output() displayModalChange = new EventEmitter<boolean>();
  @Output() settingsSaved = new EventEmitter<Partial<FormField>>();

  private readonly fb = inject(FormBuilder);
  settingsForm!: FormGroup;

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['field'] && this.field) {
      this.buildForm();
    }
  }

  buildForm(): void {
    this.settingsForm = this.fb.group({
      label: [this.field?.label || '', Validators.required],
      fieldName: [
        this.field?.fieldName || '',
        [Validators.required, Validators.pattern(/^[a-zA-Z0-9_]+$/)],
      ],
      placeholder: [this.field?.placeholder || ''],
      helpText: [this.field?.helpText || ''],
      required: [this.field?.required || false],
      defaultValue: [this.field?.defaultValue || ''],
      minLength: [this.field?.validation?.minLength || null],
      maxLength: [this.field?.validation?.maxLength || null],
      min: [this.field?.validation?.min || null],
      max: [this.field?.validation?.max || null],
      pattern: [this.field?.validation?.pattern || ''],
      errorMessage: [this.field?.validation?.errorMessage || ''],
    });
  }

  onSave(): void {
    if (this.settingsForm.invalid) return;

    const formValue = this.settingsForm.value;
    const updates: Partial<FormField> = {
      label: formValue.label,
      fieldName: formValue.fieldName,
      placeholder: formValue.placeholder,
      helpText: formValue.helpText,
      required: formValue.required,
      defaultValue: formValue.defaultValue,
      validation: {
        minLength: formValue.minLength,
        maxLength: formValue.maxLength,
        min: formValue.min,
        max: formValue.max,
        pattern: formValue.pattern,
        errorMessage: formValue.errorMessage,
      },
    };

    this.settingsSaved.emit(updates);
    this.closeModal();
  }

  onCancel(): void {
    this.closeModal();
  }

  closeModal(): void {
    this.displayModal = false;
    this.displayModalChange.emit(false);
  }

  showTextValidation(): boolean {
    return [FormFieldType.TEXT, FormFieldType.EMAIL, FormFieldType.TEXTAREA].includes(
      this.field?.type!
    );
  }

  showNumberValidation(): boolean {
    return this.field?.type === FormFieldType.NUMBER;
  }

  showPatternValidation(): boolean {
    return [FormFieldType.TEXT, FormFieldType.EMAIL].includes(this.field?.type!);
  }

  get labelControl() {
    return this.settingsForm.get('label')!;
  }
  get fieldNameControl() {
    return this.settingsForm.get('fieldName')!;
  }
}
```

### Event Propagation Handling

**Critical for Drag-Drop + Inline Editing:**

Settings button and label editor clicks must not trigger:

1. Field selection
2. Drag-drop start event

Use `event.stopPropagation()` to prevent event bubbling:

```html
<!-- Label editor -->
<app-inline-label-editor
  [label]="field.label"
  [fieldId]="field.id"
  (click)="$event.stopPropagation()"
  (labelChanged)="onLabelChanged($event)"
/>

<!-- Settings button -->
<button (click)="openSettings($event); $event.stopPropagation()" class="settings-button">
  <i class="pi pi-cog"></i>
</button>
```

### Keyboard Shortcuts

[Source: architecture/frontend-architecture.md#component-architecture]

- **Enter key:** Save inline label edit, submit modal form (if focused on Save button)
- **Escape key:** Cancel inline label edit, close modal without saving
- **Tab key:** Save inline label and move focus to next field (natural tab order)

Implement using `(keydown.enter)`, `(keydown.escape)`, `(keydown.tab)` Angular event bindings.

### Real-Time Preview Updates

**Signal Reactivity:** FormBuilderService uses signals, so field previews will automatically update
when field properties change. No manual subscription needed if using signals in template:

```typescript
// In field-preview-renderer.component.ts
@Input({ required: true }) field!: FormField;

// Template automatically updates when field changes
<p-inputText [placeholder]="field.placeholder" [disabled]="true" />
```

**Optimization:** Use `ChangeDetectionStrategy.OnPush` to prevent unnecessary re-renders. Angular
signals work seamlessly with OnPush.

### Testing

**Test Location:**

- `apps/web/src/app/features/tools/components/form-builder/form-canvas/inline-label-editor.component.spec.ts`
- `apps/web/src/app/features/tools/components/form-builder/form-canvas/field-settings-modal.component.spec.ts`

[Source: architecture/testing-strategy.md#frontend-tests]

**Test Framework:** Jest + Angular Testing Library [Source:
architecture/tech-stack.md#frontend-testing]

**Test Coverage Requirements:**

```typescript
describe('InlineLabelEditorComponent', () => {
  it('should enter edit mode on click', () => {
    fixture.nativeElement.querySelector('.inline-label-editor').click();
    expect(component.isEditing).toBe(true);
  });

  it('should save label on Enter key', () => {
    component.enterEditMode();
    const input = fixture.nativeElement.querySelector('input');
    input.value = 'New Label';
    input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter' }));
    expect(component.isEditing).toBe(false);
    expect(component.labelChanged.emit).toHaveBeenCalledWith('New Label');
  });

  it('should cancel edit on Escape key', () => {
    component.enterEditMode();
    component.editedLabel = 'Changed';
    const input = fixture.nativeElement.querySelector('input');
    input.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }));
    expect(component.isEditing).toBe(false);
    expect(component.editedLabel).toBe(component.originalLabel);
  });

  it('should prevent saving empty label', () => {
    component.enterEditMode();
    component.editedLabel = '';
    spyOn(window, 'alert');
    component.saveLabel();
    expect(window.alert).toHaveBeenCalled();
    expect(component.isEditing).toBe(true);
  });
});

describe('FieldSettingsModalComponent', () => {
  it('should pre-fill form with field data', () => {
    const field: FormField = { label: 'Test', fieldName: 'test', ... };
    component.field = field;
    component.ngOnChanges({ field: new SimpleChange(null, field, true) });
    expect(component.settingsForm.value.label).toBe('Test');
  });

  it('should disable Save button when form is invalid', () => {
    component.settingsForm.patchValue({ label: '' }); // Invalid
    fixture.detectChanges();
    const saveButton = fixture.nativeElement.querySelector('p-button[label="Save"]');
    expect(saveButton.disabled).toBe(true);
  });

  it('should emit settingsSaved event on save', () => {
    spyOn(component.settingsSaved, 'emit');
    component.settingsForm.patchValue({ label: 'Updated', fieldName: 'updated' });
    component.onSave();
    expect(component.settingsSaved.emit).toHaveBeenCalled();
  });

  it('should validate fieldName format', () => {
    component.settingsForm.patchValue({ fieldName: 'invalid name' }); // Spaces not allowed
    expect(component.fieldNameControl.invalid).toBe(true);
    component.settingsForm.patchValue({ fieldName: 'valid_name' });
    expect(component.fieldNameControl.valid).toBe(true);
  });
});
```

**Test Commands:**

```bash
# Run tests for inline label editor
npm --workspace=apps/web run test -- --include="**/inline-label-editor.component.spec.ts" --watch=false

# Run tests for settings modal
npm --workspace=apps/web run test -- --include="**/field-settings-modal.component.spec.ts" --watch=false
```

### Accessibility Requirements

[Source: architecture/frontend-architecture.md#component-template]

- **Inline Label Editor:**
  - Add `role="textbox"` to editable label
  - Add `aria-label="Edit label for {original label}"`
  - Announce edit mode changes to screen readers
  - Ensure keyboard navigation works (Tab, Enter, Escape)

- **Settings Modal:**
  - Modal header must be properly announced (`header="Field Settings"`)
  - All form controls must have associated labels (using `for` attribute)
  - Validation errors must be linked to inputs (`aria-describedby`)
  - Focus management: modal traps focus, returns focus on close
  - Escape key closes modal (PrimeNG Dialog default behavior)

### Backward Compatibility

**No Breaking Changes:**

1. FormBuilderService API extended (new methods added, existing methods unchanged)
2. `FormField` interface unchanged
3. Existing field-properties sidebar can remain (hide via CSS or feature flag)
4. Form save/load operations unaffected

**Migration Path for field-properties.component.ts:**

- Option A: Keep sidebar, add modal as alternative UI (use feature flag)
- Option B: Deprecate sidebar, migrate all users to modal
- Option C: Hybrid approach - sidebar for quick edits, modal for advanced settings

Recommendation: **Option B (migrate to modal)** for cleaner WYSIWYG experience aligned with Epic 11
goals.

---

## Change Log

| Date       | Version | Description                | Author             |
| ---------- | ------- | -------------------------- | ------------------ |
| 2025-10-07 | 1.0     | Story created from Epic 11 | Scrum Master (Bob) |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes

_To be filled by dev agent_

### File List

_To be filled by dev agent_

---

## QA Results

_This section will be populated by the QA agent after story completion._
