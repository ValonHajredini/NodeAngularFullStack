# Story 30.1.4: Repository Unit Tests

## Status

Draft

## Story

**As a** backend developer, **I want** comprehensive tests for the repository layer, **so that**
data access is reliable and maintainable.

## Acceptance Criteria

1. ✅ Unit tests for all repository methods
2. ✅ Test coverage ≥90%
3. ✅ Mock database queries (no real DB in unit tests)
4. ✅ Edge case testing (nulls, empty arrays, etc.)
5. ✅ All tests pass

## Tasks / Subtasks

- [ ] **Task 1: Setup test infrastructure** (AC: 3)
  - [ ] Verify Jest configuration exists: `apps/api/jest.config.js`
  - [ ] Create test file: `apps/api/tests/unit/repositories/tool-registry.repository.test.ts`
  - [ ] Import ToolRegistryRepository and types from shared package
  - [ ] Create mock Pool with `jest.fn()` for all methods
  - [ ] Setup beforeEach to initialize fresh repository instance with mock pool

- [ ] **Task 2: Write tests for CRUD methods** (AC: 1, 3)
  - [ ] Test `findAll()`:
    - [ ] Should return all tools ordered by created_at DESC
    - [ ] Should return empty array when no tools exist
    - [ ] Should call pool.query with correct SQL
  - [ ] Test `findById()`:
    - [ ] Should return tool when found
    - [ ] Should return null when not found
    - [ ] Should use parameterized query ($1)
  - [ ] Test `create()`:
    - [ ] Should insert tool and return record
    - [ ] Should call pool.query with INSERT statement
    - [ ] Should pass parameters in correct order
  - [ ] Test `update()`:
    - [ ] Should update tool and return updated record
    - [ ] Should build dynamic SET clause for provided fields only
    - [ ] Should throw error when tool not found
  - [ ] Test `delete()`:
    - [ ] Should delete tool successfully
    - [ ] Should call pool.query with DELETE statement

- [ ] **Task 3: Write tests for query methods** (AC: 1, 3)
  - [ ] Test `findByStatus()`:
    - [ ] Should filter by status
    - [ ] Should order by name ASC
    - [ ] Should return empty array for non-existent status
  - [ ] Test `findExported()`:
    - [ ] Should return only tools where is_exported = true
  - [ ] Test `search()`:
    - [ ] Should search name and description with ILIKE
    - [ ] Should add wildcard placeholders (%term%)
    - [ ] Should return empty array when no matches

- [ ] **Task 4: Write edge case and error tests** (AC: 4)
  - [ ] Test null handling:
    - [ ] Create tool with optional fields as null
    - [ ] Update tool with null values
    - [ ] Search with empty string
  - [ ] Test empty arrays:
    - [ ] Create tool with empty permissions array
    - [ ] Update tool with empty permissions
  - [ ] Test SQL injection attempts (verify parameterization):
    - [ ] Search with SQL injection payload (e.g., "'; DROP TABLE users; --")
    - [ ] Verify payload treated as literal string, not executed
  - [ ] Test database errors:
    - [ ] Mock pool.query to throw error
    - [ ] Verify repository catches and re-throws with context

- [ ] **Task 5: Write tests for row mapping** (AC: 1, 3)
  - [ ] Test `mapRowToRecord()` (if public or via spy):
    - [ ] Verify snake_case → camelCase conversion
    - [ ] Verify all fields mapped correctly
    - [ ] Verify JSONB parsed correctly

- [ ] **Task 6: Run coverage report and ensure ≥90%** (AC: 2, 5)
  - [ ] Run: `npm --workspace=apps/api run test:coverage`
  - [ ] Verify tool-registry.repository.ts has ≥90% coverage
  - [ ] Add missing tests for any uncovered branches
  - [ ] Verify all tests pass: `npm --workspace=apps/api run test:unit`

- [ ] **Task 7: Add test documentation** (AC: 1-5)
  - [ ] Add describe/it blocks with clear test names
  - [ ] Group related tests with nested describe blocks
  - [ ] Add comments explaining complex test setups
  - [ ] Document any test assumptions or constraints

## Dev Notes

### Testing Strategy Overview

[Source: architecture/testing-strategy.md#backend-tests]

**Testing Pyramid:**

- Unit Tests (this story): Test repository logic in isolation with mocked database
- Integration Tests (Epic 30.2): Test full API flow with real database

**Test Organization:**

```
apps/api/tests/
├── unit/
│   ├── repositories/
│   │   └── tool-registry.repository.test.ts   # <-- This story
│   ├── services/                              # Epic 30.2
│   └── utils/
└── integration/
    └── tool-registry-api.test.ts              # Epic 30.2
```

### Jest Configuration

[Source: architecture/tech-stack.md]

The project uses Jest 29+ with TypeScript support. Configuration exists at
`apps/api/jest.config.js`:

```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.test.ts'],
  collectCoverageFrom: ['src/**/*.ts'],
  coverageThreshold: {
    global: {
      statements: 90,
      branches: 90,
      functions: 90,
      lines: 90,
    },
  },
};
```

### Mocking Pattern

[Source: architecture/testing-strategy.md#backend-api-test]

**Mock pg.Pool with Jest:**

```typescript
import { Pool } from 'pg';
import { ToolRegistryRepository } from '../../../src/repositories/tool-registry.repository';

describe('ToolRegistryRepository', () => {
  let repository: ToolRegistryRepository;
  let mockPool: jest.Mocked<Pool>;

  beforeEach(() => {
    // Create mock pool with query method
    mockPool = {
      query: jest.fn(),
    } as any;

    // Create repository with mocked pool
    repository = new ToolRegistryRepository(mockPool);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // Tests go here
});
```

### Test Structure Pattern

**Arrange-Act-Assert Pattern:**

```typescript
describe('findAll', () => {
  it('should return all tools ordered by created_at DESC', async () => {
    // ARRANGE - Setup mock data
    const mockRows = [
      {
        tool_id: 'tool-1',
        name: 'Tool 1',
        description: 'First tool',
        version: '1.0.0',
        route: '/tools/tool-1',
        api_base: '/api/tools/tool-1',
        permissions: ['read'],
        status: 'active',
        is_exported: false,
        exported_at: null,
        service_url: null,
        database_name: null,
        manifest_json: {},
        created_at: new Date('2025-01-01'),
        updated_at: new Date('2025-01-01'),
        created_by: 'user-123',
      },
      // ... more mock rows
    ];

    mockPool.query.mockResolvedValue({ rows: mockRows } as any);

    // ACT - Call the method
    const result = await repository.findAll();

    // ASSERT - Verify results
    expect(result).toHaveLength(2);
    expect(result[0].toolId).toBe('tool-1'); // Verify snake_case → camelCase
    expect(mockPool.query).toHaveBeenCalledWith(
      expect.stringContaining('ORDER BY created_at DESC')
    );
  });
});
```

### Testing Query Parameterization (SQL Injection Prevention)

**Critical Test for Security:**

```typescript
describe('findById', () => {
  it('should use parameterized query to prevent SQL injection', async () => {
    const maliciousInput = "'; DROP TABLE users; --";
    mockPool.query.mockResolvedValue({ rows: [] } as any);

    await repository.findById(maliciousInput);

    // Verify query uses $1 placeholder, not string interpolation
    expect(mockPool.query).toHaveBeenCalledWith(
      expect.stringContaining('WHERE tool_id = $1'),
      [maliciousInput] // Malicious input passed as parameter, not concatenated
    );

    // Verify malicious input treated as literal string
    expect(mockPool.query).not.toHaveBeenCalledWith(expect.stringContaining(maliciousInput));
  });
});
```

### Testing Edge Cases

**Null and Empty Values:**

```typescript
describe('create', () => {
  it('should handle optional fields as null', async () => {
    const input = {
      toolId: 'minimal-tool',
      name: 'Minimal Tool',
      version: '1.0.0',
      route: '/tools/minimal',
      apiBase: '/api/tools/minimal',
      description: null, // Optional field
      icon: null, // Optional field
      permissions: [], // Empty array
      manifestJson: {},
      createdBy: 'user-123',
    };

    const mockRow = { tool_id: 'minimal-tool' /* ... */ };
    mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

    const result = await repository.create(input);

    expect(result.toolId).toBe('minimal-tool');
    // Verify null values passed correctly
    expect(mockPool.query).toHaveBeenCalledWith(
      expect.any(String),
      expect.arrayContaining([null, null, []])
    );
  });
});
```

**Database Errors:**

```typescript
describe('Error Handling', () => {
  it('should throw descriptive error when database query fails', async () => {
    mockPool.query.mockRejectedValue(new Error('Connection lost'));

    await expect(repository.findAll()).rejects.toThrow('Failed to');
  });
});
```

### Testing Update Method with Dynamic Fields

**Complex Test Case:**

```typescript
describe('update', () => {
  it('should build dynamic SET clause for provided fields only', async () => {
    const updates = {
      name: 'Updated Name',
      status: 'deprecated',
      // Other fields omitted - should not be in SET clause
    };

    const mockRow = {
      tool_id: 'test-tool',
      name: 'Updated Name',
      status: 'deprecated',
      /* ... */
    };
    mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

    await repository.update('test-tool', updates);

    expect(mockPool.query).toHaveBeenCalledWith(
      expect.stringMatching(/SET.*name = \$1.*status = \$2.*updated_at.*WHERE tool_id = \$3/),
      ['Updated Name', 'deprecated', 'test-tool']
    );
  });

  it('should throw error when tool not found', async () => {
    mockPool.query.mockResolvedValue({ rows: [] } as any); // Empty result

    await expect(repository.update('nonexistent', { name: 'New Name' })).rejects.toThrow(
      "Tool 'nonexistent' not found"
    );
  });
});
```

### Coverage Requirements

[Source: architecture/testing-strategy.md]

**Minimum Coverage Thresholds:**

- Statements: 90%
- Branches: 90%
- Functions: 90%
- Lines: 90%

**Running Coverage:**

```bash
# Run tests with coverage report
npm --workspace=apps/api run test:coverage

# Output shows coverage per file:
# tool-registry.repository.ts | 92.5% | 95% | 100% | 91%
```

**If Coverage < 90%:**

- Identify uncovered lines in coverage report (HTML report in `coverage/` folder)
- Add tests for missing branches (e.g., error paths, edge cases)
- Verify all public methods have at least one test

### Complete Test File Example from PRD

```typescript
// tests/unit/repositories/tool-registry.repository.test.ts
import { ToolRegistryRepository } from '../../../src/repositories/tool-registry.repository';
import { Pool } from 'pg';

describe('ToolRegistryRepository', () => {
  let repository: ToolRegistryRepository;
  let mockPool: jest.Mocked<Pool>;

  beforeEach(() => {
    mockPool = {
      query: jest.fn(),
    } as any;
    repository = new ToolRegistryRepository(mockPool);
  });

  describe('findAll', () => {
    it('should return all tools ordered by created_at DESC', async () => {
      const mockRows = [
        { tool_id: 'tool-1', name: 'Tool 1' /* ... */ },
        { tool_id: 'tool-2', name: 'Tool 2' /* ... */ },
      ];
      mockPool.query.mockResolvedValue({ rows: mockRows } as any);

      const result = await repository.findAll();

      expect(result).toHaveLength(2);
      expect(result[0].toolId).toBe('tool-1');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('ORDER BY created_at DESC')
      );
    });
  });

  describe('findById', () => {
    it('should return tool if found', async () => {
      const mockRow = { tool_id: 'test-tool', name: 'Test Tool' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.findById('test-tool');

      expect(result).not.toBeNull();
      expect(result?.toolId).toBe('test-tool');
    });

    it('should return null if not found', async () => {
      mockPool.query.mockResolvedValue({ rows: [] } as any);

      const result = await repository.findById('nonexistent');

      expect(result).toBeNull();
    });
  });

  describe('create', () => {
    it('should insert tool and return record', async () => {
      const input = {
        toolId: 'new-tool',
        name: 'New Tool',
        version: '1.0.0',
        route: '/tools/new-tool',
        apiBase: '/api/tools/new-tool',
        manifestJson: {
          /* ... */
        },
        createdBy: 'user-id',
      };

      const mockRow = { tool_id: 'new-tool' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.create(input);

      expect(result.toolId).toBe('new-tool');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('INSERT INTO tool_registry'),
        expect.arrayContaining(['new-tool', 'New Tool'])
      );
    });
  });

  describe('update', () => {
    it('should update tool and return updated record', async () => {
      const mockRow = { tool_id: 'test-tool', name: 'Updated Name' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.update('test-tool', { name: 'Updated Name' });

      expect(result.name).toBe('Updated Name');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('UPDATE tool_registry'),
        expect.any(Array)
      );
    });

    it('should throw error if tool not found', async () => {
      mockPool.query.mockResolvedValue({ rows: [] } as any);

      await expect(repository.update('nonexistent', { name: 'New Name' })).rejects.toThrow(
        "Tool 'nonexistent' not found"
      );
    });
  });

  describe('search', () => {
    it('should search by name and description', async () => {
      const mockRows = [{ tool_id: 'tool-1', name: 'Inventory Tool' /* ... */ }];
      mockPool.query.mockResolvedValue({ rows: mockRows } as any);

      const result = await repository.search('inventory');

      expect(result).toHaveLength(1);
      expect(mockPool.query).toHaveBeenCalledWith(expect.stringContaining('ILIKE'), [
        '%inventory%',
      ]);
    });
  });
});
```

### Test Commands

[Source: CLAUDE.md#testing-commands]

```bash
# Run all unit tests
npm --workspace=apps/api run test:unit

# Run specific test file
npm --workspace=apps/api run test -- --testPathPattern="tool-registry.repository.test.ts"

# Run with coverage
npm --workspace=apps/api run test:coverage

# Run in watch mode
npm --workspace=apps/api run test -- --watch

# Run silently (suppress console logs)
npm --workspace=apps/api run test -- --silent
```

### Dependencies on Previous Stories

**Story 30.1.2 Must Be Complete:**

- Repository implementation must exist before writing tests
- All methods (findAll, findById, create, update, delete, findByStatus, search) must be implemented

**Story 30.1.1 Must Be Complete:**

- Shared types (ToolRegistryRecord, CreateToolInput, UpdateToolInput) must exist
- Run `npm run build:shared` before testing if types were just created

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-10-23 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be completed by dev agent_

### Debug Log References

_To be completed by dev agent_

### Completion Notes List

_To be completed by dev agent_

### File List

_To be completed by dev agent_

## QA Results

_To be completed by QA agent_
