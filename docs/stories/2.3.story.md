# Story 2.3: CRUD API Endpoints

## Status
Draft

## Story
**As a** developer,
**I want** complete CRUD operations for user management,
**so that** I can understand how to implement similar patterns for business entities.

## Acceptance Criteria
1. REST endpoints for creating, reading, updating, and deleting users with proper HTTP methods
2. Request validation and sanitization prevent SQL injection and malformed data
3. Proper HTTP status codes and error messages for all success and failure scenarios
4. Pagination support for list endpoints with configurable page sizes
5. Audit logging tracks user modifications for security and debugging purposes

## Tasks / Subtasks
- [ ] Task 1: Implement comprehensive user CRUD endpoints (AC: 1)
  - [ ] POST /users - Create new user (admin only)
  - [ ] GET /users/:id - Get user by ID with role-based access
  - [ ] PUT /users/:id - Update user (full replacement)
  - [ ] PATCH /users/:id - Partial user update
  - [ ] DELETE /users/:id - Soft delete user (admin only)
  - [ ] Add proper HTTP method handling and route organization
- [ ] Task 2: Implement comprehensive request validation (AC: 2)
  - [ ] Input sanitization for all user fields
  - [ ] Email format and uniqueness validation
  - [ ] Password strength requirements for user creation
  - [ ] Role validation against allowed values
  - [ ] SQL injection prevention through parameterized queries
  - [ ] XSS protection through input encoding
- [ ] Task 3: Add proper HTTP status codes and error handling (AC: 3)
  - [ ] 200 OK for successful GET/PUT/PATCH operations
  - [ ] 201 Created for successful POST operations
  - [ ] 204 No Content for successful DELETE operations
  - [ ] 400 Bad Request for validation errors with detailed messages
  - [ ] 401 Unauthorized for authentication failures
  - [ ] 403 Forbidden for authorization failures
  - [ ] 404 Not Found for non-existent resources
  - [ ] 409 Conflict for duplicate email addresses
- [ ] Task 4: Implement pagination for user list endpoints (AC: 4)
  - [ ] Add page and limit query parameters to GET /users
  - [ ] Default pagination limits (20 items per page)
  - [ ] Total count and pagination metadata in response
  - [ ] Efficient database queries with OFFSET and LIMIT
  - [ ] Search and filtering capabilities
- [ ] Task 5: Add comprehensive audit logging system (AC: 5)
  - [ ] Create audit_logs table for tracking user modifications
  - [ ] Log user creation, updates, and deletion events
  - [ ] Include timestamp, user ID, action type, and changes
  - [ ] Record IP address and user agent for security
  - [ ] Implement audit middleware for automatic logging
- [ ] Task 6: Implement comprehensive testing (AC: 1-5)
  - [ ] Unit tests for all CRUD operations
  - [ ] Integration tests for complete user lifecycle
  - [ ] Validation testing with malicious input
  - [ ] Pagination and search functionality testing
  - [ ] Audit logging verification tests

## Dev Notes

### Previous Story Insights
[Source: Story 1.7 completion notes]
- User authentication system fully implemented with JWT tokens
- Basic user profile endpoints exist: GET /users/profile, PATCH /users/profile
- User model established with id, email, firstName, lastName, role, tenantId
- Authentication middleware and role-based authorization implemented
- Database repository pattern established with BaseRepository class

[Source: Story 1.4 completion notes]
- PostgreSQL database with users table fully configured
- Password hashing and validation implemented
- Multi-tenancy support with tenant_id relationships
- Error handling middleware for consistent API responses

### Technology Stack for CRUD Operations
[Source: architecture/tech-stack.md]
- **Backend Framework**: Express.js 4.19+ with REST endpoints
- **Database**: PostgreSQL 15+ with parameterized queries
- **Authentication**: JWT + Passport.js for token-based authentication
- **Validation**: Express-validator for input validation and sanitization
- **Testing**: Jest + Supertest for API testing

### Backend Architecture for CRUD Implementation
[Source: architecture/backend-architecture.md]
**Controller/Route Organization:**
```
apps/api/src/
├── routes/
│   └── users.routes.ts         # Complete CRUD routes
├── controllers/
│   └── users.controller.ts     # CRUD operation handlers
├── services/
│   └── users.service.ts        # Business logic layer
├── repositories/
│   └── users.repository.ts     # Data access layer
├── middleware/
│   ├── auth.middleware.ts      # Authentication
│   ├── validation.middleware.ts # Input validation
│   └── audit.middleware.ts     # Audit logging
└── validators/
    └── users.validator.ts      # Input validation schemas
```

**Controller Template Pattern:**
```typescript
export class UsersController {
  // Create user - POST /users
  createUser = AsyncHandler(async (req: AuthRequest, res: Response) => {
    const userData = req.body;
    const user = await this.usersService.create(userData);
    res.status(201).json({ success: true, data: user });
  });

  // Get user by ID - GET /users/:id
  getUserById = AsyncHandler(async (req: AuthRequest, res: Response) => {
    const { id } = req.params;
    const user = await this.usersService.findById(id);

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    res.json({ success: true, data: user });
  });
}
```

### Data Access Layer Implementation
[Source: architecture/backend-architecture.md]
**Repository Pattern for CRUD:**
```typescript
export class UsersRepository extends BaseRepository<User> {
  constructor(pool: Pool) {
    super(pool, 'users');
  }

  async findWithPagination(page: number, limit: number, tenantId?: string): Promise<{
    users: User[];
    total: number;
    page: number;
    limit: number;
  }> {
    const offset = (page - 1) * limit;

    let countQuery = 'SELECT COUNT(*) FROM users';
    let dataQuery = 'SELECT * FROM users';
    const params: any[] = [];

    if (tenantId) {
      countQuery += ' WHERE tenant_id = $1';
      dataQuery += ' WHERE tenant_id = $1';
      params.push(tenantId);
    }

    dataQuery += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);

    const [countResult, dataResult] = await Promise.all([
      this.pool.query(countQuery, tenantId ? [tenantId] : []),
      this.pool.query(dataQuery, params)
    ]);

    return {
      users: dataResult.rows,
      total: parseInt(countResult.rows[0].count),
      page,
      limit
    };
  }
}
```

### Request Validation and Security
[Source: architecture/backend-architecture.md]
**Input Validation Pattern:**
```typescript
// validators/users.validator.ts
export const createUserValidator = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .custom(async (email) => {
      const exists = await UsersService.findByEmail(email);
      if (exists) throw new Error('Email already exists');
    }),
  body('firstName')
    .trim()
    .isLength({ min: 2, max: 50 })
    .escape(),
  body('lastName')
    .trim()
    .isLength({ min: 2, max: 50 })
    .escape(),
  body('password')
    .isLength({ min: 8 })
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .withMessage('Password must contain uppercase, lowercase, number, and special character'),
  body('role')
    .isIn(['admin', 'user', 'readonly'])
    .withMessage('Invalid role')
];
```

**SQL Injection Prevention:**
- All database queries use parameterized statements
- Input sanitization through express-validator
- Database connection through secure pool configuration

### HTTP Status Codes and Error Handling
[Source: architecture/api-specification.md]
**Status Code Implementation:**
```typescript
// Success responses
201: { message: 'User created successfully', data: user }
200: { message: 'User retrieved successfully', data: user }
200: { message: 'User updated successfully', data: user }
204: null // For DELETE operations

// Error responses
400: { error: { code: 'VALIDATION_ERROR', message: 'Invalid input data', details: {} } }
401: { error: { code: 'UNAUTHORIZED', message: 'Authentication required' } }
403: { error: { code: 'FORBIDDEN', message: 'Insufficient permissions' } }
404: { error: { code: 'NOT_FOUND', message: 'User not found' } }
409: { error: { code: 'CONFLICT', message: 'Email already exists' } }
```

### Pagination Implementation
[Source: architecture/backend-architecture.md]
**Pagination Query Parameters:**
- `page`: Page number (default: 1)
- `limit`: Items per page (default: 20, max: 100)
- `search`: Search term for filtering
- `role`: Filter by user role
- `status`: Filter by active/inactive status

**Response Format:**
```typescript
{
  success: true,
  data: {
    users: User[],
    pagination: {
      page: number,
      limit: number,
      total: number,
      pages: number,
      hasNext: boolean,
      hasPrev: boolean
    }
  }
}
```

### Audit Logging System
[Source: architecture/backend-architecture.md]
**Audit Log Schema:**
```sql
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  tenant_id UUID REFERENCES tenants(id),
  user_id UUID REFERENCES users(id),
  action VARCHAR(100) NOT NULL,
  resource_type VARCHAR(50) NOT NULL,
  resource_id UUID,
  changes JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

**Audit Middleware Implementation:**
```typescript
export const auditMiddleware = (action: string, resourceType: string) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    const originalSend = res.send;

    res.send = function(body) {
      if (res.statusCode >= 200 && res.statusCode < 300) {
        // Log successful operations
        AuditService.log({
          userId: req.user?.id,
          tenantId: req.tenant?.id,
          action,
          resourceType,
          resourceId: req.params.id,
          changes: req.body,
          ipAddress: req.ip,
          userAgent: req.get('User-Agent')
        });
      }
      return originalSend.call(this, body);
    };

    next();
  };
};
```

### Route Authorization and Access Control
[Source: architecture/backend-architecture.md]
**Role-Based Access Control:**
```typescript
// Route definitions with role restrictions
router.post('/users', authenticate, authorize(['admin']), createUserValidator, usersController.createUser);
router.get('/users', authenticate, authorize(['admin']), usersController.getUsers);
router.get('/users/:id', authenticate, authorize(['admin', 'user']), usersController.getUserById);
router.put('/users/:id', authenticate, authorize(['admin']), updateUserValidator, usersController.updateUser);
router.patch('/users/:id', authenticate, authorize(['admin', 'user']), patchUserValidator, usersController.patchUser);
router.delete('/users/:id', authenticate, authorize(['admin']), usersController.deleteUser);
```

**Self-Access Rules:**
- Users can view and update their own profile
- Admin users can perform all operations on any user
- Regular users cannot create or delete other users

### Testing Standards
[Source: architecture/testing-strategy.md]
**Test File Locations:**
- **Unit Tests**: `apps/api/tests/unit/controllers/users.controller.test.ts`
- **Integration Tests**: `apps/api/tests/integration/users.test.ts`
- **Repository Tests**: `apps/api/tests/unit/repositories/users.repository.test.ts`

**Required Test Cases:**
- CRUD operations for all endpoints
- Input validation and sanitization
- Authentication and authorization
- Pagination and search functionality
- Audit logging verification
- Error handling and status codes
- SQL injection prevention
- Role-based access control

### Database Schema Extensions
[Source: architecture/data-models.md]
**Enhanced User Table:**
```sql
-- Add soft delete capability
ALTER TABLE users ADD COLUMN deleted_at TIMESTAMP WITH TIME ZONE;

-- Add indexes for performance
CREATE INDEX idx_users_email ON users(email) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_users_created_at ON users(created_at);

-- Add audit log indexes
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
```

## Testing

### Test File Locations
[Source: architecture/testing-strategy.md]
- **Unit Tests**: `apps/api/tests/unit/controllers/users.controller.test.ts`
- **Integration Tests**: `apps/api/tests/integration/users-crud.test.ts`
- **Repository Tests**: `apps/api/tests/unit/repositories/users.repository.test.ts`
- **Validation Tests**: `apps/api/tests/unit/validators/users.validator.test.ts`

### Testing Requirements
- Test all CRUD operations with various inputs
- Validate input sanitization and SQL injection prevention
- Test authentication and authorization for all endpoints
- Verify pagination functionality and edge cases
- Test audit logging accuracy and completeness
- Validate error handling and HTTP status codes
- Test role-based access control scenarios

### Test Examples Pattern
```typescript
// users-crud.test.ts
describe('Users CRUD API', () => {
  describe('POST /users', () => {
    it('should create user with valid data (admin)', async () => {
      const response = await request(app)
        .post('/api/v1/users')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          email: 'newuser@example.com',
          firstName: 'John',
          lastName: 'Doe',
          password: 'Test123!@#',
          role: 'user'
        });

      expect(response.status).toBe(201);
      expect(response.body.data.email).toBe('newuser@example.com');
    });

    it('should reject duplicate email', async () => {
      const response = await request(app)
        .post('/api/v1/users')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          email: 'admin@example.com', // Existing email
          firstName: 'Jane',
          lastName: 'Doe',
          password: 'Test123!@#',
          role: 'user'
        });

      expect(response.status).toBe(409);
      expect(response.body.error.code).toBe('CONFLICT');
    });
  });

  describe('GET /users', () => {
    it('should return paginated users (admin)', async () => {
      const response = await request(app)
        .get('/api/v1/users?page=1&limit=10')
        .set('Authorization', `Bearer ${adminToken}`);

      expect(response.status).toBe(200);
      expect(response.body.data.users).toBeInstanceOf(Array);
      expect(response.body.data.pagination).toHaveProperty('total');
    });
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-20 | 1.0 | Initial story creation for comprehensive user CRUD API endpoints | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
- (To be filled by Dev Agent)

### Debug Log References
- (To be filled by Dev Agent)

### Completion Notes
- (To be filled by Dev Agent)

### File List
- (To be filled by Dev Agent)

## QA Results
- (To be filled by QA Agent)