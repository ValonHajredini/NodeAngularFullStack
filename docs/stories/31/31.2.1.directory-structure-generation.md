# Story 31.2.1: Directory Structure Generation

## Status

Approved

## Story

**As a** developer, **I want** the CLI to generate the complete directory structure and write
rendered template files, **so that** a fully-structured tool is created with one command.

## Acceptance Criteria

1. ‚úÖ File writer module that creates directories and writes files
2. ‚úÖ Frontend directory structure created (`apps/web/src/app/features/tools/{toolId}/`)
3. ‚úÖ Backend directory structure created (`apps/api/src/{controllers,services,repositories}/`)
4. ‚úÖ Shared types directory (`packages/shared/src/types/`)
5. ‚úÖ All template files written with rendered content
6. ‚úÖ File permissions set correctly (644 for files, 755 for directories)
7. ‚úÖ Error handling for existing files/directories
8. ‚úÖ Success/failure reporting with file counts

## Tasks / Subtasks

- [ ] **Task 1: Create file writer module** (AC: 1)
  - [ ] Create file: `packages/create-tool/src/utils/file-writer.ts`
  - [ ] Import Node.js fs/promises for async file operations
  - [ ] Implement `createDirectory(path)` function with recursive mkdir
  - [ ] Implement `writeFile(path, content)` function with error handling
  - [ ] Implement `fileExists(path)` function to check for conflicts
  - [ ] Add JSDoc documentation for all functions

- [ ] **Task 2: Create directory structure configuration** (AC: 2-4)
  - [ ] Create file: `packages/create-tool/src/config/directory-structure.ts`
  - [ ] Define `DirectoryStructure` interface
  - [ ] Implement `getDirectoryStructure(metadata)` function
  - [ ] Return object mapping logical file names to actual file paths
  - [ ] Include paths for frontend, backend, and shared files
  - [ ] Account for tool-specific subdirectories

- [ ] **Task 3: Implement frontend directory structure** (AC: 2)
  - [ ] Define frontend base path: `apps/web/src/app/features/tools/${toolId}/`
  - [ ] Create directory structure:
    - [ ] `{toolId}/` - Feature root
    - [ ] `{toolId}/components/` - Components (if any)
    - [ ] `{toolId}/services/` - Services
  - [ ] Map template outputs to file paths:
    - [ ] Component TS ‚Üí `{toolId}/{toolId}.component.ts`
    - [ ] Component HTML ‚Üí `{toolId}/{toolId}.component.html`
    - [ ] Component CSS ‚Üí `{toolId}/{toolId}.component.css`
    - [ ] Service ‚Üí `{toolId}/services/{toolId}.service.ts`

- [ ] **Task 4: Implement backend directory structure** (AC: 3)
  - [ ] Define backend paths:
    - [ ] Controller ‚Üí `apps/api/src/controllers/{toolId}.controller.ts`
    - [ ] Service ‚Üí `apps/api/src/services/{toolId}.service.ts`
    - [ ] Repository ‚Üí `apps/api/src/repositories/{toolId}.repository.ts`
    - [ ] Routes ‚Üí `apps/api/src/routes/{toolId}.routes.ts`
    - [ ] Validator ‚Üí `apps/api/src/validators/{toolId}.validator.ts`
  - [ ] No nested directories needed (flat structure per backend conventions)

- [ ] **Task 5: Implement shared types structure** (AC: 4)
  - [ ] Define shared path: `packages/shared/src/types/{toolId}.types.ts`
  - [ ] Single file per tool
  - [ ] Update `packages/shared/src/index.ts` to export new types (Story 31.2.3)

- [ ] **Task 6: Implement generation orchestrator** (AC: 1-5)
  - [ ] Create file: `packages/create-tool/src/generator/file-generator.ts`
  - [ ] Implement `generateToolFiles(metadata)` async function
  - [ ] Get directory structure from config
  - [ ] Get rendered templates from template renderer
  - [ ] Create all directories first (mkdir -p pattern)
  - [ ] Write all files with rendered content
  - [ ] Track created files for reporting
  - [ ] Return generation result summary

- [ ] **Task 7: Implement conflict detection** (AC: 7)
  - [ ] Check if tool directory already exists before generation
  - [ ] Check if backend files already exist
  - [ ] Provide options:
    - [ ] `--force` flag to overwrite existing files
    - [ ] `--skip-existing` flag to skip existing files
    - [ ] Default: Abort with error message
  - [ ] List conflicting files in error message

- [ ] **Task 8: Set file permissions** (AC: 6)
  - [ ] Set permissions on created directories: `chmod 755`
  - [ ] Set permissions on created files: `chmod 644`
  - [ ] Use Node.js `fs.chmod()` after file creation
  - [ ] Handle permission errors gracefully (e.g., Windows doesn't support chmod)

- [ ] **Task 9: Implement progress reporting** (AC: 8)
  - [ ] Log each directory created: "‚úì Created directory: apps/web/src/app/features/tools/my-tool"
  - [ ] Log each file written: "‚úì Generated: my-tool.component.ts (1.2 KB)"
  - [ ] Log total summary: "‚úÖ Generated 12 files in 5 directories"
  - [ ] Use console colors (chalk library) for better UX
  - [ ] Show file sizes for each generated file

- [ ] **Task 10: Integrate with CLI** (AC: 1-8)
  - [ ] Import `generateToolFiles` in `src/index.ts`
  - [ ] Call after prompts and confirmation
  - [ ] Pass tool metadata to generator
  - [ ] Handle generation errors
  - [ ] Display success message with next steps
  - [ ] Exit with appropriate status code

- [ ] **Task 11: Add next steps instructions** (AC: 8)
  - [ ] After successful generation, print instructions:
    - [ ] "Next steps:"
    - [ ] "1. Build shared types: npm run build:shared"
    - [ ] "2. Run database migration: create migration for {toolId}"
    - [ ] "3. Add tool route to apps/web/src/app/app.routes.ts"
    - [ ] "4. Register tool via POST /api/tools/register"
    - [ ] "5. Start development: npm start"

- [ ] **Task 12: Test file generation manually** (AC: 1-8)
  - [ ] Build CLI: `npm run build --workspace=packages/create-tool`
  - [ ] Run CLI: `node packages/create-tool/dist/index.js test-tool`
  - [ ] Verify all directories created
  - [ ] Verify all files written with correct content
  - [ ] Verify file permissions correct
  - [ ] Test conflict detection (run twice on same tool)
  - [ ] Test with different feature combinations
  - [ ] Verify TypeScript compiles (npm run typecheck)

## Dev Notes

### Previous Story Insights

[Source: Story 31.1.3 Dev Agent Record]

- Templates created and tested
- Template renderer implemented
- Tool metadata structure defined
- Name converters available (PascalCase, kebab-case, etc.)

### File System Operations

[Source: Node.js fs/promises API]

**Async File Operations Pattern:**

```typescript
import fs from 'fs/promises';
import path from 'path';

/**
 * Create directory recursively (like mkdir -p).
 * @param dirPath - Directory path to create
 */
export async function createDirectory(dirPath: string): Promise<void> {
  await fs.mkdir(dirPath, { recursive: true });
}

/**
 * Write file to disk.
 * @param filePath - File path
 * @param content - File content
 */
export async function writeFile(filePath: string, content: string): Promise<void> {
  const dir = path.dirname(filePath);
  await createDirectory(dir); // Ensure directory exists
  await fs.writeFile(filePath, content, 'utf-8');
}

/**
 * Check if file or directory exists.
 * @param path - Path to check
 * @returns True if exists, false otherwise
 */
export async function fileExists(path: string): Promise<boolean> {
  try {
    await fs.access(path);
    return true;
  } catch {
    return false;
  }
}

/**
 * Set file permissions (Unix only).
 * @param filePath - File path
 * @param mode - Permission mode (e.g., 0o644)
 */
export async function setPermissions(filePath: string, mode: number): Promise<void> {
  try {
    await fs.chmod(filePath, mode);
  } catch (error) {
    // Ignore on Windows (chmod not supported)
    if (process.platform !== 'win32') {
      throw error;
    }
  }
}
```

### Directory Structure Configuration

[Source: architecture/source-tree.md + Stories 31.1.3]

**Directory Structure Interface:**

```typescript
interface DirectoryStructure {
  frontend: {
    base: string;
    files: {
      component: string;
      componentHtml: string;
      componentCss: string;
      service: string;
      routes: string;
    };
  };
  backend: {
    controller: string;
    service: string;
    repository: string;
    routes: string;
    validator: string;
  };
  shared: {
    types: string;
  };
  config: {
    readme: string;
  };
}
```

**Implementation:**

```typescript
// packages/create-tool/src/config/directory-structure.ts
import path from 'path';
import { ToolMetadata } from '../types';

/**
 * Get directory structure configuration for tool generation.
 * @param metadata - Tool metadata from prompts
 * @returns Directory structure with all file paths
 */
export function getDirectoryStructure(metadata: ToolMetadata): DirectoryStructure {
  const { toolId } = metadata;

  // Workspace root (relative to CLI package)
  const workspaceRoot = path.resolve(__dirname, '../../../../');

  // Frontend paths
  const frontendBase = path.join(workspaceRoot, 'apps/web/src/app/features/tools', toolId);

  return {
    frontend: {
      base: frontendBase,
      files: {
        component: path.join(frontendBase, `${toolId}.component.ts`),
        componentHtml: path.join(frontendBase, `${toolId}.component.html`),
        componentCss: path.join(frontendBase, `${toolId}.component.css`),
        service: path.join(frontendBase, 'services', `${toolId}.service.ts`),
        routes: path.join(frontendBase, `${toolId}.routes.ts`),
      },
    },
    backend: {
      controller: path.join(workspaceRoot, 'apps/api/src/controllers', `${toolId}.controller.ts`),
      service: path.join(workspaceRoot, 'apps/api/src/services', `${toolId}.service.ts`),
      repository: path.join(workspaceRoot, 'apps/api/src/repositories', `${toolId}.repository.ts`),
      routes: path.join(workspaceRoot, 'apps/api/src/routes', `${toolId}.routes.ts`),
      validator: path.join(workspaceRoot, 'apps/api/src/validators', `${toolId}.validator.ts`),
    },
    shared: {
      types: path.join(workspaceRoot, 'packages/shared/src/types', `${toolId}.types.ts`),
    },
    config: {
      readme: path.join(frontendBase, 'README.md'),
    },
  };
}
```

### File Generation Orchestrator

[Source: Story implementation plan]

**Generator Implementation:**

```typescript
// packages/create-tool/src/generator/file-generator.ts
import { ToolMetadata } from '../types';
import { getDirectoryStructure } from '../config/directory-structure';
import { renderAllTemplates } from '../utils/template-renderer';
import { createDirectory, writeFile, fileExists } from '../utils/file-writer';

interface GenerationResult {
  success: boolean;
  filesCreated: string[];
  directoriesCreated: string[];
  errors: string[];
}

/**
 * Generate all tool files from templates.
 * @param metadata - Tool metadata from prompts
 * @param options - Generation options
 * @returns Generation result summary
 */
export async function generateToolFiles(
  metadata: ToolMetadata,
  options: { force?: boolean; skipExisting?: boolean } = {}
): Promise<GenerationResult> {
  const result: GenerationResult = {
    success: false,
    filesCreated: [],
    directoriesCreated: [],
    errors: [],
  };

  try {
    // 1. Get directory structure
    const structure = getDirectoryStructure(metadata);

    // 2. Check for conflicts (unless force mode)
    if (!options.force && !options.skipExisting) {
      const conflicts = await checkConflicts(structure);
      if (conflicts.length > 0) {
        throw new Error(
          `Tool '${metadata.toolId}' already exists. Conflicting files:\n${conflicts.join('\n')}\n\nUse --force to overwrite or --skip-existing to skip conflicts.`
        );
      }
    }

    // 3. Render all templates
    console.log('üìù Rendering templates...');
    const rendered = await renderAllTemplates(metadata);

    // 4. Create directories
    console.log('üìÅ Creating directories...');
    const dirs = getUniqueDirs(structure);
    for (const dir of dirs) {
      await createDirectory(dir);
      result.directoriesCreated.push(dir);
      console.log(`  ‚úì ${path.relative(process.cwd(), dir)}`);
    }

    // 5. Write files
    console.log('üìÑ Generating files...');
    const fileMap = getFileMap(structure, rendered);
    for (const [filePath, content] of Object.entries(fileMap)) {
      // Skip if file exists and skipExisting mode
      if (options.skipExisting && (await fileExists(filePath))) {
        console.log(`  ‚äò Skipped (exists): ${path.basename(filePath)}`);
        continue;
      }

      await writeFile(filePath, content);
      await setPermissions(filePath, 0o644);
      result.filesCreated.push(filePath);

      const size = (content.length / 1024).toFixed(1);
      console.log(`  ‚úì ${path.basename(filePath)} (${size} KB)`);
    }

    result.success = true;
    console.log(
      `\n‚úÖ Generated ${result.filesCreated.length} files in ${result.directoriesCreated.length} directories`
    );
  } catch (error) {
    result.errors.push(error.message);
    console.error(`\n‚ùå Generation failed: ${error.message}`);
  }

  return result;
}

/**
 * Check for existing files that would conflict.
 */
async function checkConflicts(structure: DirectoryStructure): Promise<string[]> {
  const conflicts: string[] = [];
  const allFiles = getAllFilePaths(structure);

  for (const filePath of allFiles) {
    if (await fileExists(filePath)) {
      conflicts.push(filePath);
    }
  }

  return conflicts;
}

/**
 * Get unique directory paths from structure.
 */
function getUniqueDirs(structure: DirectoryStructure): string[] {
  const dirs = new Set<string>();

  // Frontend directories
  dirs.add(structure.frontend.base);
  dirs.add(path.dirname(structure.frontend.files.service));

  // Backend directories (files are flat, just need parent dirs)
  dirs.add(path.dirname(structure.backend.controller));
  // ... other dirs

  // Shared directories
  dirs.add(path.dirname(structure.shared.types));

  return Array.from(dirs);
}

/**
 * Map file paths to rendered content.
 */
function getFileMap(
  structure: DirectoryStructure,
  rendered: Record<string, string>
): Record<string, string> {
  return {
    // Frontend
    [structure.frontend.files.component]: rendered.component,
    [structure.frontend.files.componentHtml]: rendered.componentHtml,
    [structure.frontend.files.componentCss]: rendered.componentCss,
    [structure.frontend.files.service]: rendered.service,
    [structure.frontend.files.routes]: rendered.routes,

    // Backend
    [structure.backend.controller]: rendered.controller,
    [structure.backend.service]: rendered.backendService,
    [structure.backend.repository]: rendered.repository,
    [structure.backend.routes]: rendered.backendRoutes,
    [structure.backend.validator]: rendered.validator,

    // Shared
    [structure.shared.types]: rendered.types,

    // Config
    [structure.config.readme]: rendered.readme,
  };
}
```

### Conflict Detection

[Source: CLI best practices]

**Conflict Handling Strategies:**

1. **Default (Abort):** Stop generation if any file exists
   - Safest option
   - Forces user to explicitly handle conflicts

2. **Force Mode (`--force`):** Overwrite all existing files
   - Useful for regenerating tool
   - Warns user before overwriting

3. **Skip Existing (`--skip-existing`):** Only create new files
   - Useful for partial regeneration
   - Preserves manual changes

**Implementation:**

```typescript
// Check for existing frontend directory
const frontendExists = await fileExists(structure.frontend.base);
if (frontendExists && !options.force && !options.skipExisting) {
  throw new Error(
    `Frontend directory already exists: ${structure.frontend.base}\n` +
      `Use --force to overwrite or --skip-existing to skip conflicts.`
  );
}
```

### Progress Reporting

[Source: CLI UX best practices]

**Chalk Library for Colors:**

```bash
npm install chalk --workspace=packages/create-tool
npm install @types/chalk --save-dev --workspace=packages/create-tool
```

**Colored Output:**

```typescript
import chalk from 'chalk';

console.log(chalk.blue('üìÅ Creating directories...'));
console.log(chalk.green('  ‚úì apps/web/src/app/features/tools/my-tool'));

console.log(chalk.blue('üìÑ Generating files...'));
console.log(chalk.green('  ‚úì my-tool.component.ts (1.2 KB)'));

console.log(chalk.green.bold('\n‚úÖ Generation complete!'));
```

**Progress Indicators:**

- `üìÅ` - Directory creation
- `üìÑ` - File generation
- `‚úì` - Success checkmark
- `‚úÖ` - Complete checkmark
- `‚ùå` - Error indicator
- `‚äò` - Skipped indicator

### File Permissions

[Source: Unix file permissions + Node.js fs docs]

**Permission Modes:**

```typescript
// Octal notation
0o755; // rwxr-xr-x (directories)
0o644; // rw-r--r-- (files)

// Explanation:
// 7 (owner): read + write + execute
// 5 (group): read + execute
// 5 (other): read + execute

// 6 (owner): read + write
// 4 (group): read
// 4 (other): read
```

**Setting Permissions:**

```typescript
import fs from 'fs/promises';

// For directories
await fs.chmod('/path/to/directory', 0o755);

// For files
await fs.chmod('/path/to/file.ts', 0o644);

// Handle Windows (no-op)
try {
  await fs.chmod(filePath, mode);
} catch (error) {
  if (process.platform === 'win32') {
    // Windows doesn't support chmod, silently ignore
    return;
  }
  throw error;
}
```

### Next Steps Instructions

[Source: Story implementation plan]

**Post-Generation Instructions:**

```typescript
function printNextSteps(metadata: ToolMetadata): void {
  console.log(chalk.blue.bold('\nüìã Next Steps:\n'));

  console.log(chalk.white('1. Build shared types:'));
  console.log(chalk.gray('   npm run build:shared'));

  console.log(chalk.white('\n2. Create database migration:'));
  console.log(
    chalk.gray(`   npm --workspace=apps/api run db:migration:create ${metadata.toolId}_table`)
  );

  console.log(chalk.white('\n3. Add tool route to Angular:'));
  console.log(chalk.gray('   Edit apps/web/src/app/app.routes.ts'));
  console.log(chalk.gray(`   Import and add route: /tools/${metadata.toolId}`));

  console.log(chalk.white('\n4. Register tool with platform:'));
  console.log(chalk.gray('   POST /api/tools/register'));
  console.log(
    chalk.gray(`   Or run: npm --workspace=apps/api run tools:register ${metadata.toolId}`)
  );

  console.log(chalk.white('\n5. Start development servers:'));
  console.log(chalk.gray('   npm start'));
  console.log(chalk.gray(`   Then visit: http://localhost:4200/tools/${metadata.toolId}`));

  console.log(chalk.blue('\nüìö Documentation:'));
  console.log(chalk.gray(`   See ${metadata.toolId}/README.md for usage details\n`));
}
```

### Dependencies on Previous Stories

**Story 31.1.1-31.1.4 Required:**

- CLI package setup complete
- Prompts collect metadata
- Templates created and tested
- Template renderer functional

**Epic 30 Reference:**

- Tool Registry API exists (for Story 31.2.4 registration)
- Database schema patterns

### Integration with CLI Entry Point

[Source: Story 31.1.1 + 31.1.2]

**Updated CLI Entry Point:**

```typescript
#!/usr/bin/env node
import { Command } from 'commander';
import { promptForToolMetadata } from './prompts/tool-prompts.js';
import { generateToolFiles } from './generator/file-generator.js';
import { version } from '../package.json';

const program = new Command();

program
  .name('create-tool')
  .version(version)
  .description('Scaffold new tools for NodeAngularFullStack platform')
  .argument('[tool-name]', 'Tool name (will prompt if not provided)')
  .option('--force', 'Overwrite existing files')
  .option('--skip-existing', 'Skip existing files')
  .action(async (toolName?: string, options?: any) => {
    console.log('üõ†Ô∏è  Create Tool Wizard\n');

    try {
      // 1. Prompt for metadata
      const metadata = await promptForToolMetadata(toolName);

      // 2. Check confirmation
      if (!metadata.confirm) {
        console.log('‚ùå Tool generation cancelled');
        process.exit(0);
      }

      // 3. Generate files
      const result = await generateToolFiles(metadata, {
        force: options?.force,
        skipExisting: options?.skipExisting,
      });

      if (result.success) {
        printNextSteps(metadata);
        process.exit(0);
      } else {
        console.error('‚ùå Generation failed:', result.errors.join('\n'));
        process.exit(1);
      }
    } catch (error) {
      console.error('‚ùå Error:', error.message);
      process.exit(1);
    }
  });

program.parse(process.argv);
```

### JSDoc Documentation

[Source: architecture/coding-standards.md]

**Module Documentation:**

````typescript
/**
 * File Generator
 *
 * Orchestrates tool file generation from templates.
 * Creates directory structure, writes rendered files, and reports progress.
 *
 * Features:
 * - Conflict detection (abort/force/skip)
 * - Progress reporting with file sizes
 * - Error handling and rollback
 * - Permission setting (Unix)
 *
 * @module generator/file-generator
 * @example
 * ```typescript
 * import { generateToolFiles } from './generator/file-generator';
 *
 * const result = await generateToolFiles(metadata, { force: true });
 * if (result.success) {
 *   console.log(`Created ${result.filesCreated.length} files`);
 * }
 * ```
 */
````

## Testing

### Manual Testing

**Test Full Generation Flow:**

```bash
# 1. Build CLI
npm run build --workspace=packages/create-tool

# 2. Test generation with sample tool
node packages/create-tool/dist/index.js test-tool

# Follow prompts:
# - Tool name: Test Tool
# - Tool ID: test-tool (default)
# - Description: A test tool
# - Icon: pi-box (default)
# - Features: Select all
# - Confirm: Yes

# 3. Verify directories created
ls -la apps/web/src/app/features/tools/test-tool
ls -la apps/api/src/controllers/test-tool.*
ls -la packages/shared/src/types/test-tool.types.ts

# 4. Verify file content
cat apps/web/src/app/features/tools/test-tool/test-tool.component.ts
# Should contain: TestToolComponent class

# 5. Verify file permissions (Unix)
ls -l apps/web/src/app/features/tools/test-tool/test-tool.component.ts
# Should show: -rw-r--r-- (644)

# 6. Test conflict detection
node packages/create-tool/dist/index.js test-tool
# Should error: "Tool already exists"

# 7. Test force mode
node packages/create-tool/dist/index.js test-tool --force
# Should overwrite files

# 8. Test skip mode
node packages/create-tool/dist/index.js test-tool --skip-existing
# Should skip existing files

# 9. Verify TypeScript compiles
npm run typecheck --workspace=apps/web
npm run typecheck --workspace=apps/api
# Should have no errors (after building shared types)

# 10. Clean up
rm -rf apps/web/src/app/features/tools/test-tool
rm apps/api/src/controllers/test-tool.*
rm apps/api/src/services/test-tool.*
rm apps/api/src/repositories/test-tool.*
rm apps/api/src/routes/test-tool.*
rm apps/api/src/validators/test-tool.*
rm packages/shared/src/types/test-tool.types.ts
```

### Verification Checklist

After implementation:

- [ ] File writer module created
- [ ] Directory structure config created
- [ ] File generator orchestrator implemented
- [ ] Conflict detection works
- [ ] Force mode overwrites files
- [ ] Skip mode preserves existing files
- [ ] Progress reporting with colors
- [ ] File permissions set (Unix)
- [ ] Next steps printed
- [ ] All generated files compile
- [ ] CLI flags work (--force, --skip-existing)

### Known Issues & Solutions

**Issue: Path resolution errors**

```typescript
// Solution: Use absolute paths from workspace root
const workspaceRoot = path.resolve(__dirname, '../../../../');
const fullPath = path.join(workspaceRoot, 'apps/web/...');
```

**Issue: Permission denied on Windows**

```typescript
// Solution: Catch and ignore chmod errors on Windows
try {
  await fs.chmod(filePath, mode);
} catch (error) {
  if (process.platform !== 'win32') throw error;
}
```

**Issue: Directory already exists**

```typescript
// Solution: Use { recursive: true } option
await fs.mkdir(dirPath, { recursive: true }); // No error if exists
```

**Issue: File encoding issues**

```typescript
// Solution: Always specify utf-8 encoding
await fs.writeFile(filePath, content, 'utf-8');
```

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-10-24 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Debug Log References

(To be filled by dev agent)

### Completion Notes List

(To be filled by dev agent)

### File List

(To be filled by dev agent)

## QA Results

(To be filled by QA agent after story completion)
