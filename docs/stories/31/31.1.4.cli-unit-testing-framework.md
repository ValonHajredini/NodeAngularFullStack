# Story 31.1.4: CLI Unit Testing Framework

## Status

Draft

## Story

**As a** developer, **I want** a Jest testing framework for the CLI package, **so that** prompt
logic, template rendering, and utilities have test coverage.

## Acceptance Criteria

1. ✅ Jest configured for CLI package
2. ✅ Tests for string utility functions (kebab-case, PascalCase)
3. ✅ Tests for validation functions (tool ID, names)
4. ✅ Tests for template rendering (all templates)
5. ✅ Test coverage ≥80%

## Tasks / Subtasks

- [ ] **Task 1: Install Jest dependencies** (AC: 1)
  - [ ] Install Jest: `npm install jest --save-dev --workspace=packages/create-tool`
  - [ ] Install ts-jest: `npm install ts-jest --save-dev --workspace=packages/create-tool`
  - [ ] Install TypeScript types:
        `npm install @types/jest --save-dev --workspace=packages/create-tool`
  - [ ] Verify versions: Jest ≥29.0.0, ts-jest ≥29.0.0

- [ ] **Task 2: Create Jest configuration** (AC: 1)
  - [ ] Create file: `packages/create-tool/jest.config.js`
  - [ ] Configure preset: `ts-jest`
  - [ ] Set test environment: `node`
  - [ ] Configure test match pattern: `**/__tests__/**/*.test.ts`
  - [ ] Set coverage thresholds: ≥80% for branches, functions, lines, statements
  - [ ] Exclude coverage: `dist/`, `node_modules/`, `*.test.ts`
  - [ ] Add transform for TypeScript files

- [ ] **Task 3: Create test directory structure** (AC: 1-5)
  - [ ] Create directory: `packages/create-tool/src/__tests__/`
  - [ ] Create subdirectories:
    - [ ] `__tests__/utils/` - Utility function tests
    - [ ] `__tests__/templates/` - Template rendering tests
    - [ ] `__tests__/prompts/` - Prompt logic tests (future)

- [ ] **Task 4: Add test scripts to package.json** (AC: 1)
  - [ ] Add script: `"test": "jest"`
  - [ ] Add script: `"test:watch": "jest --watch"`
  - [ ] Add script: `"test:coverage": "jest --coverage"`
  - [ ] Add script: `"test:verbose": "jest --verbose"`

- [ ] **Task 5: Test string conversion utilities** (AC: 2)
  - [ ] Create file: `src/__tests__/utils/name-converters.test.ts`
  - [ ] Test `toKebabCase()`:
    - [ ] "My Tool" → "my-tool"
    - [ ] "UserProfile" → "user-profile"
    - [ ] "Inventory_Tracker" → "inventory-tracker"
    - [ ] Handles special characters (removes them)
    - [ ] Handles multiple spaces
    - [ ] Handles leading/trailing hyphens
    - [ ] Empty string returns empty string
  - [ ] Test `toPascalCase()`:
    - [ ] "my-tool" → "MyTool"
    - [ ] "user-profile" → "UserProfile"
    - [ ] "inventory_tracker" → "InventoryTracker"
    - [ ] Single word capitalized
  - [ ] Test `toCamelCase()`:
    - [ ] "my-tool" → "myTool"
    - [ ] "user-profile" → "userProfile"
    - [ ] Single word lowercase
  - [ ] Test `toSnakeCase()`:
    - [ ] "my-tool" → "my_tool"
    - [ ] "userProfile" → "user_profile"

- [ ] **Task 6: Test validation functions** (AC: 3)
  - [ ] Create file: `src/__tests__/utils/validators.test.ts`
  - [ ] Test `validateToolId()`:
    - [ ] Valid: "my-tool" → returns true
    - [ ] Valid: "inventory123" → returns true
    - [ ] Invalid: "My-Tool" (uppercase) → returns error message
    - [ ] Invalid: "my_tool" (underscore) → returns error message
    - [ ] Invalid: "123tool" (starts with number) → returns error message
    - [ ] Invalid: "a" (too short) → returns error message
    - [ ] Invalid: very long string → returns error message
  - [ ] Test `validateToolName()`:
    - [ ] Valid: "My Tool" → returns true
    - [ ] Invalid: "ab" (< 3 chars) → returns error message
    - [ ] Invalid: empty string → returns error message
    - [ ] Invalid: very long string (> 50 chars) → returns error message

- [ ] **Task 7: Test template rendering** (AC: 4)
  - [ ] Create file: `src/__tests__/templates/template-rendering.test.ts`
  - [ ] Create sample test data (toolId, toolName, etc.)
  - [ ] Test component template renders without errors
  - [ ] Test service template renders without errors
  - [ ] Test controller template renders without errors
  - [ ] Test repository template renders without errors
  - [ ] Test types template renders without errors
  - [ ] Test routes template renders without errors
  - [ ] Verify rendered content includes expected strings:
    - [ ] Component has correct class name
    - [ ] Service has correct API base
    - [ ] Controller has all CRUD methods
    - [ ] Repository has SQL queries
    - [ ] Types have all interfaces

- [ ] **Task 8: Test template loader** (AC: 4)
  - [ ] Create file: `src/__tests__/templates/template-loader.test.ts`
  - [ ] Test `loadTemplate()`:
    - [ ] Valid template path loads successfully
    - [ ] Invalid template path throws error
    - [ ] Error message mentions template name
  - [ ] Test `renderTemplate()`:
    - [ ] Simple variable substitution works
    - [ ] Conditional blocks work (if/else)
    - [ ] Loops work (forEach)
    - [ ] Invalid EJS syntax throws error
  - [ ] Test `renderTemplateFile()`:
    - [ ] Combines load and render successfully
    - [ ] Returns expected output

- [ ] **Task 9: Run tests and verify coverage** (AC: 5)
  - [ ] Run all tests: `npm --workspace=packages/create-tool run test`
  - [ ] Verify all tests pass
  - [ ] Run with coverage: `npm --workspace=packages/create-tool run test:coverage`
  - [ ] Verify coverage ≥80% for:
    - [ ] utils/name-converters.ts
    - [ ] utils/validators.ts
    - [ ] templates/template-loader.ts
  - [ ] Address any coverage gaps

- [ ] **Task 10: Add test documentation** (AC: 1-5)
  - [ ] Create file: `packages/create-tool/README.md` (if not exists)
  - [ ] Add "Testing" section
  - [ ] Document how to run tests
  - [ ] Document coverage requirements
  - [ ] Add examples of running specific tests

## Dev Notes

### Previous Story Insights

[Source: Story 31.1.3 Dev Agent Record]

- EJS templates created for all file types
- Template loader module implemented
- Name conversion utilities available
- Validation functions defined

### Jest Configuration for CLI

[Source: architecture/testing-strategy.md + Jest best practices]

**Jest Config Pattern (`packages/create-tool/jest.config.js`):**

```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.test.ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.test.ts',
    '!src/**/__tests__/**',
    '!src/index.ts', // Entry point, tested manually
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  coverageDirectory: 'coverage',
  verbose: true,
};
```

**Why ts-jest:**

- Compiles TypeScript on-the-fly during testing
- No separate build step needed
- Source maps for debugging
- Type checking during tests

### File Location

[Source: architecture/source-tree.md + Jest conventions]

**Test Directory Structure:**

```
packages/create-tool/
├── src/
│   ├── __tests__/                    # Test root
│   │   ├── utils/
│   │   │   ├── name-converters.test.ts
│   │   │   └── validators.test.ts
│   │   └── templates/
│   │       ├── template-loader.test.ts
│   │       └── template-rendering.test.ts
│   ├── utils/
│   │   ├── name-converters.ts        # Tested by __tests__/utils/
│   │   └── validators.ts             # Tested by __tests__/utils/
│   ├── templates/
│   │   └── template-loader.ts        # Tested by __tests__/templates/
│   └── index.ts
├── coverage/                         # Generated by jest --coverage
├── jest.config.js
└── package.json
```

**Test Naming Convention:**

- Test files: `*.test.ts` (NOT `*.spec.ts` - that's for Angular)
- Test suites: `describe('FunctionName', () => {})`
- Test cases: `it('should do something', () => {})`

### Testing String Utilities

[Source: Story 31.1.2 + 31.1.3 utilities]

**Test Suite Pattern:**

```typescript
// src/__tests__/utils/name-converters.test.ts
import { toKebabCase, toPascalCase, toCamelCase, toSnakeCase } from '../../utils/name-converters';

describe('toKebabCase', () => {
  it('should convert spaces to hyphens', () => {
    expect(toKebabCase('My Tool')).toBe('my-tool');
    expect(toKebabCase('User Profile Manager')).toBe('user-profile-manager');
  });

  it('should convert PascalCase to kebab-case', () => {
    expect(toKebabCase('UserProfile')).toBe('user-profile');
    expect(toKebabCase('InventoryTracker')).toBe('inventory-tracker');
  });

  it('should handle underscores', () => {
    expect(toKebabCase('user_profile')).toBe('user-profile');
    expect(toKebabCase('my_tool_name')).toBe('my-tool-name');
  });

  it('should remove special characters', () => {
    expect(toKebabCase('My Tool!')).toBe('my-tool');
    expect(toKebabCase('User@Profile#')).toBe('userprofile');
  });

  it('should handle multiple spaces', () => {
    expect(toKebabCase('My   Tool')).toBe('my-tool');
  });

  it('should trim leading/trailing hyphens', () => {
    expect(toKebabCase('-my-tool-')).toBe('my-tool');
  });

  it('should handle empty string', () => {
    expect(toKebabCase('')).toBe('');
  });

  it('should handle single word', () => {
    expect(toKebabCase('tool')).toBe('tool');
    expect(toKebabCase('Tool')).toBe('tool');
  });
});

describe('toPascalCase', () => {
  it('should convert kebab-case to PascalCase', () => {
    expect(toPascalCase('my-tool')).toBe('MyTool');
    expect(toPascalCase('user-profile')).toBe('UserProfile');
  });

  it('should capitalize single word', () => {
    expect(toPascalCase('tool')).toBe('Tool');
  });

  it('should handle underscores', () => {
    expect(toPascalCase('my_tool')).toBe('MyTool');
  });
});

describe('toCamelCase', () => {
  it('should convert kebab-case to camelCase', () => {
    expect(toCamelCase('my-tool')).toBe('myTool');
    expect(toCamelCase('user-profile')).toBe('userProfile');
  });

  it('should lowercase single word', () => {
    expect(toCamelCase('tool')).toBe('tool');
  });
});

describe('toSnakeCase', () => {
  it('should convert kebab-case to snake_case', () => {
    expect(toSnakeCase('my-tool')).toBe('my_tool');
    expect(toSnakeCase('user-profile')).toBe('user_profile');
  });
});
```

### Testing Validation Functions

[Source: Story 31.1.2 validation]

**Validation Test Pattern:**

```typescript
// src/__tests__/utils/validators.test.ts
import { validateToolId, validateToolName } from '../../utils/validators';

describe('validateToolId', () => {
  describe('valid tool IDs', () => {
    it('should accept lowercase kebab-case', () => {
      expect(validateToolId('my-tool')).toBe(true);
      expect(validateToolId('user-profile')).toBe(true);
      expect(validateToolId('inventory-tracker')).toBe(true);
    });

    it('should accept lowercase with numbers', () => {
      expect(validateToolId('tool123')).toBe(true);
      expect(validateToolId('my-tool-2')).toBe(true);
    });

    it('should accept single lowercase letter', () => {
      expect(validateToolId('a')).toBe(true);
    });
  });

  describe('invalid tool IDs', () => {
    it('should reject uppercase letters', () => {
      const result = validateToolId('My-Tool');
      expect(result).not.toBe(true);
      expect(result).toContain('kebab-case');
    });

    it('should reject underscores', () => {
      const result = validateToolId('my_tool');
      expect(result).not.toBe(true);
      expect(result).toContain('kebab-case');
    });

    it('should reject starting with number', () => {
      const result = validateToolId('123tool');
      expect(result).not.toBe(true);
      expect(result).toContain('letter');
    });

    it('should reject special characters', () => {
      const result = validateToolId('my@tool');
      expect(result).not.toBe(true);
    });

    it('should reject too short (< 2 chars)', () => {
      const result = validateToolId('a');
      expect(result).not.toBe(true);
      expect(result).toContain('2-50');
    });

    it('should reject too long (> 50 chars)', () => {
      const longId = 'a'.repeat(51);
      const result = validateToolId(longId);
      expect(result).not.toBe(true);
      expect(result).toContain('2-50');
    });

    it('should reject empty string', () => {
      const result = validateToolId('');
      expect(result).not.toBe(true);
    });
  });
});

describe('validateToolName', () => {
  describe('valid tool names', () => {
    it('should accept names 3-50 characters', () => {
      expect(validateToolName('My Tool')).toBe(true);
      expect(validateToolName('Inventory Tracker')).toBe(true);
    });

    it('should accept names with numbers', () => {
      expect(validateToolName('Tool 123')).toBe(true);
    });

    it('should accept exactly 3 characters', () => {
      expect(validateToolName('abc')).toBe(true);
    });

    it('should accept exactly 50 characters', () => {
      const name = 'a'.repeat(50);
      expect(validateToolName(name)).toBe(true);
    });
  });

  describe('invalid tool names', () => {
    it('should reject names < 3 characters', () => {
      const result = validateToolName('ab');
      expect(result).not.toBe(true);
      expect(result).toContain('3 characters');
    });

    it('should reject empty string', () => {
      const result = validateToolName('');
      expect(result).not.toBe(true);
    });

    it('should reject whitespace-only string', () => {
      const result = validateToolName('   ');
      expect(result).not.toBe(true);
    });

    it('should reject names > 50 characters', () => {
      const longName = 'a'.repeat(51);
      const result = validateToolName(longName);
      expect(result).not.toBe(true);
      expect(result).toContain('50 characters');
    });
  });
});
```

### Testing Template Rendering

[Source: Story 31.1.3 templates]

**Template Test Pattern:**

```typescript
// src/__tests__/templates/template-rendering.test.ts
import { renderTemplateFile } from '../../templates/template-loader';
import { toPascalCase, toCamelCase, toSnakeCase } from '../../utils/name-converters';

describe('Template Rendering', () => {
  const testData = {
    toolId: 'test-tool',
    toolName: 'Test Tool',
    description: 'A test tool for validation',
    icon: 'pi-box',
    className: toPascalCase('test-tool'),
    serviceName: toCamelCase('test-tool'),
    tableName: toSnakeCase('test-tool'),
    route: '/tools/test-tool',
    apiBase: '/api/tools/test-tool',
    permissions: ['user'],
    features: {
      backend: true,
      database: true,
      service: true,
      component: true,
    },
  };

  describe('Angular Component Template', () => {
    it('should render component without errors', async () => {
      const rendered = await renderTemplateFile('frontend/component.ts.ejs', testData);
      expect(rendered).toBeDefined();
      expect(rendered).toContain('@Component');
      expect(rendered).toContain('TestToolComponent');
      expect(rendered).toContain('app-test-tool');
    });

    it('should include imports', async () => {
      const rendered = await renderTemplateFile('frontend/component.ts.ejs', testData);
      expect(rendered).toContain("from '@angular/core'");
      expect(rendered).toContain("from '@angular/common'");
    });

    it('should include ngOnInit lifecycle hook', async () => {
      const rendered = await renderTemplateFile('frontend/component.ts.ejs', testData);
      expect(rendered).toContain('ngOnInit()');
    });
  });

  describe('Angular Service Template', () => {
    it('should render service without errors', async () => {
      const rendered = await renderTemplateFile('frontend/service.ts.ejs', testData);
      expect(rendered).toBeDefined();
      expect(rendered).toContain('@Injectable');
      expect(rendered).toContain('TestToolService');
    });

    it('should include HttpClient', async () => {
      const rendered = await renderTemplateFile('frontend/service.ts.ejs', testData);
      expect(rendered).toContain('HttpClient');
      expect(rendered).toContain('private http');
    });

    it('should include CRUD methods', async () => {
      const rendered = await renderTemplateFile('frontend/service.ts.ejs', testData);
      expect(rendered).toContain('getAll()');
      expect(rendered).toContain('getById(');
      expect(rendered).toContain('create(');
      expect(rendered).toContain('update(');
      expect(rendered).toContain('delete(');
    });

    it('should use correct API base', async () => {
      const rendered = await renderTemplateFile('frontend/service.ts.ejs', testData);
      expect(rendered).toContain('/api/tools/test-tool');
    });
  });

  describe('Backend Controller Template', () => {
    it('should render controller without errors', async () => {
      const rendered = await renderTemplateFile('backend/controller.ts.ejs', testData);
      expect(rendered).toBeDefined();
      expect(rendered).toContain('TestToolController');
    });

    it('should include Express types', async () => {
      const rendered = await renderTemplateFile('backend/controller.ts.ejs', testData);
      expect(rendered).toContain('Request');
      expect(rendered).toContain('Response');
      expect(rendered).toContain('NextFunction');
    });

    it('should include all CRUD methods', async () => {
      const rendered = await renderTemplateFile('backend/controller.ts.ejs', testData);
      expect(rendered).toContain('getAll = async');
      expect(rendered).toContain('getById = async');
      expect(rendered).toContain('create = async');
      expect(rendered).toContain('update = async');
      expect(rendered).toContain('delete = async');
    });

    it('should include error handling', async () => {
      const rendered = await renderTemplateFile('backend/controller.ts.ejs', testData);
      expect(rendered).toContain('try {');
      expect(rendered).toContain('catch (error)');
      expect(rendered).toContain('next(error)');
    });
  });

  describe('Backend Repository Template', () => {
    it('should render repository without errors', async () => {
      const rendered = await renderTemplateFile('backend/repository.ts.ejs', testData);
      expect(rendered).toBeDefined();
      expect(rendered).toContain('TestToolRepository');
    });

    it('should include PostgreSQL types', async () => {
      const rendered = await renderTemplateFile('backend/repository.ts.ejs', testData);
      expect(rendered).toContain('Pool');
      expect(rendered).toContain('QueryResult');
    });

    it('should include SQL queries', async () => {
      const rendered = await renderTemplateFile('backend/repository.ts.ejs', testData);
      expect(rendered).toContain('SELECT *');
      expect(rendered).toContain('INSERT INTO');
      expect(rendered).toContain('UPDATE');
      expect(rendered).toContain('DELETE FROM');
    });

    it('should use correct table name', async () => {
      const rendered = await renderTemplateFile('backend/repository.ts.ejs', testData);
      expect(rendered).toContain('test_tool'); // snake_case
    });

    it('should include parameterized queries', async () => {
      const rendered = await renderTemplateFile('backend/repository.ts.ejs', testData);
      expect(rendered).toContain('$1');
      expect(rendered).toContain('$2');
    });
  });

  describe('Shared Types Template', () => {
    it('should render types without errors', async () => {
      const rendered = await renderTemplateFile('shared/types.ts.ejs', testData);
      expect(rendered).toBeDefined();
      expect(rendered).toContain('TestToolRecord');
    });

    it('should include all interfaces', async () => {
      const rendered = await renderTemplateFile('shared/types.ts.ejs', testData);
      expect(rendered).toContain('interface TestToolRecord');
      expect(rendered).toContain('interface CreateTestToolInput');
      expect(rendered).toContain('interface UpdateTestToolInput');
    });

    it('should include JSDoc comments', async () => {
      const rendered = await renderTemplateFile('shared/types.ts.ejs', testData);
      expect(rendered).toContain('/**');
      expect(rendered).toContain('*/');
    });
  });
});
```

### Testing Template Loader

[Source: Story 31.1.3 template loader]

**Loader Test Pattern:**

```typescript
// src/__tests__/templates/template-loader.test.ts
import { loadTemplate, renderTemplate, renderTemplateFile } from '../../templates/template-loader';

describe('Template Loader', () => {
  describe('loadTemplate', () => {
    it('should load existing template', async () => {
      const template = await loadTemplate('frontend/component.ts.ejs');
      expect(template).toBeDefined();
      expect(template.length).toBeGreaterThan(0);
      expect(template).toContain('<%');
    });

    it('should throw error for missing template', async () => {
      await expect(loadTemplate('nonexistent.ejs')).rejects.toThrow('Template not found');
    });
  });

  describe('renderTemplate', () => {
    it('should render simple variable', () => {
      const template = 'Hello <%= name %>!';
      const rendered = renderTemplate(template, { name: 'World' });
      expect(rendered).toBe('Hello World!');
    });

    it('should render conditional', () => {
      const template = '<% if (show) { %>Visible<% } %>';
      const rendered = renderTemplate(template, { show: true });
      expect(rendered).toContain('Visible');
    });

    it('should render loop', () => {
      const template = '<% items.forEach(item => { %><%= item %><% }); %>';
      const rendered = renderTemplate(template, { items: ['a', 'b', 'c'] });
      expect(rendered).toBe('abc');
    });

    it('should throw error for invalid EJS syntax', () => {
      const template = '<%= unclosed';
      expect(() => renderTemplate(template, {})).toThrow();
    });
  });

  describe('renderTemplateFile', () => {
    it('should load and render template', async () => {
      const data = {
        toolId: 'test',
        toolName: 'Test',
        className: 'Test',
      };
      const rendered = await renderTemplateFile('frontend/component.ts.ejs', data);
      expect(rendered).toBeDefined();
      expect(rendered).toContain('Test');
    });
  });
});
```

### Coverage Requirements

[Source: AC5 + architecture/testing-strategy.md]

**Coverage Thresholds:**

```javascript
coverageThreshold: {
  global: {
    branches: 80,    // All if/else branches covered
    functions: 80,   // All functions called
    lines: 80,       // All lines executed
    statements: 80,  // All statements executed
  },
}
```

**How to Check Coverage:**

```bash
npm --workspace=packages/create-tool run test:coverage

# Output shows:
# File                      | % Stmts | % Branch | % Funcs | % Lines |
# --------------------------|---------|----------|---------|---------|
# name-converters.ts        |   95.23 |    87.50 |  100.00 |   95.00 |
# validators.ts             |   92.30 |    85.71 |  100.00 |   92.00 |
# template-loader.ts        |   88.88 |    75.00 |  100.00 |   88.00 |
# --------------------------|---------|----------|---------|---------|
# All files                 |   92.14 |    82.74 |  100.00 |   91.67 |
```

**Improving Coverage:**

- Add tests for uncovered branches (check coverage report HTML)
- Test error paths and edge cases
- Test with different input combinations

### Dependencies on Previous Stories

**Story 31.1.1 Required:**

- CLI package exists with TypeScript

**Story 31.1.2 Required:**

- Validation utilities implemented
- String conversion utilities available

**Story 31.1.3 Required:**

- Templates created
- Template loader implemented

### Test Running Workflow

[Source: Jest best practices]

**Development Workflow:**

```bash
# 1. Start watch mode during development
npm --workspace=packages/create-tool run test:watch

# 2. Tests auto-run on file changes
# 3. Press 'a' to run all tests
# 4. Press 'p' to filter by filename
# 5. Press 'q' to quit

# Final check before commit:
npm --workspace=packages/create-tool run test:coverage
```

**CI/CD Workflow:**

```bash
# In GitHub Actions / CI pipeline
npm --workspace=packages/create-tool run test:coverage -- --ci

# Flags:
# --ci: Optimized for CI environment
# --coverage: Generate coverage report
# --maxWorkers=2: Limit CPU usage
```

### JSDoc Documentation

[Source: architecture/coding-standards.md]

**Test Suite Documentation:**

```typescript
/**
 * Test suite for name conversion utilities.
 * Validates kebab-case, PascalCase, camelCase, and snake_case conversions.
 */
describe('Name Converters', () => {
  /**
   * Test toKebabCase function with various inputs.
   * Covers spaces, PascalCase, underscores, special chars, and edge cases.
   */
  describe('toKebabCase', () => {
    // Tests
  });
});
```

## Testing

### Running Tests

```bash
# Run all tests
npm --workspace=packages/create-tool run test

# Run tests in watch mode
npm --workspace=packages/create-tool run test:watch

# Run with coverage report
npm --workspace=packages/create-tool run test:coverage

# Run specific test file
npm --workspace=packages/create-tool run test -- name-converters.test.ts

# Run tests matching pattern
npm --workspace=packages/create-tool run test -- --testNamePattern="toKebabCase"

# Run tests with verbose output
npm --workspace=packages/create-tool run test:verbose
```

### Verification Checklist

After implementation:

- [ ] Jest and ts-jest installed
- [ ] jest.config.js created
- [ ] Test scripts added to package.json
- [ ] All utility functions have tests
- [ ] All validation functions have tests
- [ ] All templates have rendering tests
- [ ] Template loader has tests
- [ ] All tests pass
- [ ] Coverage ≥80% for all modules
- [ ] No skipped tests (fit/xit)

### Known Issues & Solutions

**Issue: Module not found errors**

```bash
# Solution: Ensure tsconfig.json includes test files
{
  "include": ["src/**/*"],  // Includes __tests__
}
```

**Issue: EJS templates not found in tests**

```typescript
// Solution: Use path.join with __dirname
const templatePath = path.join(__dirname, '../../templates/frontend/component.ts.ejs');
```

**Issue: Coverage report missing files**

```javascript
// Solution: Verify collectCoverageFrom pattern
collectCoverageFrom: [
  'src/**/*.ts', // All source files
  '!src/**/*.test.ts', // Exclude test files
  '!src/__tests__/**', // Exclude test directory
];
```

**Issue: Tests timeout for async operations**

```typescript
// Solution: Increase timeout or use fake timers
it('should render template', async () => {
  // ...
}, 10000); // 10 second timeout
```

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-10-24 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Debug Log References

(To be filled by dev agent)

### Completion Notes List

(To be filled by dev agent)

### File List

(To be filled by dev agent)

## QA Results

(To be filled by QA agent after story completion)
