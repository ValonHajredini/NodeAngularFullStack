# Story 31.1.3: EJS Template System & Templates

## Status

Draft

## Story

**As a** developer, **I want** an EJS template system with pre-designed templates, **so that** the
CLI can generate consistent, well-structured tool files.

## Acceptance Criteria

1. ✅ EJS installed and template loader implemented
2. ✅ Angular component template (standalone)
3. ✅ Angular service template with API integration
4. ✅ Angular routing template (lazy-loaded)
5. ✅ Backend controller template (Express)
6. ✅ Backend service template with repository
7. ✅ Backend repository template (PostgreSQL)
8. ✅ Backend routes template with validation
9. ✅ Shared TypeScript types template
10. ✅ Template rendering tested with sample data

## Tasks / Subtasks

- [ ] **Task 1: Install EJS** (AC: 1)
  - [ ] Install EJS: `npm install ejs --workspace=packages/create-tool`
  - [ ] Install TypeScript types:
        `npm install @types/ejs --save-dev --workspace=packages/create-tool`
  - [ ] Verify version ≥3.1.0
  - [ ] Update package.json dependencies

- [ ] **Task 2: Create template loader module** (AC: 1)
  - [ ] Create file: `packages/create-tool/src/templates/template-loader.ts`
  - [ ] Import EJS: `import ejs from 'ejs'`
  - [ ] Implement `loadTemplate(name: string)` function to read .ejs files
  - [ ] Implement `renderTemplate(template: string, data: any)` function
  - [ ] Add error handling for missing templates
  - [ ] Add JSDoc documentation

- [ ] **Task 3: Create template directory structure** (AC: 1-9)
  - [ ] Create directory: `packages/create-tool/src/templates/`
  - [ ] Create subdirectories:
    - [ ] `templates/frontend/` - Angular templates
    - [ ] `templates/backend/` - Express templates
    - [ ] `templates/shared/` - Shared type templates
    - [ ] `templates/config/` - Configuration files

- [ ] **Task 4: Create Angular component template** (AC: 2)
  - [ ] Create file: `templates/frontend/component.ts.ejs`
  - [ ] Template variables: `toolId`, `toolName`, `className`
  - [ ] Generate standalone component with:
    - [ ] `@Component` decorator with selector, template, styles
    - [ ] Imports: CommonModule, RouterModule
    - [ ] Empty constructor
    - [ ] `ngOnInit()` lifecycle hook
    - [ ] JSDoc comment with tool description
  - [ ] Create companion HTML template: `component.html.ejs`
  - [ ] Create companion CSS template: `component.css.ejs`

- [ ] **Task 5: Create Angular service template** (AC: 3)
  - [ ] Create file: `templates/frontend/service.ts.ejs`
  - [ ] Template variables: `toolId`, `toolName`, `apiBase`, `className`
  - [ ] Generate service with:
    - [ ] `@Injectable({ providedIn: 'root' })`
    - [ ] HttpClient injection
    - [ ] CRUD methods: `getAll()`, `getById()`, `create()`, `update()`, `delete()`
    - [ ] RxJS imports: Observable, catchError, map
    - [ ] Error handling with console.error
    - [ ] JSDoc comments for each method

- [ ] **Task 6: Create Angular routing template** (AC: 4)
  - [ ] Create file: `templates/frontend/routes.ts.ejs`
  - [ ] Template variables: `toolId`, `toolPath`, `componentName`
  - [ ] Generate route configuration:
    - [ ] Lazy-loaded route with `loadComponent`
    - [ ] Path: `/tools/${toolId}`
    - [ ] AuthGuard and ToolGuard imports
    - [ ] Data: `{ title: toolName }`
    - [ ] JSDoc comment

- [ ] **Task 7: Create backend controller template** (AC: 5)
  - [ ] Create file: `templates/backend/controller.ts.ejs`
  - [ ] Template variables: `toolId`, `toolName`, `serviceName`, `className`
  - [ ] Generate controller with:
    - [ ] Service dependency injection in constructor
    - [ ] Methods: `getAll`, `getById`, `create`, `update`, `delete`
    - [ ] Express types: Request, Response, NextFunction
    - [ ] Try-catch error handling in each method
    - [ ] HTTP status codes: 200, 201, 400, 404, 500
    - [ ] Response format: `{ message, data }` or `{ error }`
    - [ ] JSDoc comments

- [ ] **Task 8: Create backend service template** (AC: 6)
  - [ ] Create file: `templates/backend/service.ts.ejs`
  - [ ] Template variables: `toolId`, `toolName`, `repositoryName`, `className`
  - [ ] Generate service with:
    - [ ] Repository dependency injection
    - [ ] Methods: `getAll()`, `getById()`, `create()`, `update()`, `delete()`
    - [ ] Business logic validation placeholders
    - [ ] Error throwing with descriptive messages
    - [ ] JSDoc comments with @param, @returns, @throws

- [ ] **Task 9: Create backend repository template** (AC: 7)
  - [ ] Create file: `templates/backend/repository.ts.ejs`
  - [ ] Template variables: `toolId`, `toolName`, `tableName`, `className`
  - [ ] Generate repository with:
    - [ ] PostgreSQL pool dependency
    - [ ] Methods: `findAll()`, `findById()`, `create()`, `update()`, `delete()`
    - [ ] SQL queries with parameterized values (prevent injection)
    - [ ] Row mapping to TypeScript types
    - [ ] Error handling with database errors
    - [ ] JSDoc comments

- [ ] **Task 10: Create backend routes template** (AC: 8)
  - [ ] Create file: `templates/backend/routes.ts.ejs`
  - [ ] Template variables: `toolId`, `apiBase`, `controllerName`
  - [ ] Generate Express router with:
    - [ ] Router instantiation
    - [ ] Route definitions: GET, POST, PUT, DELETE
    - [ ] Auth middleware on all routes
    - [ ] Validation middleware on POST/PUT
    - [ ] Controller method bindings
    - [ ] Export router
    - [ ] JSDoc comment

- [ ] **Task 11: Create shared types template** (AC: 9)
  - [ ] Create file: `templates/shared/types.ts.ejs`
  - [ ] Template variables: `toolId`, `toolName`, `fields`
  - [ ] Generate TypeScript interfaces:
    - [ ] Main record interface (e.g., `InventoryRecord`)
    - [ ] Create input interface (e.g., `CreateInventoryInput`)
    - [ ] Update input interface (partial, e.g., `UpdateInventoryInput`)
    - [ ] JSDoc comments with field descriptions

- [ ] **Task 12: Create validation template** (AC: 8)
  - [ ] Create file: `templates/backend/validator.ts.ejs`
  - [ ] Template variables: `toolId`, `validationRules`
  - [ ] Generate express-validator middleware:
    - [ ] `validateCreate` validation chain
    - [ ] `validateUpdate` validation chain
    - [ ] Field validations with error messages
    - [ ] Export validators

- [ ] **Task 13: Create README template** (AC: 1-9)
  - [ ] Create file: `templates/config/README.md.ejs`
  - [ ] Template variables: `toolId`, `toolName`, `description`, `features`
  - [ ] Generate README sections:
    - [ ] Tool description
    - [ ] Features list
    - [ ] Installation steps
    - [ ] Usage examples
    - [ ] API endpoints table
    - [ ] Development notes

- [ ] **Task 14: Implement template rendering utility** (AC: 1, 10)
  - [ ] Create file: `packages/create-tool/src/utils/template-renderer.ts`
  - [ ] Implement `renderAllTemplates(metadata)` function
  - [ ] Map metadata to template variables
  - [ ] Load and render each template
  - [ ] Return object with rendered content for each file
  - [ ] Handle rendering errors gracefully

- [ ] **Task 15: Test templates with sample data** (AC: 10)
  - [ ] Create test file: `packages/create-tool/src/templates/__tests__/template-rendering.test.ts`
  - [ ] Create sample tool metadata
  - [ ] Render each template with sample data
  - [ ] Assert:
    - [ ] No EJS syntax errors
    - [ ] Generated code has correct imports
    - [ ] Class names match expected format
    - [ ] File paths correct
    - [ ] TypeScript syntax valid
  - [ ] Run tests: `npm --workspace=packages/create-tool run test`

- [ ] **Task 16: Manual template testing** (AC: 1, 10)
  - [ ] Create test script: `packages/create-tool/scripts/test-templates.ts`
  - [ ] Load sample metadata
  - [ ] Render all templates
  - [ ] Write output to temporary directory
  - [ ] Run TypeScript compiler on generated files
  - [ ] Verify no compilation errors
  - [ ] Clean up temp files

## Dev Notes

### Previous Story Insights

[Source: Story 31.1.2 Dev Agent Record]

- Inquirer.js prompts implemented successfully
- Tool metadata structure defined
- Validation utilities created (kebab-case, validators)
- Metadata includes: toolId, name, description, icon, permissions, features

### EJS Template Engine

[Source: architecture/tech-stack.md + PRD Epic 31.1]

**EJS (Embedded JavaScript Templates)** is a simple templating language for generating markup with
plain JavaScript.

**Why EJS:**

- Simple syntax: `<%= variable %>` for output, `<% code %>` for logic
- No complex DSL to learn
- Full JavaScript support in templates
- Widely used for code generation (Yeoman, generators)
- Excellent error messages

**Basic Syntax:**

```ejs
<%# Comment - not rendered %>

<% /* JavaScript code block */ %>
<% if (condition) { %>
  Content when true
<% } %>

<%= variable %>  <%# Escaped output %>
<%- html %>      <%# Unescaped output (dangerous, avoid) %>

<% items.forEach(item => { %>
  - <%= item.name %>
<% }); %>
```

**Example Component Template:**

```ejs
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * <%= toolName %> Component
 * <%= description %>
 */
@Component({
  selector: 'app-<%= toolId %>',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './<%= toolId %>.component.html',
  styleUrls: ['./<%= toolId %>.component.css'],
})
export class <%= className %>Component implements OnInit {
  constructor() {}

  ngOnInit(): void {
    console.log('<%= toolName %> component initialized');
  }
}
```

**Rendering:**

```typescript
import ejs from 'ejs';

const template = await fs.promises.readFile('component.ts.ejs', 'utf-8');
const rendered = ejs.render(template, {
  toolId: 'inventory-tracker',
  toolName: 'Inventory Tracker',
  description: 'Track inventory items',
  className: 'InventoryTracker',
});
```

### Template Directory Structure

[Source: architecture/source-tree.md + Story 31.1.1]

**Path:** `packages/create-tool/src/templates/`

**Complete Structure:**

```
packages/create-tool/src/templates/
├── frontend/
│   ├── component.ts.ejs           # Angular component
│   ├── component.html.ejs         # Component template
│   ├── component.css.ejs          # Component styles
│   ├── service.ts.ejs             # Angular service
│   └── routes.ts.ejs              # Route configuration
├── backend/
│   ├── controller.ts.ejs          # Express controller
│   ├── service.ts.ejs             # Business logic service
│   ├── repository.ts.ejs          # Database repository
│   ├── routes.ts.ejs              # Express routes
│   └── validator.ts.ejs           # express-validator middleware
├── shared/
│   └── types.ts.ejs               # TypeScript interfaces
├── config/
│   └── README.md.ejs              # Tool documentation
└── template-loader.ts             # Template loading utility
```

### Template Variables Schema

[Source: Story 31.1.2 metadata structure]

**Template Data Interface:**

```typescript
interface TemplateData {
  // Basic metadata
  toolId: string; // "inventory-tracker"
  toolName: string; // "Inventory Tracker"
  description: string; // "Track inventory items"
  icon: string; // "pi-box"
  version: string; // "1.0.0"

  // Generated identifiers
  className: string; // "InventoryTracker" (PascalCase)
  serviceName: string; // "inventoryTrackerService"
  repositoryName: string; // "inventoryTrackerRepository"
  tableName: string; // "inventory_tracker" (snake_case)

  // Paths
  route: string; // "/tools/inventory-tracker"
  apiBase: string; // "/api/tools/inventory-tracker"

  // Configuration
  permissions: string[]; // ["user", "admin"]
  features: {
    backend: boolean;
    database: boolean;
    service: boolean;
    component: boolean;
    tests: boolean;
    integrationTests: boolean;
  };

  // Timestamps
  createdAt: string; // ISO 8601 date
  author: string; // "Generated by create-tool CLI"
}
```

**Name Conversion Utilities:**

```typescript
// In utils/name-converters.ts
export function toPascalCase(str: string): string {
  // "inventory-tracker" → "InventoryTracker"
  return str
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

export function toCamelCase(str: string): string {
  // "inventory-tracker" → "inventoryTracker"
  const pascal = toPascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

export function toSnakeCase(str: string): string {
  // "inventory-tracker" → "inventory_tracker"
  return str.replace(/-/g, '_');
}
```

### Angular Component Template Pattern

[Source: architecture/frontend-architecture.md + existing components]

**Component Template (`frontend/component.ts.ejs`):**

````ejs
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { <%= className %>Service } from './<%= toolId %>.service';

/**
 * <%= toolName %> Component
 *
 * <%= description %>
 *
 * @example
 * ```html
 * <app-<%= toolId %>></app-<%= toolId %>>
 * ```
 */
@Component({
  selector: 'app-<%= toolId %>',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './<%= toolId %>.component.html',
  styleUrls: ['./<%= toolId %>.component.css'],
})
export class <%= className %>Component implements OnInit {
  /** Service for <%= toolName %> operations */
  constructor(private <%= serviceName %>: <%= className %>Service) {}

  /**
   * Component initialization lifecycle hook.
   * Loads initial data and sets up subscriptions.
   */
  ngOnInit(): void {
    this.loadData();
  }

  /**
   * Load <%= toolName %> data from backend.
   */
  private loadData(): void {
    console.log('<%= toolName %> component initialized');
    // TODO: Implement data loading
  }
}
````

**HTML Template (`frontend/component.html.ejs`):**

```ejs
<div class="<%= toolId %>-container">
  <h1><%= toolName %></h1>
  <p><%= description %></p>

  <!-- TODO: Implement <%= toolName %> UI -->
  <p>Component is working!</p>
</div>
```

**CSS Template (`frontend/component.css.ejs`):**

```ejs
.<%= toolId %>-container {
  padding: 1rem;
}

.<%= toolId %>-container h1 {
  font-size: 1.5rem;
  margin-bottom: 0.5rem;
}
```

### Angular Service Template Pattern

[Source: architecture/frontend-architecture.md + core/api patterns]

**Service Template (`frontend/service.ts.ejs`):**

```ejs
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { <%= className %>Record } from '@nodeangularfullstack/shared';

/**
 * <%= toolName %> Service
 *
 * Provides data access methods for <%= toolName %> operations.
 * Communicates with backend API at <%= apiBase %>.
 */
@Injectable({
  providedIn: 'root',
})
export class <%= className %>Service {
  private readonly apiUrl = '<%= apiBase %>';

  constructor(private http: HttpClient) {}

  /**
   * Get all <%= toolName %> records.
   * @returns Observable of <%= toolName %> records array
   */
  getAll(): Observable<<%= className %>Record[]> {
    return this.http.get<{ data: <%= className %>Record[] }>(`${this.apiUrl}`)
      .pipe(
        map(response => response.data),
        catchError(this.handleError)
      );
  }

  /**
   * Get single <%= toolName %> record by ID.
   * @param id - Record ID
   * @returns Observable of <%= toolName %> record
   */
  getById(id: string): Observable<<%= className %>Record> {
    return this.http.get<{ data: <%= className %>Record }>(`${this.apiUrl}/${id}`)
      .pipe(
        map(response => response.data),
        catchError(this.handleError)
      );
  }

  /**
   * Create new <%= toolName %> record.
   * @param data - Record data
   * @returns Observable of created record
   */
  create(data: Partial<<%= className %>Record>): Observable<<%= className %>Record> {
    return this.http.post<{ data: <%= className %>Record }>(this.apiUrl, data)
      .pipe(
        map(response => response.data),
        catchError(this.handleError)
      );
  }

  /**
   * Update existing <%= toolName %> record.
   * @param id - Record ID
   * @param data - Updated data
   * @returns Observable of updated record
   */
  update(id: string, data: Partial<<%= className %>Record>): Observable<<%= className %>Record> {
    return this.http.put<{ data: <%= className %>Record }>(`${this.apiUrl}/${id}`, data)
      .pipe(
        map(response => response.data),
        catchError(this.handleError)
      );
  }

  /**
   * Delete <%= toolName %> record.
   * @param id - Record ID
   * @returns Observable of void
   */
  delete(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`)
      .pipe(catchError(this.handleError));
  }

  /**
   * Handle HTTP errors.
   * @param error - HTTP error response
   * @returns Observable error
   */
  private handleError(error: HttpErrorResponse): Observable<never> {
    console.error('<%= className %> Service Error:', error);
    return throwError(() => new Error(error.message || 'Server error'));
  }
}
```

### Backend Controller Template Pattern

[Source: architecture/backend-architecture.md + Story 30.2.2]

**Controller Template (`backend/controller.ts.ejs`):**

```ejs
import { Request, Response, NextFunction } from 'express';
import { <%= className %>Service } from '../services/<%= toolId %>.service';

/**
 * <%= toolName %> Controller
 *
 * Handles HTTP requests for <%= toolName %> operations.
 * Delegates business logic to <%= className %>Service.
 */
export class <%= className %>Controller {
  constructor(private service: <%= className %>Service) {}

  /**
   * GET <%= apiBase %>
   * Get all <%= toolName %> records.
   */
  getAll = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const records = await this.service.getAll();
      res.json({
        message: '<%= toolName %> records retrieved successfully',
        data: records,
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * GET <%= apiBase %>/:id
   * Get <%= toolName %> record by ID.
   */
  getById = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { id } = req.params;
      const record = await this.service.getById(id);
      res.json({
        message: '<%= toolName %> record retrieved successfully',
        data: record,
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * POST <%= apiBase %>
   * Create new <%= toolName %> record.
   */
  create = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const record = await this.service.create(req.body);
      res.status(201).json({
        message: '<%= toolName %> record created successfully',
        data: record,
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * PUT <%= apiBase %>/:id
   * Update <%= toolName %> record.
   */
  update = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { id } = req.params;
      const record = await this.service.update(id, req.body);
      res.json({
        message: '<%= toolName %> record updated successfully',
        data: record,
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * DELETE <%= apiBase %>/:id
   * Delete <%= toolName %> record.
   */
  delete = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { id } = req.params;
      await this.service.delete(id);
      res.json({
        message: '<%= toolName %> record deleted successfully',
      });
    } catch (error) {
      next(error);
    }
  };
}
```

### Backend Service Template Pattern

[Source: architecture/backend-architecture.md + Story 30.2.1]

**Service Template (`backend/service.ts.ejs`):**

```ejs
import { <%= className %>Repository } from '../repositories/<%= toolId %>.repository';
import { <%= className %>Record, Create<%= className %>Input, Update<%= className %>Input } from '@nodeangularfullstack/shared';

/**
 * <%= toolName %> Service
 *
 * Business logic layer for <%= toolName %> operations.
 * Implements validation and domain rules.
 */
export class <%= className %>Service {
  constructor(private repository: <%= className %>Repository) {}

  /**
   * Get all <%= toolName %> records.
   * @returns Promise containing array of records
   */
  async getAll(): Promise<<%= className %>Record[]> {
    return await this.repository.findAll();
  }

  /**
   * Get <%= toolName %> record by ID.
   * @param id - Record ID
   * @returns Promise containing record
   * @throws {Error} When record not found
   */
  async getById(id: string): Promise<<%= className %>Record> {
    const record = await this.repository.findById(id);
    if (!record) {
      throw new Error(`<%= toolName %> record '${id}' not found`);
    }
    return record;
  }

  /**
   * Create new <%= toolName %> record.
   * @param input - Record data
   * @returns Promise containing created record
   * @throws {Error} When validation fails
   */
  async create(input: Create<%= className %>Input): Promise<<%= className %>Record> {
    // TODO: Add business logic validation
    return await this.repository.create(input);
  }

  /**
   * Update <%= toolName %> record.
   * @param id - Record ID
   * @param input - Updated data
   * @returns Promise containing updated record
   * @throws {Error} When record not found or validation fails
   */
  async update(id: string, input: Update<%= className %>Input): Promise<<%= className %>Record> {
    await this.getById(id); // Verify exists
    // TODO: Add business logic validation
    return await this.repository.update(id, input);
  }

  /**
   * Delete <%= toolName %> record.
   * @param id - Record ID
   * @returns Promise of void
   * @throws {Error} When record not found
   */
  async delete(id: string): Promise<void> {
    await this.getById(id); // Verify exists
    await this.repository.delete(id);
  }
}
```

### Backend Repository Template Pattern

[Source: architecture/backend-architecture.md + Story 30.1.2]

**Repository Template (`backend/repository.ts.ejs`):**

```ejs
import { Pool, QueryResult } from 'pg';
import { <%= className %>Record, Create<%= className %>Input, Update<%= className %>Input } from '@nodeangularfullstack/shared';

/**
 * <%= toolName %> Repository
 *
 * Data access layer for <%= tableName %> table.
 * Handles PostgreSQL queries and row mapping.
 */
export class <%= className %>Repository {
  constructor(private pool: Pool) {}

  /**
   * Find all <%= toolName %> records.
   * @returns Promise containing array of records
   */
  async findAll(): Promise<<%= className %>Record[]> {
    const query = 'SELECT * FROM <%= tableName %> ORDER BY created_at DESC';
    const result: QueryResult = await this.pool.query(query);
    return result.rows.map(this.mapRow);
  }

  /**
   * Find <%= toolName %> record by ID.
   * @param id - Record ID (UUID)
   * @returns Promise containing record or null
   */
  async findById(id: string): Promise<<%= className %>Record | null> {
    const query = 'SELECT * FROM <%= tableName %> WHERE id = $1';
    const result: QueryResult = await this.pool.query(query, [id]);
    return result.rows[0] ? this.mapRow(result.rows[0]) : null;
  }

  /**
   * Create new <%= toolName %> record.
   * @param input - Record data
   * @returns Promise containing created record
   */
  async create(input: Create<%= className %>Input): Promise<<%= className %>Record> {
    const query = `
      INSERT INTO <%= tableName %> (name, description, created_by)
      VALUES ($1, $2, $3)
      RETURNING *
    `;
    const values = [input.name, input.description || null, input.createdBy];
    const result: QueryResult = await this.pool.query(query, values);
    return this.mapRow(result.rows[0]);
  }

  /**
   * Update <%= toolName %> record.
   * @param id - Record ID
   * @param input - Updated data
   * @returns Promise containing updated record
   */
  async update(id: string, input: Update<%= className %>Input): Promise<<%= className %>Record> {
    const updates: string[] = [];
    const values: any[] = [];
    let paramCount = 1;

    if (input.name !== undefined) {
      updates.push(`name = $${paramCount++}`);
      values.push(input.name);
    }
    if (input.description !== undefined) {
      updates.push(`description = $${paramCount++}`);
      values.push(input.description);
    }

    updates.push(`updated_at = NOW()`);
    values.push(id);

    const query = `
      UPDATE <%= tableName %>
      SET ${updates.join(', ')}
      WHERE id = $${paramCount}
      RETURNING *
    `;

    const result: QueryResult = await this.pool.query(query, values);
    return this.mapRow(result.rows[0]);
  }

  /**
   * Delete <%= toolName %> record.
   * @param id - Record ID
   * @returns Promise of void
   */
  async delete(id: string): Promise<void> {
    const query = 'DELETE FROM <%= tableName %> WHERE id = $1';
    await this.pool.query(query, [id]);
  }

  /**
   * Map database row to TypeScript record.
   * @param row - PostgreSQL row
   * @returns Typed record
   */
  private mapRow(row: any): <%= className %>Record {
    return {
      id: row.id,
      name: row.name,
      description: row.description,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      createdBy: row.created_by,
    };
  }
}
```

### Shared Types Template Pattern

[Source: Story 30.1.1 types + packages/shared patterns]

**Types Template (`shared/types.ts.ejs`):**

```ejs
/**
 * <%= toolName %> Type Definitions
 *
 * Shared TypeScript interfaces for <%= toolName %> domain.
 * Used by both frontend and backend for type safety.
 */

/**
 * <%= toolName %> database record.
 * Represents a single <%= toolName.toLowerCase() %> entry.
 */
export interface <%= className %>Record {
  /** Unique identifier (UUID) */
  id: string;

  /** <%= toolName %> name */
  name: string;

  /** Optional description */
  description?: string;

  /** Creation timestamp */
  createdAt: Date;

  /** Last update timestamp */
  updatedAt: Date;

  /** User who created the record (UUID) */
  createdBy: string;
}

/**
 * Input for creating new <%= toolName %> record.
 */
export interface Create<%= className %>Input {
  /** <%= toolName %> name (required, 3-255 chars) */
  name: string;

  /** Optional description (max 500 chars) */
  description?: string;

  /** User creating the record (UUID) */
  createdBy: string;
}

/**
 * Input for updating <%= toolName %> record.
 * All fields optional (partial update).
 */
export interface Update<%= className %>Input {
  /** Updated name */
  name?: string;

  /** Updated description */
  description?: string;
}
```

### Template Rendering Workflow

[Source: Story implementation plan]

**Template Loader Implementation:**

```typescript
// packages/create-tool/src/templates/template-loader.ts
import fs from 'fs/promises';
import path from 'path';
import ejs from 'ejs';

/**
 * Load EJS template file from templates directory.
 * @param templatePath - Relative path to template (e.g., "frontend/component.ts.ejs")
 * @returns Promise containing template content
 */
export async function loadTemplate(templatePath: string): Promise<string> {
  const fullPath = path.join(__dirname, templatePath);
  try {
    return await fs.readFile(fullPath, 'utf-8');
  } catch (error) {
    throw new Error(`Template not found: ${templatePath}`);
  }
}

/**
 * Render EJS template with data.
 * @param template - EJS template string
 * @param data - Template variables
 * @returns Rendered content
 */
export function renderTemplate(template: string, data: any): string {
  try {
    return ejs.render(template, data, {
      rmWhitespace: false, // Preserve formatting
      escape: (str) => str, // Don't escape (we control content)
    });
  } catch (error) {
    throw new Error(`Template rendering failed: ${error.message}`);
  }
}

/**
 * Load and render template in one step.
 * @param templatePath - Relative template path
 * @param data - Template variables
 * @returns Promise containing rendered content
 */
export async function renderTemplateFile(templatePath: string, data: any): Promise<string> {
  const template = await loadTemplate(templatePath);
  return renderTemplate(template, data);
}
```

### Dependencies on Previous Stories

**Story 31.1.1 Required:**

- CLI package structure exists
- TypeScript compilation working

**Story 31.1.2 Required:**

- Tool metadata structure defined
- Inquirer prompts collect all needed data
- Validation utilities available (kebab-case, etc.)

**Epic 30 Reference:**

- Backend patterns from Stories 30.1.2, 30.2.1, 30.2.2
- Type definitions from Story 30.1.1
- Validation patterns from Story 30.2.3

### JSDoc Documentation Standards

[Source: architecture/coding-standards.md]

All generated code MUST include JSDoc comments:

**Template JSDoc Pattern:**

```ejs
/**
 * <%= toolName %> <%= entityType %>
 *
 * <%= description %>
 *
 * @<%= authorTag %> Generated by create-tool CLI
 * @<%= dateTag %> <%= new Date().toISOString().split('T')[0] %>
 */
```

### Testing Strategy

[Source: architecture/testing-strategy.md]

**Unit Tests for Template Rendering:**

- Test each template renders without EJS errors
- Test variable substitution correct
- Test generated TypeScript compiles
- Test edge cases (empty description, special characters)

**Manual Testing:**

- Generate sample tool
- Compile TypeScript (check no errors)
- Run ESLint on generated code
- Verify file structure matches expected

## Testing

### Manual Testing

**Test Template Rendering:**

```bash
# 1. Create test script
cat > packages/create-tool/scripts/test-templates.ts << 'EOF'
import { renderTemplateFile } from '../src/templates/template-loader';
import { toPascalCase, toCamelCase, toSnakeCase } from '../src/utils/name-converters';

const testData = {
  toolId: 'test-tool',
  toolName: 'Test Tool',
  description: 'A test tool for template validation',
  icon: 'pi-box',
  className: toPascalCase('test-tool'),
  serviceName: toCamelCase('test-tool'),
  tableName: toSnakeCase('test-tool'),
  route: '/tools/test-tool',
  apiBase: '/api/tools/test-tool',
  permissions: ['user'],
  features: {
    backend: true,
    database: true,
    service: true,
    component: true,
  },
};

async function testTemplates() {
  // Test each template
  const templates = [
    'frontend/component.ts.ejs',
    'frontend/service.ts.ejs',
    'backend/controller.ts.ejs',
    'backend/service.ts.ejs',
    'backend/repository.ts.ejs',
    'shared/types.ts.ejs',
  ];

  for (const template of templates) {
    try {
      const rendered = await renderTemplateFile(template, testData);
      console.log(`✅ ${template} rendered successfully (${rendered.length} chars)`);
    } catch (error) {
      console.error(`❌ ${template} failed:`, error.message);
    }
  }
}

testTemplates();
EOF

# 2. Run test script
npm run build --workspace=packages/create-tool
node packages/create-tool/dist/scripts/test-templates.js

# 3. Expected output:
# ✅ frontend/component.ts.ejs rendered successfully
# ✅ frontend/service.ts.ejs rendered successfully
# ✅ backend/controller.ts.ejs rendered successfully
# ... etc
```

**Test TypeScript Compilation:**

```bash
# 1. Generate files to temp directory
mkdir -p /tmp/test-tool-output

# 2. Render templates and write to temp dir
# (Use test script from above, modified to write files)

# 3. Compile generated TypeScript
npx tsc --noEmit /tmp/test-tool-output/**/*.ts

# 4. Should have no compilation errors
```

### Verification Checklist

After implementation:

- [ ] EJS installed with TypeScript types
- [ ] Template loader module created
- [ ] All 9 template files created
- [ ] Templates render without EJS errors
- [ ] Generated code has correct syntax
- [ ] Variable substitution works correctly
- [ ] JSDoc comments included
- [ ] TypeScript compiles without errors
- [ ] Test script passes for all templates

### Known Issues & Solutions

**Issue: EJS whitespace control**

```ejs
<%# Issue: Extra blank lines in output %>
<% if (condition) { %>
  Content
<% } %>

<%# Solution: Use -%> to trim %>
<% if (condition) { -%>
  Content
<% } -%>
```

**Issue: Missing template file**

```typescript
// Solution: Check template path is relative to __dirname
const templatePath = path.join(__dirname, 'frontend/component.ts.ejs');
// NOT: './frontend/component.ts.ejs' (relative to cwd)
```

**Issue: EJS syntax in generated code**

```ejs
<%# Issue: Want literal <% in output %>
Output: <%= '<% code %>' %> <%# Will render as: <% code %> %>

<%# Solution: Escape with <%% %>
Output: <%%= '<% code %>' %%> <%# Will render with EJS tag %>
```

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-10-24 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Debug Log References

(To be filled by dev agent)

### Completion Notes List

(To be filled by dev agent)

### File List

(To be filled by dev agent)

## QA Results

(To be filled by QA agent after story completion)
