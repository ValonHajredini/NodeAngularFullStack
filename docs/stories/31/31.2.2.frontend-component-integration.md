# Story 31.2.2: Frontend Component Integration & Route Registration

## Status

Approved

**As a** developer, **I want** the CLI to automatically register generated components in Angular
routing and provide integration helpers, **so that** new tools are immediately accessible in the
application.

## Acceptance Criteria

1. ✅ Route file generation with lazy-loading configuration
2. ✅ Auto-import generated component in routing
3. ✅ Guard integration (AuthGuard, ToolGuard)
4. ✅ Navigation menu helper file generated
5. ✅ Instructions for manual app.routes.ts integration
6. ✅ Service integration with HttpClient configured
7. ✅ Component includes loading/error states
8. ✅ Responsive layout classes applied

## Tasks / Subtasks

- [ ] **Task 1: Enhance component template** (AC: 7, 8)
  - [ ] Update `templates/frontend/component.ts.ejs`
  - [ ] Add loading state: `loading = signal<boolean>(false)`
  - [ ] Add error state: `error = signal<string | null>(null)`
  - [ ] Add data signal: `items = signal<${className}Record[]>([])`
  - [ ] Inject service in constructor
  - [ ] Implement `loadData()` method with loading/error handling
  - [ ] Add OnDestroy lifecycle hook for cleanup
  - [ ] Add JSDoc documentation

- [ ] **Task 2: Enhance component HTML template** (AC: 7, 8)
  - [ ] Update `templates/frontend/component.html.ejs`
  - [ ] Add PrimeNG container classes: `<div class="p-3">`
  - [ ] Add loading indicator: `@if (loading()) { <p-progressSpinner /> }`
  - [ ] Add error display: `@if (error()) { <p-message severity="error" [text]="error()" /> }`
  - [ ] Add empty state: `@if (items().length === 0) { <p-message severity="info" /> }`
  - [ ] Add data grid: `@for (item of items(); track item.id) { ... }`
  - [ ] Use responsive classes: `lg:col-4 md:col-6 col-12`
  - [ ] Include PrimeNG component imports

- [ ] **Task 3: Create route configuration file** (AC: 1, 2, 3)
  - [ ] Create template: `templates/frontend/tool.routes.ts.ejs`
  - [ ] Generate standalone route definition
  - [ ] Use `loadComponent` for lazy loading
  - [ ] Add path: `/tools/${toolId}`
  - [ ] Add guards: `canActivate: [AuthGuard, ToolGuard]`
  - [ ] Add data: `{ title: toolName, permissions: [...] }`
  - [ ] Include imports: Route, AuthGuard, ToolGuard
  - [ ] Export const with route configuration

- [ ] **Task 4: Create navigation menu helper** (AC: 4)
  - [ ] Create template: `templates/frontend/menu-item.ts.ejs`
  - [ ] Generate MenuItem interface object
  - [ ] Include properties:
    - [ ] `label`: Tool name
    - [ ] `icon`: PrimeNG icon
    - [ ] `routerLink`: Tool route
    - [ ] `visible`: Permission-based visibility function
  - [ ] Export as const
  - [ ] Add JSDoc with integration instructions

- [ ] **Task 5: Generate integration instructions** (AC: 5)
  - [ ] Create template: `templates/frontend/INTEGRATION.md.ejs`
  - [ ] Include step-by-step integration guide:
    - [ ] Import route in app.routes.ts
    - [ ] Add menu item to sidebar/navbar
    - [ ] Register tool in tool registry
    - [ ] Build shared types
  - [ ] Include code snippets for each step
  - [ ] Add troubleshooting section

- [ ] **Task 6: Enhance service template** (AC: 6)
  - [ ] Update `templates/frontend/service.ts.ejs`
  - [ ] Add signal-based state management
  - [ ] Add loading$ signal
  - [ ] Add error$ signal
  - [ ] Add data$ signal (computed from API responses)
  - [ ] Include retry logic with RxJS operators
  - [ ] Add caching with shareReplay
  - [ ] Add JSDoc comments

- [ ] **Task 7: Add PrimeNG imports to component** (AC: 7, 8)
  - [ ] Import ProgressSpinnerModule
  - [ ] Import MessageModule
  - [ ] Import ButtonModule (for actions)
  - [ ] Import CardModule (for layout)
  - [ ] Import DataViewModule (for data display)
  - [ ] Import ToastModule (for notifications)
  - [ ] Add to component imports array

- [ ] **Task 8: Create component spec file** (AC: 7)
  - [ ] Create template: `templates/frontend/component.spec.ts.ejs`
  - [ ] Generate basic Jasmine test suite
  - [ ] Test component creation
  - [ ] Test service injection
  - [ ] Mock service responses
  - [ ] Test loading state
  - [ ] Test error state
  - [ ] Test data rendering

- [ ] **Task 9: Generate service spec file** (AC: 6)
  - [ ] Create template: `templates/frontend/service.spec.ts.ejs`
  - [ ] Generate HttpClient test configuration
  - [ ] Mock HttpTestingController
  - [ ] Test getAll() method
  - [ ] Test create() method
  - [ ] Test error handling
  - [ ] Test retry logic

- [ ] **Task 10: Update file generator** (AC: 1-8)
  - [ ] Add new templates to file generator
  - [ ] Generate tool.routes.ts
  - [ ] Generate menu-item.ts
  - [ ] Generate INTEGRATION.md
  - [ ] Generate component.spec.ts
  - [ ] Generate service.spec.ts
  - [ ] Update file count reporting

- [ ] **Task 11: Print integration instructions** (AC: 5)
  - [ ] After successful generation, display:
    - [ ] Path to route file: "Route: apps/web/src/app/features/tools/{toolId}/{toolId}.routes.ts"
    - [ ] Import statement for app.routes.ts
    - [ ] Menu item import statement
    - [ ] Next steps for manual integration
  - [ ] Highlight integration file path

- [ ] **Task 12: Test frontend integration** (AC: 1-8)
  - [ ] Generate sample tool
  - [ ] Manually integrate route in app.routes.ts
  - [ ] Add menu item to navigation
  - [ ] Build project: `npm run build --workspace=apps/web`
  - [ ] Start dev server: `npm run dev --workspace=apps/web`
  - [ ] Navigate to tool route
  - [ ] Verify component loads
  - [ ] Verify loading state displays
  - [ ] Verify error handling works
  - [ ] Verify responsive layout on mobile

## Dev Notes

### Previous Story Insights

[Source: Story 31.2.1 Dev Agent Record]

- File generation orchestrator created
- Directory structure implemented
- Templates rendered and written successfully
- Conflict detection working

### Angular 20+ Standalone Components

[Source: architecture/frontend-architecture.md + Angular 20 docs]

**Standalone Component Pattern:**

```typescript
import { Component, OnInit, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { MessageModule } from 'primeng/message';
import { <%= className %>Service } from './services/<%= toolId %>.service';
import { <%= className %>Record } from '@nodeangularfullstack/shared';

/**
 * <%= toolName %> Component
 *
 * <%= description %>
 *
 * Features:
 * - Loading state with spinner
 * - Error handling with messages
 * - Responsive grid layout
 */
@Component({
  selector: 'app-<%= toolId %>',
  standalone: true,
  imports: [
    CommonModule,
    ProgressSpinnerModule,
    MessageModule,
    // Add more PrimeNG modules as needed
  ],
  templateUrl: './<%= toolId %>.component.html',
  styleUrls: ['./<%= toolId %>.component.css'],
})
export class <%= className %>Component implements OnInit {
  // Signals for reactive state
  loading = signal<boolean>(false);
  error = signal<string | null>(null);
  items = signal<<%= className %>Record[]>([]);

  constructor(private <%= serviceName %>: <%= className %>Service) {}

  ngOnInit(): void {
    this.loadData();
  }

  /**
   * Load <%= toolName %> data from backend.
   */
  private async loadData(): Promise<void> {
    this.loading.set(true);
    this.error.set(null);

    this.<%= serviceName %>.getAll().subscribe({
      next: (data) => {
        this.items.set(data);
        this.loading.set(false);
      },
      error: (err) => {
        this.error.set(err.message || 'Failed to load data');
        this.loading.set(false);
      },
    });
  }
}
```

### Component HTML Template with PrimeNG

[Source: architecture/ui-patterns.md + PrimeNG docs]

**Responsive Layout Pattern:**

```html
<!-- <%= toolId %>.component.html -->
<div class="<%= toolId %>-container p-3">
  <!-- Header -->
  <div class="flex justify-content-between align-items-center mb-3">
    <h1 class="text-2xl font-bold"><%= toolName %></h1>
    <p-button label="New" icon="pi pi-plus" (click)="onCreate()"></p-button>
  </div>

  <!-- Loading State -->
  @if (loading()) {
  <div class="flex justify-content-center p-5">
    <p-progressSpinner></p-progressSpinner>
  </div>
  }

  <!-- Error State -->
  @if (error()) {
  <p-message severity="error" [text]="error()"></p-message>
  }

  <!-- Empty State -->
  @if (!loading() && !error() && items().length === 0) {
  <p-message
    severity="info"
    text="No <%= toolName.toLowerCase() %> items found. Create your first one!"
  ></p-message>
  }

  <!-- Data Grid (Responsive) -->
  @if (!loading() && !error() && items().length > 0) {
  <div class="grid">
    @for (item of items(); track item.id) {
    <div class="col-12 md:col-6 lg:col-4">
      <p-card>
        <h3>{{ item.name }}</h3>
        <p>{{ item.description }}</p>
        <div class="flex gap-2 mt-2">
          <p-button label="Edit" icon="pi pi-pencil" size="small"></p-button>
          <p-button label="Delete" icon="pi pi-trash" size="small" severity="danger"></p-button>
        </div>
      </p-card>
    </div>
    }
  </div>
  }
</div>
```

### Route Configuration with Lazy Loading

[Source: architecture/frontend-architecture.md + Angular routing]

**Route Template (`templates/frontend/tool.routes.ts.ejs`):**

````ejs
import { Route } from '@angular/router';
import { AuthGuard } from '@app/core/guards/auth.guard';
import { ToolGuard } from '@app/core/guards/tool.guard';

/**
 * <%= toolName %> Routes
 *
 * Lazy-loaded route configuration for <%= toolName %> tool.
 *
 * Integration:
 * ```typescript
 * // In apps/web/src/app/app.routes.ts
 * import { <%= toolId %>Routes } from './features/tools/<%= toolId %>/<%= toolId %>.routes';
 *
 * export const routes: Routes = [
 *   // ... other routes
 *   ...<%= toolId %>Routes,
 * ];
 * ```
 */
export const <%= toolId %>Routes: Route[] = [
  {
    path: 'tools/<%= toolId %>',
    loadComponent: () =>
      import('./<%= toolId %>.component').then(m => m.<%= className %>Component),
    canActivate: [AuthGuard, ToolGuard],
    data: {
      title: '<%= toolName %>',
      permissions: <%= JSON.stringify(permissions) %>,
      icon: '<%= icon %>',
    },
  },
];
````

**Integration in app.routes.ts:**

```typescript
// apps/web/src/app/app.routes.ts
import { Routes } from '@angular/router';
import { <%= toolId %>Routes } from './features/tools/<%= toolId %>/<%= toolId %>.routes';

export const routes: Routes = [
  // ... existing routes
  ...<%= toolId %>Routes,  // ← Add generated routes
];
```

### Navigation Menu Integration

[Source: architecture/ui-patterns.md + PrimeNG Menu]

**Menu Item Template (`templates/frontend/menu-item.ts.ejs`):**

````ejs
import { MenuItem } from 'primeng/api';

/**
 * <%= toolName %> Menu Item
 *
 * PrimeNG MenuItem configuration for <%= toolName %> tool.
 *
 * Integration:
 * ```typescript
 * // In your menu/sidebar component
 * import { <%= toolId %>MenuItem } from '@app/features/tools/<%= toolId %>/menu-item';
 *
 * this.menuItems = [
 *   // ... other items
 *   <%= toolId %>MenuItem,
 * ];
 * ```
 */
export const <%= toolId %>MenuItem: MenuItem = {
  label: '<%= toolName %>',
  icon: '<%= icon %>',
  routerLink: ['/tools/<%= toolId %>'],
  visible: true, // TODO: Add permission check
};
````

### Service with Signal State Management

[Source: Angular 20 signals + RxJS patterns]

**Enhanced Service Template:**

```ejs
import { Injectable, signal, computed } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { tap, catchError, retry, shareReplay } from 'rxjs/operators';

/**
 * <%= toolName %> Service
 *
 * Provides data access with signal-based state management.
 */
@Injectable({
  providedIn: 'root',
})
export class <%= className %>Service {
  private readonly apiUrl = '<%= apiBase %>';

  // State signals
  private loading = signal<boolean>(false);
  private error = signal<string | null>(null);
  private cache = signal<<%= className %>Record[]>([]);

  // Public readonly signals
  readonly loading$ = this.loading.asReadonly();
  readonly error$ = this.error.asReadonly();
  readonly items$ = this.cache.asReadonly();

  // Computed signals
  readonly hasData$ = computed(() => this.cache().length > 0);

  constructor(private http: HttpClient) {}

  /**
   * Get all <%= toolName %> records.
   * Results are cached and replayed to new subscribers.
   */
  getAll(): Observable<<%= className %>Record[]> {
    this.loading.set(true);
    this.error.set(null);

    return this.http.get<{ data: <%= className %>Record[] }>(this.apiUrl).pipe(
      retry(2), // Retry failed requests twice
      tap(response => {
        this.cache.set(response.data);
        this.loading.set(false);
      }),
      catchError(err => {
        this.error.set(err.message);
        this.loading.set(false);
        throw err;
      }),
      shareReplay(1) // Cache latest emission
    );
  }

  // ... other methods
}
```

### Component Testing Template

[Source: architecture/testing-strategy.md + Angular testing]

**Component Spec Template:**

```ejs
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { HttpClientTestingModule } from '@angular/common/http/testing';
import { of, throwError } from 'rxjs';
import { <%= className %>Component } from './<%= toolId %>.component';
import { <%= className %>Service } from './services/<%= toolId %>.service';

describe('<%= className %>Component', () => {
  let component: <%= className %>Component;
  let fixture: ComponentFixture<<%= className %>Component>;
  let service: jasmine.SpyObj<<%= className %>Service>;

  beforeEach(async () => {
    const serviceSpy = jasmine.createSpyObj('<%= className %>Service', ['getAll']);

    await TestBed.configureTestingModule({
      imports: [<%= className %>Component, HttpClientTestingModule],
      providers: [
        { provide: <%= className %>Service, useValue: serviceSpy },
      ],
    }).compileComponents();

    fixture = TestBed.createComponent(<%= className %>Component);
    component = fixture.componentInstance;
    service = TestBed.inject(<%= className %>Service) as jasmine.SpyObj<<%= className %>Service>;
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should load data on init', () => {
    const mockData = [{ id: '1', name: 'Test' }];
    service.getAll.and.returnValue(of(mockData));

    fixture.detectChanges(); // Triggers ngOnInit

    expect(service.getAll).toHaveBeenCalled();
    expect(component.items()).toEqual(mockData);
    expect(component.loading()).toBe(false);
  });

  it('should handle errors', () => {
    service.getAll.and.returnValue(throwError(() => new Error('API Error')));

    fixture.detectChanges();

    expect(component.error()).toBe('API Error');
    expect(component.loading()).toBe(false);
  });
});
```

### Integration Instructions Template

[Source: Best practices for generated code]

**INTEGRATION.md Template:**

```markdown
# <%= toolName %> Integration Guide

This guide explains how to integrate the generated <%= toolName %> tool into your application.

## 1. Build Shared Types

First, build the shared types package to make the <%= className %>Record types available:

\`\`\`bash npm run build:shared \`\`\`

## 2. Register Route

Add the generated route to your application's routing configuration:

\`\`\`typescript // apps/web/src/app/app.routes.ts import { <%= toolId %>Routes } from
'./features/tools/<%= toolId %>/<%= toolId %>.routes';

export const routes: Routes = [ // ... existing routes ...<%= toolId %>Routes, // ← Add this line ];
\`\`\`

## 3. Add Navigation Menu Item

Add the tool to your navigation menu:

\`\`\`typescript // In your menu/sidebar component (e.g.,
apps/web/src/app/core/layout/sidebar/sidebar.component.ts) import { <%= toolId %>MenuItem } from
'@app/features/tools/<%= toolId %>/menu-item';

// Add to your menu items array this.menuItems = [ // ... existing items <%= toolId %>MenuItem, // ←
Add this ]; \`\`\`

## 4. Create Database Table

Create a migration for the <%= toolName %> database table:

\`\`\`bash

# Create migration file

npm --workspace=apps/api run db:migration:create <%= tableName %>\_table

# Edit the migration file and add:

# CREATE TABLE <%= tableName %> (

# id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

# name VARCHAR(255) NOT NULL,

# description TEXT,

# created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

# updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

# created_by UUID REFERENCES users(id)

# );

# Run migration

npm --workspace=apps/api run db:migrate \`\`\`

## 5. Register Tool with Platform

Register the tool in the tool registry:

\`\`\`bash curl -X POST http://localhost:3000/api/tools/register \
 -H "Content-Type: application/json" \
 -H "Authorization: Bearer YOUR_TOKEN" \
 -d '{ "toolId": "<%= toolId %>", "name": "<%= toolName %>", "version": "1.0.0", "route":
"/tools/<%= toolId %>", "apiBase": "/api/tools/<%= toolId %>", "permissions": <%=
JSON.stringify(permissions) %>, "manifestJson": { "id": "<%= toolId %>", "name": "<%= toolName %>",
"description": "<%= description %>" } }' \`\`\`

## 6. Start Development

Start the development servers:

\`\`\`bash npm start \`\`\`

Visit http://localhost:4200/tools/<%= toolId %> to see your tool!

## Troubleshooting

### TypeScript Errors

If you see TypeScript errors about missing types: \`\`\`bash npm run build:shared npm run typecheck
\`\`\`

### Component Not Loading

1. Check that routes are properly imported in app.routes.ts
2. Verify AuthGuard and ToolGuard are configured
3. Check browser console for errors

### API Errors

1. Ensure backend service is running (port 3000)
2. Check database connection
3. Verify API endpoints are registered
4. Check network tab for HTTP errors \`\`\`
```

### File Generator Updates

[Source: Story 31.2.1 file generator]

**Add New Templates to Generator:**

```typescript
// In src/generator/file-generator.ts
const fileMap = {
  // ... existing mappings

  // New frontend files
  [structure.frontend.files.routes]: rendered.toolRoutes,
  [structure.frontend.files.menuItem]: rendered.menuItem,
  [structure.frontend.files.integration]: rendered.integrationMd,
  [structure.frontend.files.componentSpec]: rendered.componentSpec,
  [structure.frontend.files.serviceSpec]: rendered.serviceSpec,
};
```

### Dependencies on Previous Stories

**Story 31.1.1-31.1.4 Required:**

- CLI package and templates ready
- Prompts collect metadata
- Templates render correctly
- Testing framework in place

**Story 31.2.1 Required:**

- File generator orchestrator exists
- Directory structure defined
- File writing utilities available

### JSDoc Documentation

[Source: architecture/coding-standards.md]

All generated files must include comprehensive JSDoc comments explaining:

- Purpose of the file
- How to use/integrate it
- Example code
- Related files

## Testing

### Manual Testing

**Test Frontend Integration:**

```bash
# 1. Generate tool with all frontend features
node packages/create-tool/dist/index.js sample-tool

# 2. Build shared types
npm run build:shared

# 3. Integrate route manually
# Edit apps/web/src/app/app.routes.ts
# Add: import { sampleToolRoutes } from './features/tools/sample-tool/sample-tool.routes';
# Add: ...sampleToolRoutes,

# 4. Build frontend
npm run build --workspace=apps/web

# 5. Start dev server
npm run dev --workspace=apps/web

# 6. Navigate to tool
# Open: http://localhost:4200/tools/sample-tool

# 7. Verify displays:
# - Component loads
# - Loading spinner appears briefly
# - Error handling works (test by stopping backend)
# - Responsive layout on mobile (resize browser)

# 8. Check generated files:
cat apps/web/src/app/features/tools/sample-tool/sample-tool.routes.ts
cat apps/web/src/app/features/tools/sample-tool/menu-item.ts
cat apps/web/src/app/features/tools/sample-tool/INTEGRATION.md
cat apps/web/src/app/features/tools/sample-tool/sample-tool.component.spec.ts
```

### Verification Checklist

After implementation:

- [ ] Component template enhanced with signals
- [ ] HTML template has loading/error/empty states
- [ ] Route configuration file generated
- [ ] Menu item helper generated
- [ ] Integration instructions created
- [ ] Component spec file generated
- [ ] Service spec file generated
- [ ] PrimeNG modules imported correctly
- [ ] Responsive classes applied
- [ ] Component compiles without errors
- [ ] Component renders in browser
- [ ] Navigation works
- [ ] Loading state displays
- [ ] Error handling works

### Known Issues & Solutions

**Issue: PrimeNG styles not loading**

```typescript
// Solution: Ensure PrimeNG theme imported in styles.css
@import "primeng/resources/themes/lara-light-blue/theme.css";
@import "primeng/resources/primeng.css";
```

**Issue: Signals not updating UI**

```typescript
// Solution: Ensure ChangeDetection strategy is correct
// Signals automatically trigger change detection in OnPush mode
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush, // Optional with signals
})
```

**Issue: Route not found**

```typescript
// Solution: Verify route export syntax
export const myToolRoutes: Route[] = [
  /* ... */
];
// NOT: export const routes = [ /* ... */ ];
```

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-10-24 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

(To be filled by dev agent)

### Debug Log References

(To be filled by dev agent)

### Completion Notes List

(To be filled by dev agent)

### File List

(To be filled by dev agent)

## QA Results

(To be filled by QA agent after story completion)
