# Story 30.1.2: Tool Registry Repository Implementation

## Status

Done

## Story

**As a** backend developer, **I want** a repository class for tool registry data access, **so that**
business logic doesn't directly access the database.

## Acceptance Criteria

1. ✅ `ToolRegistryRepository` class implements CRUD operations
2. ✅ Methods: `findAll()`, `findById()`, `create()`, `update()`, `delete()`
3. ✅ Query methods: `findByStatus()`, `findExported()`, `search()`
4. ✅ Proper error handling and validation
5. ✅ Unit tests with ≥90% coverage

## Tasks / Subtasks

- [x] **Task 1: Create ToolRegistryRepository class with CRUD methods** (AC: 1, 2)
  - [x] Create `tool-registry.repository.ts` in `apps/api/src/repositories/`
  - [x] Import Pool from pg and ToolRegistryRecord types from shared package
  - [x] Implement constructor accepting Pool instance
  - [x] Implement `findAll()` - returns all tools ordered by created_at DESC
  - [x] Implement `findById(toolId: string)` - returns tool by tool_id or null
  - [x] Implement `create(input: CreateToolInput)` - inserts new tool, returns record
  - [x] Implement `update(toolId: string, input: UpdateToolInput)` - updates tool, returns record
  - [x] Implement `delete(toolId: string)` - hard delete (no is_active column in schema)
  - [x] Create private `mapRowToRecord(row: any)` helper to map DB rows to TypeScript records

- [x] **Task 2: Implement specialized query methods** (AC: 3)
  - [x] Implement `findByStatus(status: string)` - filters by status, ordered by name ASC
  - [x] Implement `findExported()` - returns tools where is_exported = true
  - [x] Implement `search(searchTerm: string)` - ILIKE search on name and description
  - [x] Implement `findNonExported()` - returns tools where is_exported = false (for dashboard)

- [x] **Task 3: Add error handling and validation** (AC: 4)
  - [x] Wrap database queries in try-catch blocks
  - [x] Throw descriptive errors for common cases (tool not found, duplicate tool_id)
  - [x] Add input validation in create() for required fields
  - [x] Handle null/undefined edge cases gracefully
  - [x] Use console.error for error logging (Winston not yet implemented)

- [x] **Task 4: Add JSDoc documentation** (AC: 1-4)
  - [x] Add class-level JSDoc describing repository responsibility
  - [x] Document each public method with @param, @returns, @throws tags
  - [x] Include usage examples in JSDoc for complex methods
  - [x] Follow JSDoc standards from coding-standards.md

- [x] **Task 5: Write comprehensive unit tests** (AC: 5)
  - [x] Create `tool-registry.repository.test.ts` in `apps/api/tests/unit/repositories/`
  - [x] Mock pg.Pool using Jest mocks
  - [x] Test findAll() - verify query and result mapping
  - [x] Test findById() - both found and not found cases
  - [x] Test create() - verify INSERT query structure and parameterization
  - [x] Test update() - verify dynamic SET clause and error when not found
  - [x] Test delete() - verify DELETE query
  - [x] Test findByStatus() - verify WHERE clause and ordering
  - [x] Test search() - verify ILIKE query with wildcard placeholders
  - [x] Test edge cases: null values, empty arrays, SQL injection attempts
  - [x] Achieve 100% test coverage (33 tests passing)

- [x] **Task 6: Export repository from index** (AC: 1)
  - [x] Create `apps/api/src/repositories/index.ts`
  - [x] Export `ToolRegistryRepository` for use in service layer

## Dev Notes

### Repository Pattern Architecture

[Source: architecture/backend-architecture.md#data-access-layer]

**Base Repository Pattern:** The codebase uses a BaseRepository pattern for common CRUD operations.
While we won't extend BaseRepository for this story (due to tool_registry unique fields), we should
follow the same patterns:

```typescript
export abstract class BaseRepository<T> {
  constructor(
    protected pool: Pool,
    protected tableName: string
  ) {}

  async findById(id: string, tenantId?: string): Promise<T | null> {
    // Parameterized queries
    const result = await this.pool.query(query, params);
    return result.rows[0] || null;
  }
}
```

**Key Principles:**

- Accept Pool in constructor (dependency injection)
- Use parameterized queries (`$1, $2, ...`) to prevent SQL injection
- Return domain objects (TypeScript interfaces), not raw database rows
- Map snake_case columns to camelCase in TypeScript

### Database Connection

[Source: architecture/backend-architecture.md#data-access-layer]

The repository receives a `Pool` instance from `pg`:

```typescript
import { Pool, QueryResult } from 'pg';

export class ToolRegistryRepository {
  constructor(private pool: Pool) {}

  async findAll(): Promise<ToolRegistryRecord[]> {
    const result = await this.pool.query('SELECT * FROM tool_registry ORDER BY created_at DESC');
    return result.rows.map(this.mapRowToRecord);
  }
}
```

### Project Structure

[Source: architecture/unified-project-structure.md]

```
apps/api/src/
├── repositories/
│   ├── tool-registry.repository.ts   # <-- New file
│   ├── users.repository.ts           # Existing pattern
│   ├── base.repository.ts            # Existing base class
│   └── index.ts                      # Export all repositories
├── services/                         # Service layer (Epic 30.2)
└── controllers/                      # Controllers (Epic 30.2)

apps/api/tests/unit/
└── repositories/
    ├── tool-registry.repository.test.ts   # <-- New test file
    └── users.repository.test.ts           # Existing pattern
```

### Type Safety with Shared Package

[Source: architecture/coding-standards.md#critical-fullstack-rules]

**CRITICAL:** Always import types from `@nodeangularfullstack/shared`:

```typescript
import { ToolRegistryRecord, CreateToolInput, UpdateToolInput } from '@nodeangularfullstack/shared';
```

These types were created in Story 30.1.1 and must be built before use:

```bash
npm run build:shared
```

### SQL Injection Prevention

[Source: architecture/coding-standards.md#critical-fullstack-rules]

**CRITICAL:** Use parameterized queries to prevent SQL injection:

```typescript
// ✅ CORRECT - Parameterized query
const result = await this.pool.query('SELECT * FROM tool_registry WHERE tool_id = $1', [toolId]);

// ❌ WRONG - SQL injection risk!
const result = await this.pool.query(`SELECT * FROM tool_registry WHERE tool_id = '${toolId}'`);
```

### Update Method Pattern

The `update()` method should build dynamic SET clauses only for provided fields:

```typescript
async update(toolId: string, input: UpdateToolInput): Promise<ToolRegistryRecord> {
  const updates: string[] = [];
  const values: any[] = [];
  let paramCount = 1;

  if (input.name !== undefined) {
    updates.push(`name = $${paramCount++}`);
    values.push(input.name);
  }
  if (input.status !== undefined) {
    updates.push(`status = $${paramCount++}`);
    values.push(input.status);
  }
  // ... more fields ...

  updates.push(`updated_at = CURRENT_TIMESTAMP`);
  values.push(toolId);

  const query = `
    UPDATE tool_registry
    SET ${updates.join(', ')}
    WHERE tool_id = $${paramCount}
    RETURNING *
  `;

  const result = await this.pool.query(query, values);

  if (result.rows.length === 0) {
    throw new Error(`Tool '${toolId}' not found`);
  }

  return this.mapRowToRecord(result.rows[0]);
}
```

### Row Mapping Pattern

Convert snake_case database columns to camelCase TypeScript:

```typescript
private mapRowToRecord(row: any): ToolRegistryRecord {
  return {
    id: row.id,
    toolId: row.tool_id,           // snake_case → camelCase
    name: row.name,
    description: row.description,
    version: row.version,
    icon: row.icon,
    route: row.route,
    apiBase: row.api_base,         // snake_case → camelCase
    permissions: row.permissions,
    status: row.status,
    isExported: row.is_exported,   // snake_case → camelCase
    exportedAt: row.exported_at,   // snake_case → camelCase
    serviceUrl: row.service_url,   // snake_case → camelCase
    databaseName: row.database_name, // snake_case → camelCase
    manifestJson: row.manifest_json, // snake_case → camelCase
    createdAt: row.created_at,     // snake_case → camelCase
    updatedAt: row.updated_at,     // snake_case → camelCase
    createdBy: row.created_by,     // snake_case → camelCase
  };
}
```

### Documentation Standards

[Source: architecture/coding-standards.md#documentation-standards]

**JSDoc Example for Repository:**

```typescript
/**
 * Repository for tool registry data access.
 * Provides CRUD operations and specialized queries for tool discovery.
 *
 * @example
 * const repository = new ToolRegistryRepository(pool);
 * const tools = await repository.findAll();
 */
export class ToolRegistryRepository {
  /**
   * Finds a tool by its unique tool ID.
   *
   * @param toolId - The tool's unique identifier (e.g., "inventory-tracker")
   * @returns The tool record if found, null otherwise
   * @throws {Error} If database query fails
   *
   * @example
   * const tool = await repository.findById('inventory-tracker');
   * if (tool) {
   *   console.log(`Found tool: ${tool.name}`);
   * }
   */
  async findById(toolId: string): Promise<ToolRegistryRecord | null> {
    // Implementation
  }
}
```

### Testing

[Source: architecture/testing-strategy.md#backend-tests]

**Unit Test Organization:**

- Location: `apps/api/tests/unit/repositories/`
- Framework: Jest with TypeScript
- Mock database with `jest.fn()`

**Repository Test Pattern:**

```typescript
import { ToolRegistryRepository } from '../../../src/repositories/tool-registry.repository';
import { Pool } from 'pg';

describe('ToolRegistryRepository', () => {
  let repository: ToolRegistryRepository;
  let mockPool: jest.Mocked<Pool>;

  beforeEach(() => {
    // Create mock pool
    mockPool = {
      query: jest.fn(),
    } as any;

    repository = new ToolRegistryRepository(mockPool);
  });

  describe('findAll', () => {
    it('should return all tools ordered by created_at DESC', async () => {
      const mockRows = [
        { tool_id: 'tool-1', name: 'Tool 1' /* ... */ },
        { tool_id: 'tool-2', name: 'Tool 2' /* ... */ },
      ];
      mockPool.query.mockResolvedValue({ rows: mockRows } as any);

      const result = await repository.findAll();

      expect(result).toHaveLength(2);
      expect(result[0].toolId).toBe('tool-1');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('ORDER BY created_at DESC')
      );
    });
  });

  describe('findById', () => {
    it('should return tool if found', async () => {
      const mockRow = { tool_id: 'test-tool', name: 'Test Tool' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.findById('test-tool');

      expect(result).not.toBeNull();
      expect(result?.toolId).toBe('test-tool');
      expect(mockPool.query).toHaveBeenCalledWith(expect.stringContaining('WHERE tool_id = $1'), [
        'test-tool',
      ]);
    });

    it('should return null if not found', async () => {
      mockPool.query.mockResolvedValue({ rows: [] } as any);

      const result = await repository.findById('nonexistent');

      expect(result).toBeNull();
    });
  });

  describe('create', () => {
    it('should insert tool and return record', async () => {
      const input = {
        toolId: 'new-tool',
        name: 'New Tool',
        version: '1.0.0',
        route: '/tools/new-tool',
        apiBase: '/api/tools/new-tool',
        manifestJson: {
          /* ... */
        },
        createdBy: 'user-id',
      };

      const mockRow = { tool_id: 'new-tool' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.create(input);

      expect(result.toolId).toBe('new-tool');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('INSERT INTO tool_registry'),
        expect.arrayContaining(['new-tool', 'New Tool'])
      );
    });
  });
});
```

**Coverage Requirements:**

- Minimum 90% statement coverage
- Test both success and error paths
- Verify SQL query structure (parameterization, ORDER BY, WHERE clauses)
- Test edge cases (null, empty strings, special characters)

### Error Handling Pattern

```typescript
async findById(toolId: string): Promise<ToolRegistryRecord | null> {
  try {
    const query = 'SELECT * FROM tool_registry WHERE tool_id = $1';
    const result = await this.pool.query(query, [toolId]);

    if (result.rows.length === 0) {
      return null; // Not an error, just not found
    }

    return this.mapRowToRecord(result.rows[0]);
  } catch (error) {
    // Log error with context
    console.error('Error finding tool by ID:', { toolId, error });
    throw new Error(`Failed to find tool: ${error.message}`);
  }
}
```

## Change Log

| Date       | Version | Description                                                                                                                                                                         | Author             |
| ---------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| 2025-10-23 | 1.0     | Initial story creation                                                                                                                                                              | Bob (Scrum Master) |
| 2025-10-24 | 1.1     | Implemented repository with 33 passing tests, completed                                                                                                                             | James (Dev Agent)  |
| 2025-10-24 | 1.2     | QA review: CONCERNS gate (90/100), Ready for Done recommended. No code fixes applied - issues deferred to future code quality epic per QA guidance to maintain codebase consistency | James (Dev Agent)  |

## Dev Agent Record

### Agent Model Used

Claude Code (Sonnet 4.5) - Dev Agent (James)

### Debug Log References

**QA Review Analysis (2025-10-24)**:

- Gate Status: CONCERNS (Quality Score: 90/100)
- Must Fix Items: 0 (no blocking issues)
- QA Recommended Status: Ready for Done
- Decision: No code fixes applied per QA guidance
- Rationale: Issues are "consistent with existing codebase patterns" and should be addressed in
  future code quality epic to avoid creating codebase inconsistency

### Completion Notes List

- ✅ Created ToolRegistryRepository with full CRUD operations following BaseRepository patterns
- ✅ Implemented all specialized query methods (findByStatus, findExported, findNonExported, search)
- ✅ Used parameterized queries throughout to prevent SQL injection
- ✅ Added comprehensive JSDoc documentation with usage examples
- ✅ Created 33 unit tests with 100% test coverage - all passing
- ✅ Tested edge cases including SQL injection attempts, null values, duplicate keys
- ✅ Followed existing repository patterns (databaseService.getPool(), client management)
- ✅ Used snake_case in types to match database schema (no camelCase conversion needed)
- ✅ Hard delete implementation (schema has no is_active column)
- ✅ Dynamic UPDATE query builder for partial updates
- ✅ Typecheck passed with no errors
- ✅ Created central repository index file for exports
- ✅ QA review completed: All ACs met, no security/reliability issues, quality score 90/100
- ✅ Code quality issues deferred to future epic per QA recommendation (systematic refactoring
  required)

### File List

**New Files:**

- `apps/api/src/repositories/tool-registry.repository.ts` - Repository implementation (413 lines)
- `apps/api/src/repositories/index.ts` - Central repository exports (17 lines)
- `apps/api/tests/unit/repositories/tool-registry.repository.test.ts` - Unit tests (658 lines, 33
  tests)

**Modified Files:**

- None

## QA Results

### Review Date: 2025-10-24

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment**: The implementation is **solid and production-ready** with excellent test
coverage (33 passing tests, 100% coverage) and comprehensive documentation. All acceptance criteria
are fully met. The repository correctly implements the repository pattern with proper SQL injection
prevention, error handling, and connection management.

**Test Coverage Excellence**:

- 33 unit tests covering all CRUD operations and specialized queries
- Edge cases thoroughly tested (null values, SQL injection attempts, duplicate keys, special
  characters)
- 100% code coverage achieved (exceeds 90% requirement)
- All tests passing in CI/CD pipeline

**Architecture Strengths**:

- Proper repository pattern implementation following existing BaseRepository conventions
- Parameterized queries throughout (SQL injection prevention)
- Dynamic UPDATE query builder for partial updates
- Comprehensive JSDoc documentation with examples
- Proper client connection management (connect/release in try-finally blocks)
- Appropriate use of shared types from @nodeangularfullstack/shared

**Code Quality Concerns** (Non-blocking):

- Use of `any` type in error handlers (3 occurrences) - should use `unknown`
- `create()` method complexity: 14 (exceeds guideline max of 10)
- `update()` method length: 90 lines (exceeds guideline max of 50)
- Uses `||` instead of `??` for nullish coalescing (5 occurrences)
- Strict boolean expression issues per ESLint rules

**Important Context**: The lint errors are **consistent with existing repository patterns**
(tools.repository.ts has 22 similar issues). This indicates existing technical debt in the codebase
rather than story-specific problems. The implementation follows established patterns and is
appropriate for MVP.

### Refactoring Performed

No refactoring performed during this review. The code quality issues identified are consistent with
existing codebase patterns and should be addressed in a dedicated code quality epic rather than
blocking this story.

**Rationale**: Refactoring would:

1. Create inconsistency with other repositories (tools.repository.ts, forms.repository.ts)
2. Expand scope beyond story requirements
3. Potentially introduce risk without corresponding tests for the refactored structure

**Recommendation**: Track these improvements for a future "Code Quality & Technical Debt" epic that
addresses the pattern across all repositories simultaneously.

### Compliance Check

- **Coding Standards**: ✅ **PASS**
  - Types imported from @nodeangularfullstack/shared
  - Parameterized queries prevent SQL injection
  - JSDoc documentation comprehensive and follows standards
  - Minor strictness issues (any types, nullish coalescing) match existing patterns

- **Project Structure**: ✅ **PASS**
  - Repository location correct: apps/api/src/repositories/
  - Tests location correct: apps/api/tests/unit/repositories/
  - Follows naming conventions
  - Exported from central index file

- **Testing Strategy**: ✅ **PASS**
  - Jest with TypeScript for unit tests
  - Mocked database dependencies correctly
  - Exceeds coverage requirement (100% vs 90% required)
  - Test organization follows existing patterns

- **All ACs Met**: ✅ **PASS**
  - AC 1: Repository class implements CRUD ✅
  - AC 2: Required methods implemented ✅
  - AC 3: Specialized query methods ✅
  - AC 4: Error handling and validation ✅
  - AC 5: Unit tests ≥90% coverage ✅

### Requirements Traceability

**AC 1 → Repository Class**: Validated by test suite structure and constructor pattern **AC 2 → CRUD
Methods**: Validated by 15 tests covering findAll, findById, create, update, delete **AC 3 → Query
Methods**: Validated by 12 tests covering findByStatus, findExported, findNonExported, search **AC 4
→ Error Handling**: Validated by 6 tests covering database errors, validation errors, duplicate keys
**AC 5 → Test Coverage**: Validated by 33 passing tests with 100% coverage

**Coverage Gaps**: None - all acceptance criteria have comprehensive test validation

### Security Review

**Findings**: ✅ **No security vulnerabilities detected**

- **SQL Injection Prevention**: All queries use parameterized statements ($1, $2, etc.)
- **Input Validation**: Required fields validated; duplicate keys handled
- **Error Handling**: No sensitive information leakage in error messages
- **Data Integrity**: Foreign key constraints properly defined
- **Test Validation**: SQL injection attempts explicitly tested (lines 493-505 of test file)

### Performance Considerations

**Database Operations**: ✅ **Optimized**

- Connection pooling via databaseService.getPool()
- Proper client release in finally blocks ensures no connection leaks
- Migration includes appropriate indexes (tool_id, status, is_exported, created_at)

**Query Efficiency**: ✅ **Appropriate**

- WHERE clauses and ORDER BY optimized
- JSONB column for manifest provides flexibility without schema bloat
- No N+1 query patterns detected

**Scalability Notes**:

- Hard delete approach acceptable for MVP (no soft-delete complexity)
- ILIKE search adequate for small datasets; consider full-text search if tool registry grows to
  thousands of entries
- Current design supports expected Epic 30-33 workload

### NFR Validation Summary

- **Security**: ✅ **PASS** - Parameterized queries, proper error handling, foreign key constraints
- **Performance**: ✅ **PASS** - Appropriate indexing, connection pooling, optimized queries
- **Reliability**: ✅ **PASS** - Comprehensive error handling, client cleanup, transaction safety
- **Maintainability**: ⚠️ **CONCERNS** - Excellent docs, minor complexity/length guideline
  violations

### Improvements Checklist

**Future Code Quality Improvements** (Not blocking - recommend tracking in separate epic):

- [ ] Replace `any` types with `unknown` in error handlers (tool-registry.repository.ts:44,76,135)
- [ ] Extract validation logic from `create()` method to reduce complexity from 14 to ≤10
- [ ] Extract dynamic UPDATE builder to shared utility method to reduce method length
- [ ] Apply nullish coalescing operator (`??`) instead of logical OR (`||`) throughout
- [ ] Address lint errors across all repositories in dedicated code quality initiative

**Why not blocking**: These issues are consistent with existing repository patterns
(tools.repository.ts, forms.repository.ts) and represent existing technical debt rather than
story-specific problems. Addressing them in this story would create inconsistency with the rest of
the codebase.

### Files Modified During Review

None - no refactoring performed to maintain consistency with existing patterns.

**Note to Dev**: No File List updates needed.

### Gate Status

**Gate Decision**: ⚠️ **CONCERNS**

**Quality Score**: 90/100

**Gate File**: `docs/qa/gates/30.1.2-tool-registry-repository-implementation.yml`

**Summary**: Implementation is production-ready with excellent test coverage and documentation. Code
quality concerns (lint errors, method complexity) are consistent with existing codebase patterns and
acceptable for MVP. These should be addressed in a future code quality epic that refactors the
pattern across all repositories simultaneously.

**Top Issues** (All non-blocking):

- CODE-001: Use of `any` type in error handlers (medium severity)
- CODE-002: `create()` method complexity exceeds guideline (medium severity)
- CODE-003: `update()` method length exceeds guideline (medium severity)
- CODE-004: Use of `||` instead of `??` operator (low severity)

**NFR Status**: Security ✅ | Performance ✅ | Reliability ✅ | Maintainability ⚠️

### Recommended Status

✅ **Ready for Done**

**Rationale**:

1. All acceptance criteria fully met with comprehensive testing
2. No security or reliability issues
3. Code quality issues are consistent with existing patterns (not story-specific)
4. Implementation enables Epic 30 progression (Tool Registry Service & API - Story 30.2.1)
5. Technical debt should be addressed systematically across all repositories

**Next Steps**:

1. Story owner can mark as "Done"
2. Consider creating a dedicated epic for code quality improvements across all repositories
3. Proceed with Story 30.2.1 (Tool Registry Service & API implementation)
