# Story 30.1.4: Repository Unit Tests

## Status

Review

## Story

**As a** backend developer, **I want** comprehensive tests for the repository layer, **so that**
data access is reliable and maintainable.

## Acceptance Criteria

1. ✅ Unit tests for all repository methods
2. ✅ Test coverage ≥90%
3. ✅ Mock database queries (no real DB in unit tests)
4. ✅ Edge case testing (nulls, empty arrays, etc.)
5. ✅ All tests pass

## Tasks / Subtasks

- [x] **Task 1: Setup test infrastructure** (AC: 3)
  - [x] Verify Jest configuration exists: `apps/api/jest.config.js`
  - [x] Create test file: `apps/api/tests/unit/repositories/tool-registry.repository.test.ts`
  - [x] Import ToolRegistryRepository and types from shared package
  - [x] Create mock Pool with `jest.fn()` for all methods
  - [x] Setup beforeEach to initialize fresh repository instance with mock pool

- [x] **Task 2: Write tests for CRUD methods** (AC: 1, 3)
  - [x] Test `findAll()`:
    - [x] Should return all tools ordered by created_at DESC
    - [x] Should return empty array when no tools exist
    - [x] Should call pool.query with correct SQL
  - [x] Test `findById()`:
    - [x] Should return tool when found
    - [x] Should return null when not found
    - [x] Should use parameterized query ($1)
  - [x] Test `create()`:
    - [x] Should insert tool and return record
    - [x] Should call pool.query with INSERT statement
    - [x] Should pass parameters in correct order
  - [x] Test `update()`:
    - [x] Should update tool and return updated record
    - [x] Should build dynamic SET clause for provided fields only
    - [x] Should throw error when tool not found
  - [x] Test `delete()`:
    - [x] Should delete tool successfully
    - [x] Should call pool.query with DELETE statement

- [x] **Task 3: Write tests for query methods** (AC: 1, 3)
  - [x] Test `findByStatus()`:
    - [x] Should filter by status
    - [x] Should order by name ASC
    - [x] Should return empty array for non-existent status
  - [x] Test `findExported()`:
    - [x] Should return only tools where is_exported = true
  - [x] Test `search()`:
    - [x] Should search name and description with ILIKE
    - [x] Should add wildcard placeholders (%term%)
    - [x] Should return empty array when no matches

- [x] **Task 4: Write edge case and error tests** (AC: 4)
  - [x] Test null handling:
    - [x] Create tool with optional fields as null
    - [x] Update tool with null values
    - [x] Search with empty string
  - [x] Test empty arrays:
    - [x] Create tool with empty permissions array
    - [x] Update tool with empty permissions
  - [x] Test SQL injection attempts (verify parameterization):
    - [x] Search with SQL injection payload (e.g., "'; DROP TABLE users; --")
    - [x] Verify payload treated as literal string, not executed
  - [x] Test database errors:
    - [x] Mock pool.query to throw error
    - [x] Verify repository catches and re-throws with context

- [x] **Task 5: Write tests for row mapping** (AC: 1, 3)
  - [x] Test `mapRowToRecord()` (if public or via spy):
    - [x] Verify snake_case → camelCase conversion
    - [x] Verify all fields mapped correctly
    - [x] Verify JSONB parsed correctly

- [x] **Task 6: Run coverage report and ensure ≥90%** (AC: 2, 5)
  - [x] Run: `npm --workspace=apps/api run test:coverage`
  - [x] Verify tool-registry.repository.ts has ≥90% coverage
  - [x] Add missing tests for any uncovered branches
  - [x] Verify all tests pass: `npm --workspace=apps/api run test:unit`

- [x] **Task 7: Add test documentation** (AC: 1-5)
  - [x] Add describe/it blocks with clear test names
  - [x] Group related tests with nested describe blocks
  - [x] Add comments explaining complex test setups
  - [x] Document any test assumptions or constraints

## Dev Notes

### Testing Strategy Overview

[Source: architecture/testing-strategy.md#backend-tests]

**Testing Pyramid:**

- Unit Tests (this story): Test repository logic in isolation with mocked database
- Integration Tests (Epic 30.2): Test full API flow with real database

**Test Organization:**

```
apps/api/tests/
├── unit/
│   ├── repositories/
│   │   └── tool-registry.repository.test.ts   # <-- This story
│   ├── services/                              # Epic 30.2
│   └── utils/
└── integration/
    └── tool-registry-api.test.ts              # Epic 30.2
```

### Jest Configuration

[Source: architecture/tech-stack.md]

The project uses Jest 29+ with TypeScript support. Configuration exists at
`apps/api/jest.config.js`:

```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.test.ts'],
  collectCoverageFrom: ['src/**/*.ts'],
  coverageThreshold: {
    global: {
      statements: 90,
      branches: 90,
      functions: 90,
      lines: 90,
    },
  },
};
```

### Mocking Pattern

[Source: architecture/testing-strategy.md#backend-api-test]

**Mock pg.Pool with Jest:**

```typescript
import { Pool } from 'pg';
import { ToolRegistryRepository } from '../../../src/repositories/tool-registry.repository';

describe('ToolRegistryRepository', () => {
  let repository: ToolRegistryRepository;
  let mockPool: jest.Mocked<Pool>;

  beforeEach(() => {
    // Create mock pool with query method
    mockPool = {
      query: jest.fn(),
    } as any;

    // Create repository with mocked pool
    repository = new ToolRegistryRepository(mockPool);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // Tests go here
});
```

### Test Structure Pattern

**Arrange-Act-Assert Pattern:**

```typescript
describe('findAll', () => {
  it('should return all tools ordered by created_at DESC', async () => {
    // ARRANGE - Setup mock data
    const mockRows = [
      {
        tool_id: 'tool-1',
        name: 'Tool 1',
        description: 'First tool',
        version: '1.0.0',
        route: '/tools/tool-1',
        api_base: '/api/tools/tool-1',
        permissions: ['read'],
        status: 'active',
        is_exported: false,
        exported_at: null,
        service_url: null,
        database_name: null,
        manifest_json: {},
        created_at: new Date('2025-01-01'),
        updated_at: new Date('2025-01-01'),
        created_by: 'user-123',
      },
      // ... more mock rows
    ];

    mockPool.query.mockResolvedValue({ rows: mockRows } as any);

    // ACT - Call the method
    const result = await repository.findAll();

    // ASSERT - Verify results
    expect(result).toHaveLength(2);
    expect(result[0].toolId).toBe('tool-1'); // Verify snake_case → camelCase
    expect(mockPool.query).toHaveBeenCalledWith(
      expect.stringContaining('ORDER BY created_at DESC')
    );
  });
});
```

### Testing Query Parameterization (SQL Injection Prevention)

**Critical Test for Security:**

```typescript
describe('findById', () => {
  it('should use parameterized query to prevent SQL injection', async () => {
    const maliciousInput = "'; DROP TABLE users; --";
    mockPool.query.mockResolvedValue({ rows: [] } as any);

    await repository.findById(maliciousInput);

    // Verify query uses $1 placeholder, not string interpolation
    expect(mockPool.query).toHaveBeenCalledWith(
      expect.stringContaining('WHERE tool_id = $1'),
      [maliciousInput] // Malicious input passed as parameter, not concatenated
    );

    // Verify malicious input treated as literal string
    expect(mockPool.query).not.toHaveBeenCalledWith(expect.stringContaining(maliciousInput));
  });
});
```

### Testing Edge Cases

**Null and Empty Values:**

```typescript
describe('create', () => {
  it('should handle optional fields as null', async () => {
    const input = {
      toolId: 'minimal-tool',
      name: 'Minimal Tool',
      version: '1.0.0',
      route: '/tools/minimal',
      apiBase: '/api/tools/minimal',
      description: null, // Optional field
      icon: null, // Optional field
      permissions: [], // Empty array
      manifestJson: {},
      createdBy: 'user-123',
    };

    const mockRow = { tool_id: 'minimal-tool' /* ... */ };
    mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

    const result = await repository.create(input);

    expect(result.toolId).toBe('minimal-tool');
    // Verify null values passed correctly
    expect(mockPool.query).toHaveBeenCalledWith(
      expect.any(String),
      expect.arrayContaining([null, null, []])
    );
  });
});
```

**Database Errors:**

```typescript
describe('Error Handling', () => {
  it('should throw descriptive error when database query fails', async () => {
    mockPool.query.mockRejectedValue(new Error('Connection lost'));

    await expect(repository.findAll()).rejects.toThrow('Failed to');
  });
});
```

### Testing Update Method with Dynamic Fields

**Complex Test Case:**

```typescript
describe('update', () => {
  it('should build dynamic SET clause for provided fields only', async () => {
    const updates = {
      name: 'Updated Name',
      status: 'deprecated',
      // Other fields omitted - should not be in SET clause
    };

    const mockRow = {
      tool_id: 'test-tool',
      name: 'Updated Name',
      status: 'deprecated',
      /* ... */
    };
    mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

    await repository.update('test-tool', updates);

    expect(mockPool.query).toHaveBeenCalledWith(
      expect.stringMatching(/SET.*name = \$1.*status = \$2.*updated_at.*WHERE tool_id = \$3/),
      ['Updated Name', 'deprecated', 'test-tool']
    );
  });

  it('should throw error when tool not found', async () => {
    mockPool.query.mockResolvedValue({ rows: [] } as any); // Empty result

    await expect(repository.update('nonexistent', { name: 'New Name' })).rejects.toThrow(
      "Tool 'nonexistent' not found"
    );
  });
});
```

### Coverage Requirements

[Source: architecture/testing-strategy.md]

**Minimum Coverage Thresholds:**

- Statements: 90%
- Branches: 90%
- Functions: 90%
- Lines: 90%

**Running Coverage:**

```bash
# Run tests with coverage report
npm --workspace=apps/api run test:coverage

# Output shows coverage per file:
# tool-registry.repository.ts | 92.5% | 95% | 100% | 91%
```

**If Coverage < 90%:**

- Identify uncovered lines in coverage report (HTML report in `coverage/` folder)
- Add tests for missing branches (e.g., error paths, edge cases)
- Verify all public methods have at least one test

### Complete Test File Example from PRD

```typescript
// tests/unit/repositories/tool-registry.repository.test.ts
import { ToolRegistryRepository } from '../../../src/repositories/tool-registry.repository';
import { Pool } from 'pg';

describe('ToolRegistryRepository', () => {
  let repository: ToolRegistryRepository;
  let mockPool: jest.Mocked<Pool>;

  beforeEach(() => {
    mockPool = {
      query: jest.fn(),
    } as any;
    repository = new ToolRegistryRepository(mockPool);
  });

  describe('findAll', () => {
    it('should return all tools ordered by created_at DESC', async () => {
      const mockRows = [
        { tool_id: 'tool-1', name: 'Tool 1' /* ... */ },
        { tool_id: 'tool-2', name: 'Tool 2' /* ... */ },
      ];
      mockPool.query.mockResolvedValue({ rows: mockRows } as any);

      const result = await repository.findAll();

      expect(result).toHaveLength(2);
      expect(result[0].toolId).toBe('tool-1');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('ORDER BY created_at DESC')
      );
    });
  });

  describe('findById', () => {
    it('should return tool if found', async () => {
      const mockRow = { tool_id: 'test-tool', name: 'Test Tool' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.findById('test-tool');

      expect(result).not.toBeNull();
      expect(result?.toolId).toBe('test-tool');
    });

    it('should return null if not found', async () => {
      mockPool.query.mockResolvedValue({ rows: [] } as any);

      const result = await repository.findById('nonexistent');

      expect(result).toBeNull();
    });
  });

  describe('create', () => {
    it('should insert tool and return record', async () => {
      const input = {
        toolId: 'new-tool',
        name: 'New Tool',
        version: '1.0.0',
        route: '/tools/new-tool',
        apiBase: '/api/tools/new-tool',
        manifestJson: {
          /* ... */
        },
        createdBy: 'user-id',
      };

      const mockRow = { tool_id: 'new-tool' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.create(input);

      expect(result.toolId).toBe('new-tool');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('INSERT INTO tool_registry'),
        expect.arrayContaining(['new-tool', 'New Tool'])
      );
    });
  });

  describe('update', () => {
    it('should update tool and return updated record', async () => {
      const mockRow = { tool_id: 'test-tool', name: 'Updated Name' /* ... */ };
      mockPool.query.mockResolvedValue({ rows: [mockRow] } as any);

      const result = await repository.update('test-tool', { name: 'Updated Name' });

      expect(result.name).toBe('Updated Name');
      expect(mockPool.query).toHaveBeenCalledWith(
        expect.stringContaining('UPDATE tool_registry'),
        expect.any(Array)
      );
    });

    it('should throw error if tool not found', async () => {
      mockPool.query.mockResolvedValue({ rows: [] } as any);

      await expect(repository.update('nonexistent', { name: 'New Name' })).rejects.toThrow(
        "Tool 'nonexistent' not found"
      );
    });
  });

  describe('search', () => {
    it('should search by name and description', async () => {
      const mockRows = [{ tool_id: 'tool-1', name: 'Inventory Tool' /* ... */ }];
      mockPool.query.mockResolvedValue({ rows: mockRows } as any);

      const result = await repository.search('inventory');

      expect(result).toHaveLength(1);
      expect(mockPool.query).toHaveBeenCalledWith(expect.stringContaining('ILIKE'), [
        '%inventory%',
      ]);
    });
  });
});
```

### Test Commands

[Source: CLAUDE.md#testing-commands]

```bash
# Run all unit tests
npm --workspace=apps/api run test:unit

# Run specific test file
npm --workspace=apps/api run test -- --testPathPattern="tool-registry.repository.test.ts"

# Run with coverage
npm --workspace=apps/api run test:coverage

# Run in watch mode
npm --workspace=apps/api run test -- --watch

# Run silently (suppress console logs)
npm --workspace=apps/api run test -- --silent
```

### Dependencies on Previous Stories

**Story 30.1.2 Must Be Complete:**

- Repository implementation must exist before writing tests
- All methods (findAll, findById, create, update, delete, findByStatus, search) must be implemented

**Story 30.1.1 Must Be Complete:**

- Shared types (ToolRegistryRecord, CreateToolInput, UpdateToolInput) must exist
- Run `npm run build:shared` before testing if types were just created

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-10-23 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References

No debug log entries required - all tests passed on first run.

### Completion Notes List

- ✅ Created comprehensive unit tests for ToolRegistryRepository with 39 test cases
- ✅ Achieved 96% code coverage (exceeds 90% requirement):
  - Statements: 96%
  - Branches: 98.18%
  - Functions: 100%
  - Lines: 96%
- ✅ All acceptance criteria met:
  - AC1: Unit tests for all repository methods (findAll, findById, create, update, delete,
    findByStatus, findExported, findNonExported, search)
  - AC2: Test coverage ≥90% (achieved 96%)
  - AC3: Mock database queries (used jest.Mock with pg.Pool and PoolClient)
  - AC4: Edge case testing (nulls, empty arrays, SQL injection prevention, database errors)
  - AC5: All tests pass (39/39 passing)
- ✅ Added tests for all update method field branches (description, icon, route, api_base,
  permissions, manifest_json)
- ✅ Verified SQL injection prevention through parameterized queries
- ✅ Tested row mapping with proper type conversions (JSONB, dates, arrays)
- ✅ Documented tests with clear describe/it blocks and AAA pattern (Arrange-Act-Assert)

### File List

**Modified:**

- `apps/api/tests/unit/repositories/tool-registry.repository.test.ts` (enhanced from 33 to 39 tests,
  added update field branch coverage)

## QA Results

### Review Date: 2025-10-24

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Outstanding** - This repository implementation demonstrates exemplary software engineering
practices with comprehensive test coverage, proper separation of concerns, and robust error
handling.

**Strengths:**

1. **Test Coverage**: 96% overall (Statements: 96%, Branches: 98.18%, Functions: 100%, Lines: 96%) -
   exceeds 90% requirement
2. **Test Organization**: Well-structured with clear AAA (Arrange-Act-Assert) pattern throughout all
   39 test cases
3. **Security**: SQL injection prevention properly tested with parameterized queries ($1, $2
   placeholders)
4. **Edge Cases**: Comprehensive coverage including null handling, empty arrays, special characters,
   database errors
5. **Mock Strategy**: Proper use of Jest mocks for database layer isolation (Pool + PoolClient)
6. **Documentation**: Clear JSDoc comments on all public methods with usage examples

**Architecture Patterns:**

- Repository pattern correctly implemented with single responsibility
- Database service abstraction properly utilized via singleton pattern
- Type safety enforced through shared types package (@nodeangularfullstack/shared)
- Connection pooling properly managed with client.release() in finally blocks

### Refactoring Performed

**None required** - Code quality is already at production level. No refactoring performed.

### Compliance Check

- ✅ **Coding Standards**: Follows TypeScript best practices with strict mode, proper error
  handling, async/await patterns
- ✅ **Project Structure**: Correctly placed in `apps/api/src/repositories/` with corresponding
  tests in `apps/api/tests/unit/repositories/`
- ✅ **Testing Strategy**: Adheres to testing pyramid - unit tests properly isolated with mocked
  dependencies
- ✅ **All ACs Met**: All 5 acceptance criteria fully satisfied

### Requirements Traceability (Given-When-Then)

**AC1: Unit tests for all repository methods**

- **Given** repository with 9 public methods (findAll, findById, create, update, delete,
  findByStatus, findExported, findNonExported, search)
- **When** test suite executes
- **Then** all methods have comprehensive test coverage including happy path, error cases, and edge
  cases (39 test cases total)

**AC2: Test coverage ≥90%**

- **Given** coverage report for tool-registry.repository.ts
- **When** tests execute with --coverage flag
- **Then** achieve 96% statements, 98.18% branches, 100% functions, 96% lines (exceeds requirement)

**AC3: Mock database queries (no real DB in unit tests)**

- **Given** ToolRegistryRepository depends on pg.Pool and PoolClient
- **When** tests execute
- **Then** all database interactions use Jest mocks (mockPool.connect, mockClient.query) with no
  real database connection

**AC4: Edge case testing (nulls, empty arrays, etc.)**

- **Given** optional fields and edge conditions
- **When** tests execute with null values, empty arrays, SQL injection payloads, special characters
- **Then** repository handles all edge cases gracefully (tests lines 614-657)

**AC5: All tests pass**

- **Given** test suite with 39 test cases
- **When** npm test executes
- **Then** 39/39 tests pass with 0 failures (Test Suites: 1 passed, Tests: 39 passed)

### Test Architecture Assessment

**Test Level Appropriateness**: ✅ **Excellent**

- Unit tests correctly isolate repository logic from database layer
- No integration tests at this level (reserved for Epic 30.2 as documented)
- Mock strategy appropriate for repository pattern testing

**Test Design Quality**: ✅ **Outstanding**

- Consistent AAA pattern across all tests
- Descriptive test names that document behavior
- Proper grouping with nested describe blocks (findAll → happy path/errors/edge cases)
- Test data properly structured with realistic mock objects

**Edge Case Coverage**: ✅ **Comprehensive**

- Null optional fields (lines 614-635)
- Empty result arrays (lines 637-647)
- SQL injection prevention (line 599-611)
- Special characters in search (lines 649-656)
- Database errors (duplicate keys, connection failures, not found scenarios)
- Dynamic SET clause with varying field combinations (update method tests)

**Test Execution**: ✅ **Fast & Reliable**

- Execution time: 1.345s for 39 tests (~34ms per test)
- No flaky tests, all deterministic with mocked dependencies
- Proper cleanup with jest.clearAllMocks() in afterEach

### Non-Functional Requirements (NFRs)

**Security**: ✅ **PASS**

- SQL injection prevention verified via parameterized queries (lines 599-611)
- All user inputs pass through query parameters ($1, $2, etc.), never string concatenation
- Duplicate key constraint properly handled (PostgreSQL error code 23505)
- No sensitive data logged in error messages

**Performance**: ✅ **PASS**

- Connection pooling properly utilized (client.release() in all finally blocks)
- No N+1 query patterns
- Efficient queries with proper indexes assumed (ORDER BY, WHERE clauses)
- Test execution fast (1.3s for full suite)

**Reliability**: ✅ **PASS**

- Comprehensive error handling with descriptive error messages
- Client connections always released via try/finally blocks (prevents connection leaks)
- Null handling for optional fields prevents runtime errors
- Database service singleton pattern ensures single connection pool

**Maintainability**: ✅ **PASS**

- Clear separation of concerns (repository only handles data access)
- Excellent JSDoc documentation with usage examples
- DRY principle followed (mapRowToRecord method eliminates duplication)
- Type safety via TypeScript and shared types package

### Testability Evaluation

- ✅ **Controllability**: High - Mock pool/client allows full control over database responses
- ✅ **Observability**: High - All return values and query calls are verifiable via Jest assertions
- ✅ **Debuggability**: High - Descriptive test names and clear error messages aid debugging

### Technical Debt Identification

**No significant technical debt found.**

**Minor observations (not blocking):**

1. **Uncovered error paths**: 5 lines (140, 297, 321, 346, 376) in generic catch blocks remain
   uncovered, representing ~4% of code. These are acceptable as specific error scenarios (duplicate
   keys, not found) are already tested.
2. **Future enhancement**: Consider adding integration tests in Epic 30.2 to verify actual database
   queries against real PostgreSQL (as documented in Dev Notes).

### Security Review

**No security concerns.**

- ✅ SQL injection prevention properly implemented and tested
- ✅ Parameterized queries enforced throughout
- ✅ Error messages do not leak sensitive information
- ✅ Input validation occurs at service/controller layers (appropriate separation)

### Performance Considerations

**No performance concerns.**

- ✅ Connection pooling properly managed
- ✅ No blocking operations or unnecessary queries
- ✅ Client release handled correctly to prevent connection leaks
- ✅ Queries use indexes (assumed from ORDER BY and WHERE clauses)

### Files Modified During Review

**None** - No code changes required. Implementation and tests are production-ready.

### Gate Status

**Gate**: PASS → docs/qa/gates/30.1.4-repository-unit-tests.yml

**Quality Score**: 100/100

- 0 FAIL issues
- 0 CONCERNS issues
- Exceptional test coverage (96%)
- All acceptance criteria met
- Production-ready code quality

### Recommended Status

✅ **Ready for Done** - All acceptance criteria met, no changes required.

**Rationale**: This story represents a gold standard for repository layer testing with comprehensive
coverage, proper mocking, security testing, and edge case handling. The 96% coverage exceeds
requirements, and the 5 uncovered lines are acceptable generic error paths. Code quality is
production-ready with no refactoring needed.
