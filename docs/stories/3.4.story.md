# Story 3.4: JWT Multi-Tenant Token Handling

## Status
Draft

## Story
**As a** user in a multi-tenant system,
**I want** my authentication to work correctly within my tenant context,
**so that** I can access appropriate data and features for my organization.

## Acceptance Criteria
1. JWT tokens include tenant context when multi-tenancy is enabled
2. API endpoints automatically filter data based on token tenant information
3. Cross-tenant access prevention with clear error messages and logging
4. Token validation includes tenant status and permissions checking
5. Single-tenant mode operates without tenant token overhead or complexity

## Tasks / Subtasks
- [ ] Task 1: Enhance JWT token generation with tenant context (AC: 1)
  - [ ] Modify JWT payload to include tenant ID when multi-tenancy is enabled
  - [ ] Add tenant metadata to token claims (plan, features, limits)
  - [ ] Implement conditional tenant inclusion based on configuration
  - [ ] Create tenant-aware token refresh mechanism
  - [ ] Add tenant validation during token generation
- [ ] Task 2: Update authentication middleware for tenant-aware requests (AC: 2)
  - [ ] Extract tenant context from JWT tokens during authentication
  - [ ] Inject tenant information into request context for downstream use
  - [ ] Implement automatic tenant filtering in repository layer
  - [ ] Add tenant context to all database queries
  - [ ] Create tenant-aware API response filtering
- [ ] Task 3: Implement cross-tenant access prevention (AC: 3)
  - [ ] Add tenant boundary validation in all API endpoints
  - [ ] Create comprehensive cross-tenant access logging
  - [ ] Implement tenant mismatch error handling with clear messages
  - [ ] Add security audit trails for cross-tenant access attempts
  - [ ] Create tenant isolation monitoring and alerting
- [ ] Task 4: Enhance token validation with tenant status checking (AC: 4)
  - [ ] Validate tenant status (active/inactive) during token verification
  - [ ] Check tenant permissions and feature access in middleware
  - [ ] Implement tenant plan enforcement and limits checking
  - [ ] Add tenant-specific session timeout handling
  - [ ] Create tenant suspension and reactivation token handling
- [ ] Task 5: Optimize single-tenant mode for performance (AC: 5)
  - [ ] Skip tenant processing when multi-tenancy is disabled
  - [ ] Create performance-optimized token generation for single-tenant
  - [ ] Implement conditional middleware execution based on tenant mode
  - [ ] Add zero-overhead tenant skipping in database operations
  - [ ] Create single-tenant specific JWT validation path
- [ ] Task 6: Update frontend authentication to handle tenant context (AC: 1, 2)
  - [ ] Modify authentication service to extract tenant from tokens
  - [ ] Update API interceptors to include tenant context
  - [ ] Implement tenant-aware route guards and navigation
  - [ ] Add tenant context to application state management
  - [ ] Create tenant switching functionality for admin users

## Dev Notes

### Previous Story Insights
[Source: Story 3.1 completion notes (anticipated)]
- Enhanced tenant table with configuration and isolation settings
- Tenant-aware repository pattern with automatic filtering
- Row-Level Security policies for database-level tenant isolation

[Source: Story 3.2 completion notes (anticipated)]
- Environment configuration system with TENANT_TOKEN_ISOLATION flag
- Configuration validation for tenant-specific settings
- Feature flags for conditional tenant processing

[Source: Story 3.3 completion notes (anticipated)]
- Admin interface for tenant management and configuration
- Tenant metrics and validation systems
- Tenant onboarding and management workflows

### Technology Stack for JWT Multi-Tenancy
[Source: architecture/tech-stack.md]
- **Authentication**: JWT + Passport.js for token-based authentication
- **Backend Framework**: Express.js 4.19+ with TypeScript middleware
- **Frontend Framework**: Angular 20+ with JWT handling interceptors
- **Database**: PostgreSQL 15+ with tenant-aware queries
- **Validation**: Joi for token payload validation

### JWT Token Architecture
[Source: architecture/backend-architecture.md]
**Enhanced JWT Payload Structure:**
```typescript
interface JWTPayload {
  // Standard claims
  sub: string;          // User ID
  iat: number;          // Issued at
  exp: number;          // Expiration
  jti: string;          // JWT ID

  // User claims
  email: string;
  role: 'admin' | 'user' | 'readonly';
  permissions: string[];

  // Tenant claims (when multi-tenancy enabled)
  tenant?: {
    id: string;
    slug: string;
    plan: 'free' | 'starter' | 'professional' | 'enterprise';
    features: string[];
    limits: {
      maxUsers: number;
      maxStorage: number;
      maxApiCalls: number;
    };
    status: 'active' | 'suspended' | 'inactive';
  };
}
```

**JWT Service Implementation:**
```typescript
// services/auth/jwt.service.ts
import jwt from 'jsonwebtoken';
import { tenantConfig } from '../config/tenant.config';

export class JWTService {
  static async generateTokens(user: User, tenant?: Tenant): Promise<TokenPair> {
    const payload: JWTPayload = {
      sub: user.id,
      email: user.email,
      role: user.role,
      permissions: this.getUserPermissions(user.role),
    };

    // Include tenant context if multi-tenancy is enabled
    if (tenantConfig.tokenIsolation && tenant) {
      payload.tenant = {
        id: tenant.id,
        slug: tenant.slug,
        plan: tenant.plan,
        features: Object.keys(tenant.settings.features || {}),
        limits: {
          maxUsers: tenant.maxUsers,
          maxStorage: tenant.settings.limits?.maxStorage || 0,
          maxApiCalls: tenant.settings.limits?.maxApiCalls || 0
        },
        status: tenant.isActive ? 'active' : 'inactive'
      };
    }

    const accessToken = jwt.sign(payload, process.env.JWT_SECRET!, {
      expiresIn: '15m',
      issuer: 'nodeangular-api',
      audience: 'nodeangular-app'
    });

    const refreshToken = jwt.sign(
      { sub: user.id, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET!,
      { expiresIn: '7d' }
    );

    return { accessToken, refreshToken };
  }

  static async verifyToken(token: string): Promise<JWTPayload> {
    const payload = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;

    // Validate tenant status if present
    if (payload.tenant && payload.tenant.status !== 'active') {
      throw new ApiError(401, 'Tenant account is suspended');
    }

    return payload;
  }
}
```

### Authentication Middleware Enhancement
[Source: architecture/backend-architecture.md]
**Tenant-Aware Authentication Middleware:**
```typescript
// middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { JWTService } from '../services/jwt.service';
import { TenantService } from '../services/tenant.service';
import { ApiError } from '../utils/api-error';

export interface AuthRequest extends Request {
  user?: User;
  tenant?: Tenant;
  tenantContext?: {
    id: string;
    slug: string;
    features: string[];
    limits: Record<string, number>;
  };
}

export const authenticate = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const token = extractToken(req);

    if (!token) {
      throw new ApiError(401, 'No token provided');
    }

    const payload = await JWTService.verifyToken(token);

    // Get user data
    const user = await UsersService.findById(payload.sub);
    if (!user || !user.isActive) {
      throw new ApiError(401, 'Invalid token');
    }

    req.user = user;

    // Handle tenant context if present in token
    if (payload.tenant && tenantConfig.multiTenancyEnabled) {
      // Verify tenant still exists and is active
      const tenant = await TenantService.findById(payload.tenant.id);
      if (!tenant || !tenant.isActive) {
        throw new ApiError(401, 'Tenant account is inactive');
      }

      req.tenant = tenant;
      req.tenantContext = {
        id: payload.tenant.id,
        slug: payload.tenant.slug,
        features: payload.tenant.features,
        limits: payload.tenant.limits
      };

      // Validate user still belongs to tenant
      if (user.tenantId !== tenant.id) {
        throw new ApiError(403, 'User no longer belongs to tenant');
      }
    }

    next();
  } catch (error) {
    next(error);
  }
};

export const requireTenantAccess = (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  if (!req.tenantContext && tenantConfig.multiTenancyEnabled) {
    throw new ApiError(403, 'Tenant access required');
  }

  next();
};
```

### Project Structure for JWT Multi-Tenancy
[Source: architecture/unified-project-structure.md]
**Backend Files:**
- JWT service: `apps/api/src/services/auth/jwt.service.ts`
- Auth middleware: `apps/api/src/middleware/auth.middleware.ts`
- Tenant middleware: `apps/api/src/middleware/tenant.middleware.ts`
- Auth utilities: `apps/api/src/utils/jwt.utils.ts`

**Frontend Files:**
- Auth service: `apps/web/src/app/core/auth/auth.service.ts`
- Auth interceptor: `apps/web/src/app/core/auth/auth.interceptor.ts`
- Tenant service: `apps/web/src/app/core/auth/tenant.service.ts`
- Auth guards: `apps/web/src/app/core/auth/guards/`

### Repository Layer Tenant Integration
**Enhanced Base Repository with Tenant Filtering:**
```typescript
// repositories/base.repository.ts
export abstract class BaseRepository<T> {
  constructor(
    protected pool: Pool,
    protected tableName: string
  ) {}

  async findById(id: string, tenantContext?: TenantContext): Promise<T | null> {
    let query = `SELECT * FROM ${this.tableName} WHERE id = $1`;
    const params: any[] = [id];

    // Apply tenant filtering if multi-tenancy is enabled
    if (tenantContext && this.supportsTenancy()) {
      query += ' AND tenant_id = $2';
      params.push(tenantContext.id);
    }

    const result = await this.pool.query(query, params);
    return result.rows[0] || null;
  }

  async findMany(
    filters: Record<string, any>,
    tenantContext?: TenantContext
  ): Promise<T[]> {
    let query = `SELECT * FROM ${this.tableName} WHERE 1=1`;
    const params: any[] = [];
    let paramCount = 0;

    // Apply tenant filtering first
    if (tenantContext && this.supportsTenancy()) {
      paramCount++;
      query += ` AND tenant_id = $${paramCount}`;
      params.push(tenantContext.id);
    }

    // Apply other filters
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined) {
        paramCount++;
        query += ` AND ${key} = $${paramCount}`;
        params.push(value);
      }
    });

    const result = await this.pool.query(query, params);
    return result.rows;
  }

  protected supportsTenancy(): boolean {
    return ['users', 'audit_logs', 'sessions'].includes(this.tableName);
  }
}
```

### Frontend Authentication Service
[Source: architecture/frontend-architecture.md]
**Angular Auth Service with Tenant Support:**
```typescript
// core/auth/auth.service.ts
import { Injectable, signal, computed, inject } from '@angular/core';
import { Router } from '@angular/router';
import { ApiClient } from '../api/api.client';
import { JWTPayload, LoginResponse, User, Tenant } from '@shared/models';

@Injectable({ providedIn: 'root' })
export class AuthService {
  private readonly api = inject(ApiClient);
  private readonly router = inject(Router);

  private readonly userSignal = signal<User | null>(null);
  private readonly tenantSignal = signal<Tenant | null>(null);
  private readonly tokenSignal = signal<string | null>(null);

  readonly user = this.userSignal.asReadonly();
  readonly tenant = this.tenantSignal.asReadonly();
  readonly isAuthenticated = computed(() => !!this.userSignal());
  readonly hasTenantContext = computed(() => !!this.tenantSignal());

  async login(email: string, password: string): Promise<void> {
    const response = await this.api.post<LoginResponse>('/auth/login', {
      email,
      password
    }).toPromise();

    if (response?.data) {
      this.setAuthData(response.data);
    }
  }

  async logout(): Promise<void> {
    try {
      await this.api.post('/auth/logout', {}).toPromise();
    } finally {
      this.clearAuthData();
      this.router.navigate(['/auth/login']);
    }
  }

  private setAuthData(data: LoginResponse): void {
    const { user, accessToken, tenant } = data;

    // Store tokens
    localStorage.setItem('accessToken', accessToken);
    this.tokenSignal.set(accessToken);

    // Decode and validate token
    const payload = this.decodeToken(accessToken);

    // Set user and tenant data
    this.userSignal.set(user);

    if (payload.tenant && tenant) {
      this.tenantSignal.set(tenant);
    }
  }

  private decodeToken(token: string): JWTPayload {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload as JWTPayload;
    } catch (error) {
      throw new Error('Invalid token format');
    }
  }

  private clearAuthData(): void {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
    this.tokenSignal.set(null);
    this.userSignal.set(null);
    this.tenantSignal.set(null);
  }

  getTenantContext(): TenantContext | null {
    const tenant = this.tenantSignal();
    return tenant ? {
      id: tenant.id,
      slug: tenant.slug,
      features: Object.keys(tenant.settings.features || {}),
      limits: tenant.settings.limits || {}
    } : null;
  }
}
```

### Cross-Tenant Access Prevention
**Security Audit Middleware:**
```typescript
// middleware/tenant-security.middleware.ts
export const auditTenantAccess = (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  // Log all tenant-aware requests for security monitoring
  if (req.tenantContext) {
    const auditLog = {
      userId: req.user?.id,
      tenantId: req.tenantContext.id,
      action: `${req.method} ${req.path}`,
      ipAddress: req.ip,
      userAgent: req.get('User-Agent'),
      timestamp: new Date()
    };

    // Async logging (don't block request)
    setImmediate(() => {
      AuditService.logTenantAccess(auditLog);
    });
  }

  next();
};

export const preventCrossTenantAccess = (resourceTenantId: string) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.tenantContext) {
      throw new ApiError(403, 'Tenant context required');
    }

    if (req.tenantContext.id !== resourceTenantId) {
      // Log security violation
      SecurityAuditService.logCrossTenantAttempt({
        userId: req.user?.id,
        requestedTenantId: resourceTenantId,
        actualTenantId: req.tenantContext.id,
        endpoint: req.path,
        ipAddress: req.ip
      });

      throw new ApiError(403, 'Access denied: Resource belongs to different tenant');
    }

    next();
  };
};
```

### API Specification Updates
[Source: architecture/api-specification.md]
**Enhanced Authentication Responses:**
```yaml
components:
  schemas:
    LoginResponse:
      type: object
      properties:
        accessToken:
          type: string
          description: JWT access token with tenant context
        refreshToken:
          type: string
        user:
          $ref: '#/components/schemas/User'
        tenant:
          $ref: '#/components/schemas/Tenant'
          description: Present when multi-tenancy is enabled

    TenantContext:
      type: object
      properties:
        id:
          type: string
          format: uuid
        slug:
          type: string
        features:
          type: array
          items:
            type: string
        limits:
          type: object
          additionalProperties:
            type: number
```

## Testing

### Test File Locations
[Source: architecture/testing-strategy.md]
- **Backend JWT Tests**: `apps/api/tests/unit/services/jwt.test.ts`
- **Middleware Tests**: `apps/api/tests/unit/middleware/auth.test.ts`
- **Integration Tests**: `apps/api/tests/integration/auth-tenant.test.ts`
- **Frontend Auth Tests**: `apps/web/src/app/core/auth/**/*.spec.ts`

### Testing Requirements
- JWT token generation with tenant context
- Token validation and tenant status checking
- Cross-tenant access prevention testing
- Single-tenant mode performance validation
- Frontend auth service tenant handling
- Security audit logging verification
- Token refresh with tenant validation

### Test Examples Pattern
```typescript
// JWT Multi-Tenancy Testing
describe('JWT Multi-Tenant Token Handling', () => {
  describe('Token Generation', () => {
    it('should include tenant context when multi-tenancy enabled', async () => {
      process.env.ENABLE_MULTI_TENANCY = 'true';
      process.env.TENANT_TOKEN_ISOLATION = 'true';

      const user = await createTestUser({ tenantId: 'tenant-1' });
      const tenant = await createTestTenant({ id: 'tenant-1' });

      const { accessToken } = await JWTService.generateTokens(user, tenant);
      const payload = jwt.decode(accessToken) as JWTPayload;

      expect(payload.tenant).toBeDefined();
      expect(payload.tenant.id).toBe('tenant-1');
      expect(payload.tenant.plan).toBe(tenant.plan);
    });

    it('should exclude tenant context in single-tenant mode', async () => {
      process.env.ENABLE_MULTI_TENANCY = 'false';

      const user = await createTestUser();
      const { accessToken } = await JWTService.generateTokens(user);
      const payload = jwt.decode(accessToken) as JWTPayload;

      expect(payload.tenant).toBeUndefined();
    });
  });

  describe('Cross-Tenant Access Prevention', () => {
    it('should prevent access to resources from different tenant', async () => {
      const tenant1User = await createTestUserWithToken({ tenantId: 'tenant-1' });
      const tenant2Resource = await createTestResource({ tenantId: 'tenant-2' });

      const response = await request(app)
        .get(`/api/v1/resources/${tenant2Resource.id}`)
        .set('Authorization', `Bearer ${tenant1User.token}`);

      expect(response.status).toBe(403);
      expect(response.body.error.message).toContain('different tenant');
    });

    it('should log cross-tenant access attempts', async () => {
      const logSpy = jest.spyOn(SecurityAuditService, 'logCrossTenantAttempt');

      const tenant1User = await createTestUserWithToken({ tenantId: 'tenant-1' });
      const tenant2Resource = await createTestResource({ tenantId: 'tenant-2' });

      await request(app)
        .get(`/api/v1/resources/${tenant2Resource.id}`)
        .set('Authorization', `Bearer ${tenant1User.token}`);

      expect(logSpy).toHaveBeenCalledWith({
        userId: tenant1User.id,
        requestedTenantId: 'tenant-2',
        actualTenantId: 'tenant-1',
        endpoint: expect.stringContaining('/resources/'),
        ipAddress: expect.any(String)
      });
    });
  });

  describe('Tenant Status Validation', () => {
    it('should reject tokens when tenant is suspended', async () => {
      const suspendedTenant = await createTestTenant({
        isActive: false,
        status: 'suspended'
      });
      const user = await createTestUser({ tenantId: suspendedTenant.id });
      const { accessToken } = await JWTService.generateTokens(user, suspendedTenant);

      const response = await request(app)
        .get('/api/v1/users/profile')
        .set('Authorization', `Bearer ${accessToken}`);

      expect(response.status).toBe(401);
      expect(response.body.error.message).toContain('suspended');
    });
  });
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-21 | 1.0 | Initial story creation for JWT multi-tenant token handling | Bob (Scrum Master) |