# Configuration Migration Guide\n\nGuide for migrating between different configuration modes and upgrading configuration schemas.\n\n## Table of Contents\n\n1. [Single-Tenant to Multi-Tenant Migration](#single-tenant-to-multi-tenant-migration)\n2. [Multi-Tenant to Single-Tenant Migration](#multi-tenant-to-single-tenant-migration)\n3. [Environment Migration](#environment-migration)\n4. [Configuration Schema Upgrades](#configuration-schema-upgrades)\n5. [Rollback Procedures](#rollback-procedures)\n6. [Validation and Testing](#validation-and-testing)\n\n---\n\n## Single-Tenant to Multi-Tenant Migration\n\n### Prerequisites\n\n- [ ] Database backup completed\n- [ ] Application downtime scheduled\n- [ ] New environment variables prepared\n- [ ] Database schema migration scripts ready\n- [ ] Testing environment validated\n\n### Step 1: Database Preparation\n\n```sql\n-- Add tenant_id column to existing tables\nALTER TABLE users ADD COLUMN tenant_id UUID;\nALTER TABLE user_sessions ADD COLUMN tenant_id UUID;\n-- Add other tables as needed\n\n-- Create tenants table\nCREATE TABLE tenants (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  name VARCHAR(255) NOT NULL,\n  slug VARCHAR(100) UNIQUE NOT NULL,\n  plan VARCHAR(50) DEFAULT 'free',\n  max_users INTEGER DEFAULT 5,\n  features JSONB DEFAULT '{}',\n  created_at TIMESTAMP DEFAULT NOW(),\n  updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Create default tenant for existing data\nINSERT INTO tenants (id, name, slug) \nVALUES (gen_random_uuid(), 'Default Tenant', 'default');\n\n-- Update existing records with default tenant ID\nUPDATE users SET tenant_id = (SELECT id FROM tenants WHERE slug = 'default');\n-- Repeat for other tables\n```\n\n### Step 2: Configuration Updates\n\n```bash\n# Current single-tenant configuration\nENABLE_MULTI_TENANCY=false\nDEFAULT_TENANT_ID=default\nTENANT_RLS_ENABLED=false\n\n# New multi-tenant configuration\nENABLE_MULTI_TENANCY=true\nDEFAULT_TENANT_ID=system\nTENANT_ISOLATION_LEVEL=row\nTENANT_RLS_ENABLED=true\nTENANT_CROSS_ACCESS_PREVENTION=true\nTENANT_AUDIT_LOGGING=true\nTENANT_TOKEN_ISOLATION=true\nTENANT_DATA_ENCRYPTION=false  # Enable later if needed\nTENANT_REQUIRE_VERIFICATION=true\nTENANT_DEFAULT_PLAN=free\nTENANT_MAX_USERS_DEFAULT=5\nTENANT_FEATURES_DEFAULT='{\"api_access\":true,\"file_storage\":true}'\n```\n\n### Step 3: Enable Row-Level Security (if using row-level isolation)\n\n```sql\n-- Enable RLS on tables\nALTER TABLE users ENABLE ROW LEVEL SECURITY;\nALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;\n\n-- Create RLS policies\nCREATE POLICY tenant_isolation_users ON users\n  USING (tenant_id = current_setting('app.current_tenant_id')::UUID);\n\nCREATE POLICY tenant_isolation_sessions ON user_sessions\n  USING (tenant_id = current_setting('app.current_tenant_id')::UUID);\n```\n\n### Step 4: Application Code Updates\n\n```typescript\n// Update authentication middleware to include tenant context\nexport const authMiddleware = async (req: Request, res: Response, next: NextFunction) => {\n  // ... existing auth logic\n  \n  if (tenantConfig.multiTenancyEnabled && tenantConfig.tokenIsolation) {\n    req.tenantId = decodedToken.tenantId;\n  } else {\n    req.tenantId = tenantConfig.defaultTenantId;\n  }\n  \n  next();\n};\n\n// Update database queries to include tenant context\nexport const findUserById = async (id: string, tenantId: string) => {\n  if (tenantConfig.multiTenancyEnabled) {\n    return await db.query('SELECT * FROM users WHERE id = $1 AND tenant_id = $2', [id, tenantId]);\n  } else {\n    return await db.query('SELECT * FROM users WHERE id = $1', [id]);\n  }\n};\n```\n\n### Step 5: Testing and Validation\n\n```bash\n# Test configuration validation\nnpm run test:config\n\n# Test database connectivity\nnpm run test:db\n\n# Test multi-tenant functionality\nnpm run test:integration -- --grep \"multi-tenant\"\n\n# Validate tenant isolation\nnpm run test:security -- --grep \"tenant-isolation\"\n```\n\n---\n\n## Multi-Tenant to Single-Tenant Migration\n\n### Prerequisites\n\n- [ ] Data consolidation plan (which tenant's data to keep)\n- [ ] Database backup completed\n- [ ] User migration strategy defined\n\n### Step 1: Data Consolidation\n\n```sql\n-- Option 1: Keep specific tenant's data\nDELETE FROM users WHERE tenant_id != 'specific-tenant-id';\nDELETE FROM user_sessions WHERE tenant_id != 'specific-tenant-id';\n\n-- Option 2: Merge all tenant data (remove tenant context)\nALTER TABLE users DROP COLUMN tenant_id;\nALTER TABLE user_sessions DROP COLUMN tenant_id;\n\n-- Remove tenant-specific tables\nDROP TABLE tenants;\n```\n\n### Step 2: Configuration Updates\n\n```bash\n# Change from multi-tenant to single-tenant\nENABLE_MULTI_TENANCY=false\nDEFAULT_TENANT_ID=consolidated\n\n# Disable multi-tenant features\nTENANT_RLS_ENABLED=false\nTENANT_CROSS_ACCESS_PREVENTION=false\nTENANT_AUDIT_LOGGING=false\nTENANT_TOKEN_ISOLATION=false\nTENANT_DATA_ENCRYPTION=false\n```\n\n### Step 3: Remove Row-Level Security\n\n```sql\n-- Disable RLS\nALTER TABLE users DISABLE ROW LEVEL SECURITY;\nALTER TABLE user_sessions DISABLE ROW LEVEL SECURITY;\n\n-- Drop RLS policies\nDROP POLICY IF EXISTS tenant_isolation_users ON users;\nDROP POLICY IF EXISTS tenant_isolation_sessions ON user_sessions;\n```\n\n---\n\n## Environment Migration\n\n### Development to Staging\n\n```bash\n# Copy development configuration\ncp .env.development .env.staging\n\n# Update environment-specific values\nsed -i 's/NODE_ENV=development/NODE_ENV=staging/' .env.staging\nsed -i 's/localhost/staging-db.company.com/' .env.staging\nsed -i 's/DB_SSL=false/DB_SSL=true/' .env.staging\n\n# Add staging-specific monitoring\necho \"SENTRY_DSN=https://staging-dsn@sentry.io/project\" >> .env.staging\n```\n\n### Staging to Production\n\n```bash\n# Use production template\ncp .env.production.example .env.production\n\n# Security checklist for production\n# - Change all default passwords\n# - Use strong JWT secrets\n# - Enable SSL everywhere\n# - Configure monitoring\n# - Enable all security features\n\n# Validate production configuration\nnpm run validate:config:production\n```\n\n---\n\n## Configuration Schema Upgrades\n\n### Version 1.0 to 1.1 (Adding Multi-Tenancy)\n\n```bash\n# Backup current configuration\ncp .env .env.backup.v1.0\n\n# Add new multi-tenancy variables\ncat >> .env << EOF\n\n# Multi-tenancy Configuration (v1.1)\nENABLE_MULTI_TENANCY=false\nDEFAULT_TENANT_ID=default\nTENANT_ISOLATION_LEVEL=row\nTENANT_RLS_ENABLED=false\nTENANT_CROSS_ACCESS_PREVENTION=false\nTENANT_AUDIT_LOGGING=false\nTENANT_TOKEN_ISOLATION=false\nTENANT_DATA_ENCRYPTION=false\nTENANT_REQUIRE_VERIFICATION=true\nTENANT_DEFAULT_PLAN=free\nTENANT_MAX_USERS_DEFAULT=5\nTENANT_FEATURES_DEFAULT={}\nEOF\n\n# Validate new schema\nnpm run validate:config\n```\n\n### Automated Schema Migration Script\n\n```typescript\n// scripts/migrate-config.ts\nimport { readFileSync, writeFileSync, existsSync } from 'fs';\nimport { parse } from 'dotenv';\n\ninterface ConfigMigration {\n  version: string;\n  migrate: (config: Record<string, string>) => Record<string, string>;\n}\n\nconst migrations: ConfigMigration[] = [\n  {\n    version: '1.1.0',\n    migrate: (config) => {\n      return {\n        ...config,\n        ENABLE_MULTI_TENANCY: config.ENABLE_MULTI_TENANCY || 'false',\n        DEFAULT_TENANT_ID: config.DEFAULT_TENANT_ID || 'default',\n        TENANT_ISOLATION_LEVEL: 'row',\n        TENANT_RLS_ENABLED: 'false',\n        TENANT_CROSS_ACCESS_PREVENTION: 'false',\n        TENANT_AUDIT_LOGGING: 'false',\n        TENANT_TOKEN_ISOLATION: 'false',\n        TENANT_DATA_ENCRYPTION: 'false',\n        TENANT_REQUIRE_VERIFICATION: 'true',\n        TENANT_DEFAULT_PLAN: 'free',\n        TENANT_MAX_USERS_DEFAULT: '5',\n        TENANT_FEATURES_DEFAULT: '{}',\n      };\n    },\n  },\n];\n\nexport const migrateConfiguration = (targetVersion: string) => {\n  if (!existsSync('.env')) {\n    throw new Error('.env file not found');\n  }\n  \n  // Create backup\n  const envContent = readFileSync('.env', 'utf8');\n  writeFileSync(`.env.backup.${Date.now()}`, envContent);\n  \n  // Parse current config\n  let config = parse(envContent);\n  \n  // Apply migrations\n  for (const migration of migrations) {\n    if (shouldApplyMigration(migration.version, targetVersion)) {\n      console.log(`Applying migration ${migration.version}...`);\n      config = migration.migrate(config);\n    }\n  }\n  \n  // Write updated config\n  const updatedContent = Object.entries(config)\n    .map(([key, value]) => `${key}=${value}`)\n    .join('\\n');\n    \n  writeFileSync('.env', updatedContent);\n  console.log('Configuration migration completed');\n};\n```\n\n---\n\n## Rollback Procedures\n\n### Configuration Rollback\n\n```bash\n# List available backups\nls -la .env.backup.*\n\n# Restore from backup\ncp .env.backup.1701234567890 .env\n\n# Validate restored configuration\nnpm run validate:config\n\n# Restart application\nnpm restart\n```\n\n### Database Rollback\n\n```sql\n-- For single-tenant to multi-tenant rollback\nBEGIN;\n\n-- Remove tenant-related columns\nALTER TABLE users DROP COLUMN IF EXISTS tenant_id;\nALTER TABLE user_sessions DROP COLUMN IF EXISTS tenant_id;\n\n-- Drop tenant tables\nDROP TABLE IF EXISTS tenants;\n\n-- Disable RLS\nALTER TABLE users DISABLE ROW LEVEL SECURITY;\nALTER TABLE user_sessions DISABLE ROW LEVEL SECURITY;\n\nCOMMIT;\n```\n\n### Application Rollback\n\n```bash\n# Stop current application\nnpm stop\n\n# Checkout previous version\ngit checkout previous-stable-tag\n\n# Restore configuration\ncp .env.backup.previous .env\n\n# Install dependencies for previous version\nnpm install\n\n# Start application\nnpm start\n```\n\n---\n\n## Validation and Testing\n\n### Pre-Migration Checklist\n\n- [ ] Configuration backup created\n- [ ] Database backup created\n- [ ] Migration scripts tested in development\n- [ ] Rollback procedure documented and tested\n- [ ] Downtime window scheduled and communicated\n- [ ] Monitoring and alerting configured\n\n### Post-Migration Validation\n\n```bash\n# Configuration validation\nnpm run validate:config\n\n# Database connectivity\nnpm run test:db:connection\n\n# Application functionality\nnpm run test:integration\n\n# Security validation\nnpm run test:security\n\n# Performance check\nnpm run test:performance\n```\n\n### Monitoring Migration Health\n\n```bash\n# Check application logs\ntail -f logs/application.log | grep -E \"(ERROR|WARN|tenant|config)\"\n\n# Monitor database connections\npsql -c \"SELECT count(*) FROM pg_stat_activity;\"\n\n# Check error rates\ncurl http://localhost:3000/health\n```\n\n---\n\n## Best Practices\n\n1. **Always create backups** before configuration changes\n2. **Test migrations in staging** before production\n3. **Use gradual rollouts** for major configuration changes\n4. **Monitor closely** after migrations\n5. **Document all changes** and rollback procedures\n6. **Validate configuration** at each step\n7. **Plan for rollback** scenarios\n8. **Communicate changes** to stakeholders\n9. **Use automation** for repeatable migrations\n10. **Keep migration scripts** version controlled\n\n---\n\n## Troubleshooting Common Issues\n\n### Configuration Validation Failures\n\n```bash\n# Check for syntax errors\nnpm run lint:config\n\n# Validate individual components\nnpm run validate:config:database\nnpm run validate:config:tenant\nnpm run validate:config:security\n```\n\n### Database Migration Issues\n\n```sql\n-- Check for conflicting data\nSELECT table_name, column_name \nFROM information_schema.columns \nWHERE column_name = 'tenant_id';\n\n-- Verify RLS policies\nSELECT schemaname, tablename, policyname, permissive, roles, cmd, qual \nFROM pg_policies;\n```\n\n### Application Startup Issues\n\n```bash\n# Check configuration consistency\nnpm run debug:config\n\n# Verify environment variables\nprintenv | grep -E \"(TENANT|DB|JWT)\"\n\n# Test individual components\nnpm run test:unit:config\n```"